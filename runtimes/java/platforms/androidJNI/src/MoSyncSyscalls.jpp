/* Copyright (C) 2010 MoSync AB

This program is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License, version 2, as published by
the Free Software Foundation.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
for more details.

You should have received a copy of the GNU General Public License
along with this program; see the file COPYING.  If not, write to the Free
Software Foundation, 59 Temple Place - Suite 330, Boston, MA
02111-1307, USA.
*/

#include "helpers.h"
#include "config_platform.h"
#include "generated/MAAPI_consts.h"

final class ImageCache
{
	Bitmap mBitmap;
	Canvas mCanvas;

	ImageCache(Canvas canvas, Bitmap bitmap)
	{
		mCanvas = canvas;
		mBitmap = bitmap;
	}
}

public ByteBuffer mMemDataSection;
ByteBuffer mResourceFile;

Canvas mCanvas;
Bitmap mBitmap;

int mWidth;
int mHeight;

int mClipLeft, mClipTop, mClipWidth, mClipHeight;

boolean mUsingFrameBuffer;
int mFrameBufferAddress;
int mFrameBufferSize;
Bitmap mFrameBufferBitmap;

ImageCache mDrawTargetScreen = null;
ImageCache mDrawTarget = null;
int mDrawTargetHandle = 0;

int mSoundVolume;
MediaPlayer mMediaPlayer;

Paint mPaint = new Paint();
Paint mBlitPaint = new Paint();

int mTextConsoleHeight;

boolean initSyscalls()
{
	SYSLOG("initSyscalls");
	 mUsingFrameBuffer = false;

	 mClipLeft = 0;
	 mClipTop = 0;
	 mClipWidth = mWidth;
	 mClipHeight = mHeight;

	 mPaint.setStyle(Paint.Style.FILL);
	 mPaint.setAntiAlias(false);
	 mPaint.setColor(0xffffffff);
	 
	 mBlitPaint.setAntiAlias(false);
	 mBlitPaint.setColor(0xffffffff);
	 mBlitPaint.setAlpha(255);
	 
	 mSoundVolume = 50;
	 
	 // Generates a default text height used for console text writing.
	 // This is used so that all text which is printed to the console
	 // gets the same text height.
	MAExtent e = maGetTextSize("abcdefghijklmnopqrstuvwxyz"+
													"ABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890");
	mTextConsoleHeight = EXTENT_Y(e);
	 
	 return true;
}

/**
* @brief maSetColor
*/
int maSetColor(int rgb)
{
	SYSLOG("maSetColor");

	int t = mPaint.getColor();
	mPaint.setColor(rgb);
	mPaint.setAlpha(255);
	return t;
}

/**
* @brief maSetClipRect
*/
void maSetClipRect(int left, int top, int width, int height)
{
	SYSLOG("maSetClipRect");

	mClipLeft = left;
	mClipTop = top;
	mClipWidth = width;
	mClipHeight = height;

	mCanvas.clipRect(left, top, left+width, top+height, Region.Op.REPLACE );
}

/**
* @brief maPlot
*/
void maPlot(int posX, int posY)
{
	SYSLOG("maPlot");

	mCanvas.drawPoint(posX, posY, mPaint);
}

/**
* @brief maLine
*/
void maLine(int startX, int startY, int endX, int endY)
{
	SYSLOG("maLine");

	mCanvas.drawLine(startX, startY, endX, endY, mPaint);
}

/**
* @brief maFillRect
*/
void maFillRect(int left, int top, int width, int height)
{
	SYSLOG("maFillRect");

	mCanvas.drawRect(left, top, left+width, top+height, mPaint);
}

/*
This implementation might seem a bit strange but it works so much better than using Canvas.drawVertices..
*/
/**
* @brief maFillTriangleStrip
*/
void maFillTriangleStrip(int address, int count)
{
	SYSLOG("maFillTriangleStrip");

	if(count < 3) maPanic(1,"maFillTriangleStrip takes more than 3 vertices");

	mMemDataSection.mark();
	mMemDataSection.position(address);

	IntBuffer ib = mMemDataSection.asIntBuffer();
	
	int[] vertices = new int[count*2];
	ib.get(vertices);
	
	Path path = new Path();

	int i = 0;
	
	int xa = vertices[i++];
	int ya = vertices[i++];

	int xb = vertices[i++];
	int yb = vertices[i++];
	for(;;) {
		int xc = vertices[i++];
		int yc = vertices[i++];
		path.moveTo(xa,ya);
		path.lineTo(xb,yb);
		path.lineTo(xc,yc);
		path.close();
		
		if(i >= count*2)
			break;
		xa = vertices[i++];
		ya = vertices[i++];
		path.moveTo(xb,yb);
		path.lineTo(xc,yc);
		path.lineTo(xa,ya);
		path.close();
		
		if(i >= count*2)
			break;
		xb = vertices[i++];
		yb = vertices[i++];
		path.moveTo(xc,yc);
		path.lineTo(xa,ya);
		path.lineTo(xb,yb);
		path.close();
		
		if(i >= count*2)
			break;			
	}
	mCanvas.drawPath(path, mPaint);
	
	mMemDataSection.reset();
	
}


/**
* @brief maFillTriangleFan
*/
void maFillTriangleFan(int address, int count)
{
	SYSLOG("maFillTriangleFan");

	if(count < 3) maPanic(1,"maFillTriangleFan takes more than 3 vertices");

	mMemDataSection.mark();
	mMemDataSection.position(address);

	IntBuffer ib = mMemDataSection.asIntBuffer();
	
	int[] vertices = new int[count*2];
	ib.get(vertices);
	
	Path path = new Path();

	int i = 0;
	
	int xa = vertices[i++];
	int ya = vertices[i++];

	int xb = vertices[i++];
	int yb = vertices[i++];
	for(;;) {
		int xc = vertices[i++];
		int yc = vertices[i++];
		path.moveTo(xa,ya);
		path.lineTo(xb,yb);
		path.lineTo(xc,yc);
		path.close();
		
		if(i >= count*2)
			break;
		xa = vertices[i++];
		ya = vertices[i++];
		path.moveTo(xa,ya);
		path.lineTo(xc,yc);
		path.lineTo(xb,yb);
		path.close();
		
		if(i >= count*2)
			break;			
	}
	mCanvas.drawPath(path, mPaint);
	
	mMemDataSection.reset();
}


Rect mTextSizeRect = new Rect();

/**
* @brief maGetTextSize - Gets the height in pixels of the string,
*
* Calculates the height in pixels of this string, as it's gonna 
* be drawn to the screen
*
* @param str	The string which the height should be calculated from
*
* @return the height in pixels
*/
int maGetTextSize(final String str)
{
	SYSLOG("maGetTextSize");
	
	mPaint.getTextBounds(str, 0, str.length(), mTextSizeRect);
	
	return EXTENT(mTextSizeRect.width(), mTextSizeRect.height());
}

/**
* @brief maGetTextSizeW - Gets the height in pixels of the string,
*
* Calculates the height in pixels of this string, as it's gonna 
* be drawn to the screen
*
* @param str	The string which the height should be calculated from
*
* @return the height in pixels
*/
int maGetTextSizeW(final String str)
{
	SYSLOG("maGetTextSizeW");
	
	mPaint.getTextBounds(str, 0, str.length(), mTextSizeRect);
	
	return EXTENT(mTextSizeRect.width(), mTextSizeRect.height());
}

/**
* @brief maDrawText - draws a string of text to the screen
*
* @param left		The left most pixel on which the text should be rendered
* @param top		The top most pixel on which the text should be rendered
*/
void maDrawText(int left, int top, final String str)
{
	SYSLOG("maDrawText");
	
	mCanvas.drawText(str, left, top+mTextConsoleHeight, mPaint);
}

/**
* @brief maDrawText - draws a string of text to the screen
*
* @param left		The left most pixel on which the text should be rendered
* @param top		The top most pixel on which the text should be rendered
*/
void maDrawTextW(int left, int top, final String str)
{
 	SYSLOG("maDrawTextW");
	
	mCanvas.drawText(str, left, top+mTextConsoleHeight, mPaint);
}

/**
* @brief maUpdateScreen
*/
void maUpdateScreen()
{
	//SYSLOG("maUpdateScreen");
	Canvas lockedCanvas = null;
	
	if (mMoSyncView == null) return;
	
	try 
	{
		lockedCanvas = mMoSyncView.mSurfaceHolder.lockCanvas();
		synchronized (mMoSyncView.mSurfaceHolder)
		{
			if (mUsingFrameBuffer)
			{				
				mMemDataSection.mark();
				mMemDataSection.position(mFrameBufferAddress);
				mFrameBufferBitmap.copyPixelsFromBuffer(mMemDataSection);
				mMemDataSection.reset();
				
				// Clear the screen.. in this case draw the canvas black
				lockedCanvas.drawRGB(0,0,0);
				
				// Blit the framebuffer
				lockedCanvas.drawBitmap(mFrameBufferBitmap, 0, 0, mBlitPaint);
			}
			else
			{
				if (null != lockedCanvas)
				{
					lockedCanvas.drawBitmap(mBitmap, 0, 0, mBlitPaint);
				}
			}
		}
	} 
	catch (Exception e)
	{
		logError("updateScreen Exception : " + e.toString(), e);
		return;
	}
		
	if (lockedCanvas != null)
	{
		mMoSyncView.mSurfaceHolder.unlockCanvasAndPost(lockedCanvas);
	}
	
}

/**
* @brief maResetBacklight
*/
void maResetBacklight()
{
	SYSLOG("maResetBacklight");
}

/**
* @brief maGetScrSize
*/
int maGetScrSize()
{
	SYSLOG("maGetScrSize");
	return EXTENT(mWidth, mHeight);
}

/**
* @brief maDrawImage
*/
void maDrawImage(int image, int left, int top)
{
	SYSLOG("maDrawImage");
	
	ImageCache imageResource = (ImageCache)mImageResources.get(new Integer(image));
	if (imageResource == null)
	{
		return;
	}

	mCanvas.drawBitmap(imageResource.mBitmap, left, top, null);
}

/**
* @brief _maDrawRGB
*/
void _maDrawRGB(int dstX, int dstY, int mem, int srcRectLeft, int srcRectTop, int srcRectWidth, int srcRectHeight, int scanLength)
{
	SYSLOG("maDrawRGB");

	int pixels[] = new int[srcRectWidth];
	
	mMemDataSection.mark();
	mMemDataSection.position(mem);

	IntBuffer ib = mMemDataSection.asIntBuffer();
	
	for(int y = 0; y < srcRectHeight; y++)
	{
		ib.position(y*scanLength);		
		
		ib.get(pixels);
		mCanvas.drawBitmap(pixels, 0, srcRectWidth, dstX, dstY+y, srcRectWidth, 1, true, mPaint);		
	}
	
	mMemDataSection.reset();
}

/**
 * Rectangle objects used for drawing in maDrawImageRegion().
 */
private Rect mMaDrawImageRegionTempSourceRect = new Rect();
private Rect mMaDrawImageRegionTempDestRect = new Rect();

#if 1 // New code
/**
 * @brief _maDrawImageRegion 
 *
 * Draw rectangular region of an image.
 *
 * @param image Handle to the image.
 * @param srcRectLeft Left coord of source rectangle.
 * @param srcRectTop Top coord of source rectangle.
 * @param srcRectWidth Width of source rectangle.
 * @param srcRectHeight Height of source rectangle.
 * @param dstLeft Left coord of destination point.
 * @param dstTop Top coord of destination point.
 * @param transformMode A TRANS_* constant.
 */
void _maDrawImageRegion(
	final int image, 
	final int srcRectLeft, 
	final int srcRectTop, 
	final int srcRectWidth, 
	final int srcRectHeight, 
	final int dstLeft, 
	final int dstTop, 
	final int transformMode)
{
	SYSLOG("_maDrawImageRegion");
	
	// Get image resource.
	ImageCache imageResource = (ImageCache)mImageResources.get(image);
	if (imageResource == null) { return; }

	// Get image dimension.
	final int imgHeight = imageResource.mBitmap.getHeight();
	final int imgWidth = imageResource.mBitmap.getWidth();
	
	// Make sure source rect is inside the image.
	// This is according to the syscall spec. 
	// TODO: Should we call maPanic()?
	if (srcRectLeft < 0) { return; }
	if (srcRectTop < 0) { return; }
	if (srcRectLeft + srcRectWidth > imgWidth) { return; }
	if (srcRectTop + srcRectHeight > imgHeight) { return; }
	
	// Set up image source rectangle.
	mMaDrawImageRegionTempSourceRect.left = srcRectLeft;
	mMaDrawImageRegionTempSourceRect.right = (srcRectLeft + srcRectWidth);
	mMaDrawImageRegionTempSourceRect.top = srcRectTop;
	mMaDrawImageRegionTempSourceRect.bottom = (srcRectTop + srcRectHeight);
	
	// Set up destination rectangle. 
	// We set origin to 0,0 and translate below.
	mMaDrawImageRegionTempDestRect.left = 0;
	mMaDrawImageRegionTempDestRect.right = srcRectWidth;
	mMaDrawImageRegionTempDestRect.top = 0;
	mMaDrawImageRegionTempDestRect.bottom = srcRectHeight;
	
	// Save the canvas matrix state.
	mCanvas.save(Canvas.MATRIX_SAVE_FLAG);
	
	// Set up canvas matrix for each transformation.
	// The transforms that mirror and rotate the image
	// might take some time to understand, because mirroring
	// flips the coordinate system, positive becomes negative,
	// rotation goes the other way, and so on.
    switch (transformMode)
	{
    	case TRANS_NONE:
    		mCanvas.translate(dstLeft, dstTop);
    		break;
			
    	case TRANS_ROT90:
    		mCanvas.translate(dstLeft + srcRectHeight, dstTop);
    		mCanvas.rotate(90);
    		break;
			
    	case TRANS_ROT180:
    		mCanvas.translate(dstLeft + srcRectWidth, dstTop + srcRectHeight);
    		mCanvas.rotate(180);
    		break;
			
    	case TRANS_ROT270:
    		mCanvas.translate(dstLeft, dstTop + srcRectWidth);
    		mCanvas.rotate(270);
    		break;
			
    	case TRANS_MIRROR:
    		mCanvas.translate(dstLeft + srcRectWidth, dstTop);
    		mCanvas.scale(-1, 1);
    		break;
			
    	case TRANS_MIRROR_ROT90:
    		mCanvas.translate(dstLeft + srcRectHeight, dstTop + srcRectWidth);
    		mCanvas.scale(-1, 1);
    		mCanvas.rotate(270);
    		break;
			
    	case TRANS_MIRROR_ROT180:
    		mCanvas.translate(dstLeft, dstTop + srcRectHeight);
    		mCanvas.scale(-1, 1);
    		mCanvas.rotate(180);
    		break;
			
    	case TRANS_MIRROR_ROT270:
    		mCanvas.translate(dstLeft, dstTop);
    		mCanvas.scale(-1, 1);
    		mCanvas.rotate(90);
			break;
			
		default:
			maPanic(0, "maDrawImageRegion - unsupported transform");
			break;
	}
		
	mCanvas.drawBitmap(
		imageResource.mBitmap, 
		mMaDrawImageRegionTempSourceRect, 
		mMaDrawImageRegionTempDestRect, 
		null);
	
	// Restore canvas matrix.
	mCanvas.restore();
}
#endif

#if 0 // Old code TODO: Delete
/**
 * @brief _maDrawImageRegion 
 *
 * Draw rectangular region of an image.
 *
 * @param image Handle to the image.
 * @param srcRectLeft Left coord of source rectangle.
 * @param srcRectTop Top coord of source rectangle.
 * @param srcRectWidth Width of source rectangle.
 * @param srcRectHeight Height of source rectangle.
 * @param dstLeft Left coord of destination point.
 * @param dstTop Top coord of destination point.
 * @param transformMode A TRANS_* constant.
 */
void _maDrawImageRegion(
	int image, 
	int srcRectLeft, 
	int srcRectTop, 
	int srcRectWidth, 
	int srcRectHeight, 
	int dstLeft, 
	int dstTop, 
	int transformMode)
{
	SYSLOG("maDrawImageRegion");

	ImageCache imageResource = (ImageCache)mImageResources.get(image);
	if (imageResource == null)
	{
		return;
	}

	// srcRectTop must be less than the image height.
	final int imgHeight = imageResource.mBitmap.getHeight();
	if (srcRectTop > imgHeight) 
	{
		return;
	}
	
	final int imgWidth = imageResource.mBitmap.getWidth();
	if (srcRectLeft > imgWidth) 
	{
		return;
	}
	
	if (srcRectTop < 0)
	{
		srcRectHeight += srcRectTop;
		srcRectTop = 0;
	}
	
	if (srcRectLeft < 0)
	{
		srcRectWidth += srcRectLeft;
		srcRectLeft = 0;
	}
	
	if (srcRectTop + srcRectHeight > imgHeight)
	{
		srcRectHeight = imgHeight - srcRectTop;
	}
	
	if (srcRectLeft + srcRectWidth > imgWidth)
	{
		srcRectWidth = imgWidth - srcRectLeft;
	}
	
	if (srcRectWidth <= 0 || srcRectHeight <= 0) 
	{
		return;
	}

	if (transformMode == TRANS_NONE)
	{
		mCanvas.clipRect(dstLeft, dstTop, dstLeft + srcRectWidth, dstTop + srcRectHeight, Region.Op.INTERSECT);
		mCanvas.drawBitmap(imageResource.mBitmap, dstLeft - srcRectLeft, dstTop - srcRectTop, mPaint);
		mCanvas.clipRect(mClipLeft, mClipTop, mClipLeft + mClipWidth, mClipTop + mClipHeight, Region.Op.REPLACE);
		return;
	}
	else
	{
		boolean mirror = false;
		int rotation = 0;

		switch (transformMode)
		{
		case TRANS_ROT90:
			rotation = 90;
			break;
		case TRANS_ROT180:
			rotation = 180;
			break;
		case TRANS_ROT270:
			rotation = 270;
			break;
		case TRANS_MIRROR:
			mirror = true;
			break;
		case TRANS_MIRROR_ROT90:
			mirror = true;
			rotation = 90;
			break;
		case TRANS_MIRROR_ROT180:
			mirror = true;
			rotation = 180;
			break;
		case TRANS_MIRROR_ROT270:
			mirror = true;
			rotation = 270;
			break;
		default:
			maPanic(0,"error");
		}

		mTempMatrix.reset();
		if (mirror)
		{
			mTempMatrix.setScale(-1, 1);
			mTempMatrix.postTranslate(imgWidth, 0);
		}
		if (rotation != 0) {
			mTempMatrix.postRotate(rotation);
		}

		// TODO: This implementation is really slow, needs to be fixed.
		mTempBitmap = Bitmap.createBitmap(imageResource.mBitmap, srcRectLeft, srcRectTop, srcRectWidth, srcRectHeight, mTempMatrix, false);

		// TODO: Clip
		mCanvas.drawBitmap(mTempBitmap, dstLeft, dstTop, mPaint);
		// TODO: Restore clip.
	}
}
#endif

/**
* @brief maGetImageSize
*/
int maGetImageSize(int image)
{
	SYSLOG("maGetImageSize");
	ImageCache imageResource = (ImageCache)mImageResources.get(new Integer(image));
	if (imageResource == null)
	{
		logError("maGetImageSize : no such resource");
		return -1;
	}

	return EXTENT(imageResource.mBitmap.getWidth(), imageResource.mBitmap.getHeight());
}

/**
* @brief maGetImageData
*/
void _maGetImageData(int image, int dst, int srcLeft, int srcTop, int srcWidth, int srcHeight, int scanLength)
{
	SYSLOG("maGetImageData");

	ImageCache imageResource = (ImageCache)mImageResources.get(image);
	if(null == imageResource)
	{
		maPanic(1,"maGetImageData failed, no image resource!");
	}
	
	int bitmapSize = scanLength * srcHeight;
	
	if ((srcTop + srcHeight) > imageResource.mBitmap.getHeight()) maPanic(-1, "maGetImageData, (srcTop + srcHeight) > imageResource.mBitmap.getHeight() : " + (srcTop + srcHeight) + " > " + imageResource.mBitmap.getHeight());
	if ((srcLeft + srcWidth) > imageResource.mBitmap.getWidth()) maPanic(-1, "maGetImageData, (srcLeft + srcWidth) > imageResource.mBitmap.getWidth() : " + (srcLeft + srcWidth) + " > " + imageResource.mBitmap.getWidth());	


	int pixels[] = new int[srcWidth];
	
	mMemDataSection.mark();
	mMemDataSection.position(dst);

	IntBuffer ib = mMemDataSection.asIntBuffer();
	
	for(int y = 0; y < srcHeight; y++)
	{
		ib.position(y*scanLength);		
		imageResource.mBitmap.getPixels(pixels, 0, srcWidth, srcLeft, srcTop+y, srcWidth, 1);
		
		ib.put(pixels);	
	}
	
	mMemDataSection.reset();
	
}

/**
* @brief maSetDrawTarget
*/
int maSetDrawTarget(int image)
{
	SYSLOG("maSetDrawTarget");
	if (0 == image)
	{
		mCanvas = mDrawTargetScreen.mCanvas;
		mBitmap = mDrawTargetScreen.mBitmap;
	}
	else
	{
		ImageCache imageResource = (ImageCache)mImageResources.get(new Integer(image));
		if (null == imageResource)
		{
			return -1;
		}

		mCanvas = imageResource.mCanvas;
		mBitmap = imageResource.mBitmap;
	}
	return 1;
}

/**
* @brief maCreateImageFromData
*
* Create an image from a resource and store it in an image object.
*
* @param placeholder The handle for the image
* @param data The handle of the resource where the image data is stored
* @param offset Byte offset into the resource data
* @param size Byte size of the image data
* @return Status code
*/
int maCreateImageFromData(int placeholder, int data, int offset, int size)
{
	SYSLOG("maCreateImageFromData");

	// Byte array to hold resource data. This is the data we will
	// use to create the image.
	byte[] resourceData = new byte[size];

	// If data is a binary resource it is found in the table mBinaryResources.
	ByteBuffer binData = (ByteBuffer)mBinaryResources.get(data);
	if (null != binData)
	{
		try
		{
			// Load binary data into resource memory.
			binData.position(offset);
			binData.get(resourceData);
		}
		catch(Exception e)
		{
			logError("maCreateImageFromData - Couldn't read data, exception : " + e, e);
			return RES_BAD_INPUT;
		}
	}
	else // ubin
	{
		// If it is an unloaded binary resource (.ubin) it is found in mUBinaryResources.
		UBinData uBinData = (UBinData) mUBinaryResources.get(data);
		if (null != uBinData)
		{
			// Sanity check that offset + size is not larger the resource itself. 
			if (uBinData.getSize() < offset + size)
			{
				logError("maCreateImageFromData " +
					"size error, uBinData.getSize(): " + uBinData.getSize() + 
					" size: " + size + 
					" offset: " + offset);
				return RES_BAD_INPUT;
			}
		
			try
			{	
				// Read data from the resource asset file. All resources are
				// bundled into this file.
				AssetManager assetManager = mContext.getAssets();
				InputStream resourceFileInputStream = assetManager.open(RESOURCE_FILE);
			
				// Here we position the stream pointer at the offset where 
				// the image data starts.
				resourceFileInputStream.skip(uBinData.getOffset() + offset);
				
				// Read from asset file into the data array.
				resourceFileInputStream.read(resourceData);
			}
			catch(Exception e)
			{
				logError("maCreateImageFromData - Couldn't read read stream, exception : " + e.toString(), e);
				return RES_BAD_INPUT;
			}
		}
	}
	
	try 
	{
		// Create a Bitmap object from the resoure data.
		Bitmap decodedImage = BitmapFactory.decodeByteArray(resourceData, 0, resourceData.length);
		if (decodedImage == null)
		{
			logError("maCreateImageFromData - could not decode image data (decodedImage == null)");
			return RES_BAD_INPUT;
		}
		mImageResources.put(placeholder, new ImageCache(null, decodedImage));
	} 
	catch(UnsupportedOperationException e) 
	{
		logError("maCreateImageFromData - Unsupported operation, exception : " + e, e);
		return RES_BAD_INPUT;
	} 
	catch (java.lang.IllegalArgumentException e) 
	{
		logError("maCreateImageFromData - Illegal argument, exception : " + e, e);
		return RES_BAD_INPUT;
	} 
	catch (java.lang.OutOfMemoryError e) 
	{
		logError("maCreateImageFromData - Out of memory, exception : " + e, e);
		return RES_OUT_OF_MEMORY;
	}
	return RES_OK;
}

ByteBuffer tempImageRawBuffer;

/**
* @brief _maCreateImageRawGetData
*
* This fucntion generates a ByteBuffer which then is sent to the JNI library for processing
*/
ByteBuffer _maCreateImageRawGetData(int size)
{
	tempImageRawBuffer = ByteBuffer.allocateDirect(size);
	tempImageRawBuffer.order(null);
	
	return tempImageRawBuffer;
}

/**
* @brief _maCreateImageRaw
*
* Takes the preprocessed raw image data and copies the contents to a bitmap
*/
int _maCreateImageRaw(int placeholder, int width, int height)
{
	SYSLOG("maCreateImageRaw");
	
	Bitmap bitmap = Bitmap.createBitmap(width, height, Bitmap.Config.ARGB_8888);
	if(null == bitmap)
	{
		maPanic(1, "Unable to create ");
	}
	
	tempImageRawBuffer.position(0);
	bitmap.copyPixelsFromBuffer(tempImageRawBuffer);
	
	mImageResources.put(placeholder, new ImageCache(null, bitmap));
		
	return RES_OK;
}

/**
* @brief maCreateDrawableImage
*/
int maCreateDrawableImage(int placeholder, int width, int height)
{
	SYSLOG("maCreateDrawableImage");
	try
	{
		Bitmap bitmap = Bitmap.createBitmap(width, height, Bitmap.Config.ARGB_8888);
		Canvas canvas = new Canvas(bitmap);
	
		mImageResources.put(placeholder, new ImageCache(canvas, bitmap));	
	}
	catch (UnsupportedOperationException e)
	{
		logError("maCreateDrawableImage - e: " + e.toString(), e);
		return -1;
	}
	catch (Exception e)
	{
		logError("maCreateDrawableImage - e: " + e.toString(), e);
		return -1;
	}
	catch (java.lang.OutOfMemoryError e)
	{
		logError("maCreateDrawableImage - Out of Memory e: " + e.toString(), e);
		return -1;
	}
	return 1;
}

Hashtable<Integer, String> mStores = new Hashtable<Integer, String>();

int mMaxStoreId = 0;

final static String storesPath = "MAStore";

/**
* @brief maOpenStore
*/
int maOpenStore(String name, int flags)
{
	SYSLOG("maOpenStore");
	
	try
	{
		File f = mContext.getFileStreamPath(storesPath);

		if (f.isFile()) 
		{
			return STERR_GENERIC;
		}
		else if (!f.isDirectory())
		{
			boolean success = f.mkdir();
			if (!success) return STERR_GENERIC;
		}
		
		String filePath = storesPath + File.pathSeparator + name;
		f = mContext.getFileStreamPath(filePath);
		
		if (f.isDirectory()) return STERR_GENERIC;
		
		if (!f.isFile())
		{
			if ((flags & MAS_CREATE_IF_NECESSARY) == 0) return STERR_NONEXISTENT;
			f.createNewFile();
		}
		
		mMaxStoreId++;
		mStores.put(new Integer(mMaxStoreId), filePath);
		return mMaxStoreId;
	} 
	catch(Exception e) 
	{
		logError("open store exception : " + e.toString(), e);
		return STERR_GENERIC;
	}
}

/**
* @brief maWriteStore
*/
int maWriteStore(int store, int data)
{
	SYSLOG("maWriteStore");
	try 
	{
		File f = mContext.getFileStreamPath((String)mStores.get(new Integer(store)));
		if (f.isFile())
		{
			ByteBuffer bb = (ByteBuffer)mBinaryResources.get(data);
			if (null != bb)
			{
				FileOutputStream fos = new FileOutputStream(f, false);
				FileChannel fc = fos.getChannel();
				
				// Make sure that the buffer is reading from the start
				bb.position(0);
				
				fc.write(bb);
				fc.force(false);
				fc.close();
				fos.close();
				return 1;
			}
			
			UBinData ubd = (UBinData)mUBinaryResources.get(data);
			if (null != ubd)
			{
				byte[] ra = new byte[ubd.getSize()];
			
				AssetManager assetManager = mContext.getAssets();
				InputStream is = assetManager.open(RESOURCE_FILE);
				
				is.skip(ubd.getOffset());
				is.read(ra);
			
				FileOutputStream fos = new FileOutputStream(f, false);
				fos.write(ra);
				fos.close();
				return 1;
			}

			logError("Write Store - didn't find buffer, data:" + data);
			return STERR_GENERIC;			
		}
	} 
	catch(Exception e) 
	{
		logError("write store exception : " + e.toString(), e);
	}
	return STERR_GENERIC;
}

/**
* @brief _maReadStore
*/
ByteBuffer _maReadStore(int store, int resourceIndex)
{
	SYSLOG("_maReadStore");
	
	try 
	{
		File f = mContext.getFileStreamPath((String)mStores.get(new Integer(store)));
		byte[] buffer;
		int length = 0;
		if (f.isFile())
		{
			length = (int)f.length();
			buffer = new byte[length];
			
			FileInputStream fis = new FileInputStream(f);
			int offset = 0;
			while (offset >= 0 && offset < length)
			{
				offset = fis.read(buffer, offset, (length-offset));
			}
			fis.close();	
		}
		else
		{
			buffer = new byte[0];
		}
		
		ByteBuffer bb = loadBinary(resourceIndex, length);
		bb.put(buffer);
		return bb;
		
	} 
	catch(Exception e) 
	{
		logError("read store exception : " + e.toString(), e);
		return null;
	}
}

/**
* @brief maCloseStore
*/
void maCloseStore(int store, int remove)
{
	SYSLOG("maCloseStore");
	
	String filePath = (String)mStores.get(new Integer(store));
	if (remove != 0) 
	{
		File f = mContext.getFileStreamPath(filePath);
		f.delete();
	} 
	
	if (!(mStores.remove(new Integer(store)) == filePath))
	{
		maPanic(1, "maCloseStore failed!");
	}
}

#include "MoSyncSound.jpp"

#include "MoSyncBluetooth.jpp"

#include "MoSyncNetwork.jpp"

#include "MoSyncLocation.jpp"

/**
* @brief maLoadProgram
*/
void maLoadProgram(int data, int reload)
{
	SYSLOG("maLoadProgram");
}

/**
* @brief maGetKeys
*/
int maGetKeys()
{
	SYSLOG("maGetKeys");
	return -1;
}

/**
* @brief maGetEvent
*/
int maGetEvent(int event)
{
	SYSLOG("maGetEvent");
	return -1;
}

/**
* @brief maWait
*/
void maWait(int timeout)
{
	SYSLOG("maWait");	

	try
	{
 		if (timeout<=0)
		{
			this.sleep(Long.MAX_VALUE);
		}
		else
		{
			this.sleep(timeout);
		}
	} 
	catch (InterruptedException ie) 
	{
		SYSLOG("Sleeping thread interrupted!");
	} 
	catch (Exception e) 
	{
		logError("Thread sleep failed : " + e.toString(), e);
	}
	
	SYSLOG("maWait returned");
}

/**
* @brief maTime
*/
int maTime()
{
	SYSLOG("maTime");
	Date d = new Date();
	return (int)(d.getTime() / 1000);
}

/**
* @brief maLocalTime
*/
int maLocalTime()
{
	SYSLOG("maLocalTime");
	Date d = new Date();
	TimeZone tz = TimeZone.getDefault();
	return (int)((d.getTime() + tz.getRawOffset()) / 1000);
}

/**
* @brief maGetMilliSecondCount
*/
int maGetMilliSecondCount()
{
	return (int)SystemClock.elapsedRealtime();
}

/**
* @brief maFreeObjectMemory 
*/
int maFreeObjectMemory()
{
	SYSLOG("maFreeObjectMemory");
	return -1;
}

/**
* @brief maTotalObjectMemory
*/
int maTotalObjectMemory()
{
	SYSLOG("maTotalObjectMemory");
	return -1;
}

/**
* @brief maVibrate
*/
int maVibrate(int millisecondsToVibrate)
{
	SYSLOG("maVibrate");
	
	Vibrator vibrator = (Vibrator) mContext.getSystemService(Context.VIBRATOR_SERVICE);
	if (null == vibrator) 
	{
		return 0; // No vibrator.
	}
	
	if (0 == millisecondsToVibrate)
	{
		vibrator.cancel();
	}
	else
	{
		vibrator.vibrate(millisecondsToVibrate);
	}
	
	return 1;
}

/**
* @brief maPanic
*/
void maPanic(int result, String message)
{
	SYSLOG("maPanic");
	
	threadPanic(result, message);
}

/**
* @brief maInvokeExtension
*/
int maInvokeExtension(int function, int a, int b, int c)
{
	SYSLOG("maInvokeExtension");
	return -1;
}

/**
* @brief maIOCtl
*/
int maIOCtl(int function, int a, int b, int c)
{
	SYSLOG("maIOCtl");
	return -1;
}

/**
* @brief _enableFramebuffer
*/
void _enableFramebuffer(int address)
{
	mUsingFrameBuffer = true;
	mFrameBufferAddress = address; // address is pointing at a byte but that array is an int array..
	mFrameBufferSize = mWidth*mHeight;
	mFrameBufferBitmap = Bitmap.createBitmap(mWidth, mHeight, Bitmap.Config.ARGB_8888 );
	
}

/**
* @brief _disableFramebuffer
*/
void _disableFramebuffer()
{
	mUsingFrameBuffer = false;
}

/**
* Implemation of the maWriteLog syscall which only sends the log message to the Android Logcat
*
* @param str	The string to send to Logcat
*		 size	The number of characters in the string
*/
int maWriteLog(String str, int size)
{
	Log.i("maWriteLog", str);
	return 1;
}

/**
* @brief maGetSystemProperty
*/
int maGetSystemProperty(String key, int buf, int size)
{
	String property = "";
	
	if(key.equals("mosync.imei"))
	{
		TelephonyManager manager = (TelephonyManager)mContext.getSystemService(Context.TELEPHONY_SERVICE);
		property = manager.getDeviceId();
	}
	else if(key.equals("mosync.imsi"))
	{
		TelephonyManager manager = (TelephonyManager)mContext.getSystemService(Context.TELEPHONY_SERVICE);
		property = manager.getSubscriberId();
	}
	else if(key.equals("mosync.iso-639-1"))
	{
		Locale locale = Locale.getDefault();
		property = locale.getLanguage();
	}
	else if(key.equals("mosync.iso-639-2"))
	{
		Locale locale = Locale.getDefault();
		property = locale.getISO3Language();
	}
	
	if(null == property) return -2;
	
	if(0 == property.compareTo("")) return -2;
	
	if(property.length() >= size)
		return property.length() + 1;
		
	// Write this property to memory
	
	byte[] ba = property.getBytes();
	
	mMemDataSection.mark();
	mMemDataSection.position(buf);
	mMemDataSection.put(ba);
	mMemDataSection.put((byte)0);
	mMemDataSection.reset();
	
	return property.length() + 1;
}

/**
* @brief maPlatformRequest
*/
int maPlatformRequest(String url)
{
	if(url.startsWith("http://"))
	{
		Log.i("maPlatformRequest","Starting browser:" + url);
		Intent i = new Intent(Intent.ACTION_VIEW);
		i.setData(Uri.parse(url));
		((Activity)mContext).startActivity(i);
		
		return 0;
	}
	return -1;
}

/**
* @brief maShowVirtualKeyboard
*/
int maShowVirtualKeyboard()
{
	InputMethodManager mgr = (InputMethodManager) mContext.getSystemService(Context.INPUT_METHOD_SERVICE);
	mgr.showSoftInput(mMoSyncView, InputMethodManager.SHOW_FORCED);
	return 0;
}

Hashtable<Integer, ImageCache> mImageResources = new Hashtable<Integer, ImageCache>();

/**
* @brief loadImage
*
* Stores an image resource. Since Andriod differs a lot from
* the other runtimes this is necessary. There isn't a duplicate stored
* on the JNI side.
*/
boolean loadImage(int resourceIndex, int pos, int length, int binaryResource)
{
	SYSLOG("LoadImage");
	SYSLOG("ri:" + resourceIndex + " pos:" + pos + " length:" + length + " br:" + binaryResource );
	try
	{
		byte[] ra = new byte[length];
		
		if(binaryResource != 0)
		{
			SYSLOG("Reading image resource from binary resource");
			ByteBuffer bb = (ByteBuffer)mBinaryResources.get(binaryResource);
			if(null == bb)
				return false;
			
			int p = bb.position();
			bb.position(pos);
			bb.get(ra);
			bb.position(p);
		}
		else // is ubin
		{
			SYSLOG("Reading image resource from asset");
			int offset =  pos-(int)mResourceOffset;
			
			AssetManager assetManager = mContext.getAssets();
			InputStream is = assetManager.open(RESOURCE_FILE);
			
			is.skip(offset);
			is.read(ra);
		}
		
		SYSLOG("Decode a bitmap!");
		Bitmap bitmap = BitmapFactory.decodeByteArray(ra, 0, length);
		if(bitmap != null)
		{
			SYSLOG("Bitmap was created!");
			mImageResources.put(resourceIndex, new ImageCache(null, bitmap));
			return true;
		}
		logError("loadImage - Bitmap wasn't created from Resource: " + resourceIndex);
		return false;
	}
	catch (Exception e)
	{
		logError("loadImage - Bitmap exceptions : " + e.toString(), e);
		return false;
	}
}

Hashtable<Integer, ByteBuffer> mBinaryResources = new Hashtable<Integer, ByteBuffer>();

/**
* @brief loadBinary
*
* Stores a binary resource. Since Andriod differs a lot from
* the other runtimes this is necessary. There isn't a duplicate stored
* on the JNI side.
*/
ByteBuffer loadBinary(int resourceIndex, int size)
{
	SYSLOG("loadBinary index:" + resourceIndex);
	
	try
	{
		ByteBuffer data = ByteBuffer.allocateDirect(size);
		data.order(null);
		mBinaryResources.put(resourceIndex, data);
		return data;
	}
	catch(Exception e)
	{
		logError("loadBinary - Out of Memory!", e);
		maPanic(1,"Out of Memory!");
	}
	return null;
}


/**
* @brief UBinData class
*
* Class that stores offset and size of an unloaded binary resource (.ubin). 
* These a memory saving resources that are loaded on demand. Om Android we
* need to store audio resource as files to be able to play them, there is
* some special handling of audio resources in the Android runtime. See file
* MoSyncSound.jpp.
*/
class UBinData
{
	public UBinData(int offset, int size)
	{
		mOffset = offset;
		mSize = size;
	}
	
	public int getOffset()
	{
		// getResourceStartOffset() is where resources start (after the header of 
		// the asset file).
		// We need to subtract this offset because resourceFileInputStream
		// will begin at mResourceOffset and uBinData.mOffset is the offset
		// from the actual beginning of the asset file.
		return mOffset - getResourceStartOffset();
	}
	
	public int getSize()
	{
		return mSize;
	}
	
	/**
	 * The byte offset in the resource file to the 
	 * beginning of this ubin.
	 */
	private int mOffset;
	
	/**
	 * The byte size of this ubin.
	 */
	private int mSize;
};

/**
 * Table that stores ubin resources. 
 */
Hashtable<Integer, UBinData> mUBinaryResources = new Hashtable<Integer, UBinData>();


/**
* @brief loadUBinary
*
* Stores an unloaded binary resource. Since Andriod differs a lot from
* the other runtimes this is necessary. There isn't a duplicate stored
* on the JNI side.
*/
void loadUBinary(int resourceIndex, int offset, int size)
{
	SYSLOG("loadUBinary index:" + resourceIndex);
	UBinData ubd = new UBinData(offset, size);
	mUBinaryResources.put(resourceIndex, ubd);
	
	// UBIN must always point to the resource file.
	try
	{
		AssetManager assetManager = mContext.getAssets();
		AssetFileDescriptor pAfd = assetManager.openFd(RESOURCE_FILE);
		
		FileInputStream fis = pAfd.createInputStream();
		fis.skip(ubd.getOffset());
	
		if(true == checkIfMimeAudioType(fis))
		{
			storeAudioUBin(ubd, resourceIndex);
		}
	}
	catch(Exception e)
	{
		logError("loadUBinary - exception :", e);
	}
}

/**
* @brief destroyResource
*
* @param 	resourceIndex the resource index which should be destroyed
*/
void destroyResource(int resourceIndex)
{
	SYSLOG("destroyBinary :" + resourceIndex);
	
	if(null != mBinaryResources.get(resourceIndex))
	{
		mBinaryResources.remove(resourceIndex);
	}

	if(null != mUBinaryResources.get(resourceIndex))
	{
		mUBinaryResources.remove(resourceIndex);
	}

	if(null != mImageResources.get(resourceIndex))
	{
		mImageResources.remove(resourceIndex);
	}
}

/**
* @brief maTextBox
*/
int maTextBox(String title, String inText, int outText, int maxSize, int constraints)
{
	Intent intent = new Intent(mContext, TextBox.class);
	Bundle bundle = new Bundle();
	bundle.putString("TITLE", title);
	bundle.putString("TEXT", inText);
	bundle.putInt("OUTPUT", outText);
	bundle.putInt("CONSTRAINTS", constraints);
	intent.putExtras(bundle);
	mContext.startActivity(intent);
	Log.i("MoSync", "New activity started for InputBox");
	return 0;
}
