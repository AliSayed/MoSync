/* Copyright (C) 2010 MoSync AB

This program is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License, version 2, as published by
the Free Software Foundation.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
for more details.

You should have received a copy of the GNU General Public License
along with this program; see the file COPYING.  If not, write to the Free
Software Foundation, 59 Temple Place - Suite 330, Boston, MA
02111-1307, USA.
*/

#include "helpers.h"
#include "config_platform.h"
#include "generated/MAAPI_consts.h"

final class ImageCache
{
	Bitmap mBitmap;
	Canvas mCanvas;

	ImageCache(Canvas canvas, Bitmap bitmap)
	{
		mCanvas = canvas;
		mBitmap = bitmap;
	}
}

public ByteBuffer mMemDataSection;
ByteBuffer mResourceFile;

Canvas mCanvas;
Bitmap mBitmap;

int mWidth;
int mHeight;

int mClipLeft, mClipTop, mClipWidth, mClipHeight;

boolean mUsingFrameBuffer;
int mFrameBufferAddress;
int mFrameBufferSize;
Bitmap mFrameBufferBitmap;

ImageCache mDrawTargetScreen = null;
ImageCache mDrawTarget = null;
int mDrawTargetHandle = 0;

int mSoundVolume;
MediaPlayer mMediaPlayer;

Paint mPaint = new Paint();
Paint mBlitPaint = new Paint();

int mTextConsoleHeight;

boolean initSyscalls()
{
	SYSLOG("initSyscalls");
	 mUsingFrameBuffer = false;

	 mClipLeft = 0;
	 mClipTop = 0;
	 mClipWidth = mWidth;
	 mClipHeight = mHeight;

	 mPaint.setStyle(Paint.Style.FILL);
	 mPaint.setAntiAlias(false);
	 mPaint.setColor(0xffffffff);
	 
	 mBlitPaint.setAntiAlias(false);
	 mBlitPaint.setColor(0xffffffff);
	 mBlitPaint.setAlpha(255);
	 
	 mSoundVolume = 50;
	 
	 // Generates a default text height used for console text writing.
	 // This is used so that all text which is printed to the console
	 // gets the same text height.
	MAExtent e = maGetTextSize("abcdefghijklmnopqrstuvwxyz"+
													"ABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890");
	mTextConsoleHeight = EXTENT_Y(e);
	 
	 return true;
}

/**
* @brief maSetColor
*/
int maSetColor(int rgb)
{
	SYSLOG("maSetColor");

	int t = mPaint.getColor();
	mPaint.setColor(rgb);
	mPaint.setAlpha(255);
	return t;
}

/**
* @brief maSetClipRect
*/
void maSetClipRect(int left, int top, int width, int height)
{
	SYSLOG("maSetClipRect");

	mClipLeft = left;
	mClipTop = top;
	mClipWidth = width;
	mClipHeight = height;

	mCanvas.clipRect(left, top, left+width, top+height, Region.Op.REPLACE );
}

/**
* @brief maPlot
*/
void maPlot(int posX, int posY)
{
	SYSLOG("maPlot");

	mCanvas.drawPoint(posX, posY, mPaint);
}

/**
* @brief maLine
*/
void maLine(int startX, int startY, int endX, int endY)
{
	SYSLOG("maLine");

	mCanvas.drawLine(startX, startY, endX, endY, mPaint);
}

/**
* @brief maFillRect
*/
void maFillRect(int left, int top, int width, int height)
{
	SYSLOG("maFillRect");

	mCanvas.drawRect(left, top, left+width, top+height, mPaint);
}

/*
This implementation might seem a bit strange but it works so much better than using Canvas.drawVertices..
*/
/**
* @brief maFillTriangleStrip
*/
void maFillTriangleStrip(int address, int count)
{
	SYSLOG("maFillTriangleStrip");

	if(count < 3) maPanic(1,"maFillTriangleStrip takes more than 3 vertices");

	mMemDataSection.mark();
	mMemDataSection.position(address);

	IntBuffer ib = mMemDataSection.asIntBuffer();
	
	int[] vertices = new int[count*2];
	ib.get(vertices);
	
	Path path = new Path();

	int i = 0;
	
	int xa = vertices[i++];
	int ya = vertices[i++];

	int xb = vertices[i++];
	int yb = vertices[i++];
	for(;;) {
		int xc = vertices[i++];
		int yc = vertices[i++];
		path.moveTo(xa,ya);
		path.lineTo(xb,yb);
		path.lineTo(xc,yc);
		path.close();
		
		if(i >= count*2)
			break;
		xa = vertices[i++];
		ya = vertices[i++];
		path.moveTo(xb,yb);
		path.lineTo(xc,yc);
		path.lineTo(xa,ya);
		path.close();
		
		if(i >= count*2)
			break;
		xb = vertices[i++];
		yb = vertices[i++];
		path.moveTo(xc,yc);
		path.lineTo(xa,ya);
		path.lineTo(xb,yb);
		path.close();
		
		if(i >= count*2)
			break;			
	}
	mCanvas.drawPath(path, mPaint);
	
	mMemDataSection.reset();
	
}


/**
* @brief maFillTriangleFan
*/
void maFillTriangleFan(int address, int count)
{
	SYSLOG("maFillTriangleFan");

	if(count < 3) maPanic(1,"maFillTriangleFan takes more than 3 vertices");

	mMemDataSection.mark();
	mMemDataSection.position(address);

	IntBuffer ib = mMemDataSection.asIntBuffer();
	
	int[] vertices = new int[count*2];
	ib.get(vertices);
	
	Path path = new Path();

	int i = 0;
	
	int xa = vertices[i++];
	int ya = vertices[i++];

	int xb = vertices[i++];
	int yb = vertices[i++];
	for(;;) {
		int xc = vertices[i++];
		int yc = vertices[i++];
		path.moveTo(xa,ya);
		path.lineTo(xb,yb);
		path.lineTo(xc,yc);
		path.close();
		
		if(i >= count*2)
			break;
		xa = vertices[i++];
		ya = vertices[i++];
		path.moveTo(xa,ya);
		path.lineTo(xc,yc);
		path.lineTo(xb,yb);
		path.close();
		
		if(i >= count*2)
			break;			
	}
	mCanvas.drawPath(path, mPaint);
	
	mMemDataSection.reset();
}


Rect mTextSizeRect = new Rect();

/**
* @brief maGetTextSize - Gets the height in pixels of the string,
*
* Calculates the height in pixels of this string, as it's gonna 
* be drawn to the screen
*
* @param str	The string which the height should be calculated from
*
* @return the height in pixels
*/
int maGetTextSize(final String str)
{
	SYSLOG("maGetTextSize");
	
	mPaint.getTextBounds(str, 0, str.length(), mTextSizeRect);
	
	return EXTENT(mTextSizeRect.width(), mTextSizeRect.height());
}

/**
* @brief maGetTextSizeW - Gets the height in pixels of the string,
*
* Calculates the height in pixels of this string, as it's gonna 
* be drawn to the screen
*
* @param str	The string which the height should be calculated from
*
* @return the height in pixels
*/
int maGetTextSizeW(final String str)
{
	SYSLOG("maGetTextSizeW");
	
	mPaint.getTextBounds(str, 0, str.length(), mTextSizeRect);
	
	return EXTENT(mTextSizeRect.width(), mTextSizeRect.height());
}

/**
* @brief maDrawText - draws a string of text to the screen
*
* @param left		The left most pixel on which the text should be rendered
* @param top		The top most pixel on which the text should be rendered
*/
void maDrawText(int left, int top, final String str)
{
	SYSLOG("maDrawText");
	
	mCanvas.drawText(str, left, top+mTextConsoleHeight, mPaint);
}

/**
* @brief maDrawText - draws a string of text to the screen
*
* @param left		The left most pixel on which the text should be rendered
* @param top		The top most pixel on which the text should be rendered
*/
void maDrawTextW(int left, int top, final String str)
{
 	SYSLOG("maDrawTextW");
	
	mCanvas.drawText(str, left, top+mTextConsoleHeight, mPaint);
}

/**
* @brief maUpdateScreen
*/
void maUpdateScreen()
{
	//SYSLOG("maUpdateScreen");
	Canvas lockedCanvas = null;
	
	if (mMoSyncView == null) return;
	
	try 
	{
		lockedCanvas = mMoSyncView.mSurfaceHolder.lockCanvas();
		synchronized (mMoSyncView.mSurfaceHolder)
		{
			if (mUsingFrameBuffer)
			{				
				mMemDataSection.mark();
				mMemDataSection.position(mFrameBufferAddress);
				mFrameBufferBitmap.copyPixelsFromBuffer(mMemDataSection);
				mMemDataSection.reset();
				
				// Clear the screen.. in this case draw the canvas black
				lockedCanvas.drawRGB(0,0,0);
				
				// Blit the framebuffer
				lockedCanvas.drawBitmap(mFrameBufferBitmap, 0, 0, mBlitPaint);
			}
			else
			{
				if (null != lockedCanvas)
				{
					lockedCanvas.drawBitmap(mBitmap, 0, 0, mBlitPaint);
				}
			}
		}
	} 
	catch (Exception e)
	{
		logError("updateScreen Exception : " + e.toString(), e);
		return;
	}
		
	if (lockedCanvas != null)
	{
		mMoSyncView.mSurfaceHolder.unlockCanvasAndPost(lockedCanvas);
	}
	
}

/**
* @brief maResetBacklight
*/
void maResetBacklight()
{
	SYSLOG("maResetBacklight");
}

/**
* @brief maGetScrSize
*/
int maGetScrSize()
{
	SYSLOG("maGetScrSize");
	return EXTENT(mWidth, mHeight);
}

/**
* @brief maDrawImage
*/
void maDrawImage(int image, int left, int top)
{
	SYSLOG("maDrawImage");
	
	ImageCache imageResource = (ImageCache)mImageResources.get(new Integer(image));
	if (imageResource == null)
	{
		return;
	}

	mCanvas.drawBitmap(imageResource.mBitmap, left, top, null);
}

/**
* @brief _maDrawRGB
*/
void _maDrawRGB(int dstX, int dstY, int mem, int srcRectLeft, int srcRectTop, int srcRectWidth, int srcRectHeight, int scanLength)
{
	SYSLOG("maDrawRGB");

	int pixels[] = new int[srcRectWidth];
	
	mMemDataSection.mark();
	mMemDataSection.position(mem);

	IntBuffer ib = mMemDataSection.asIntBuffer();
	
	for(int y = 0; y < srcRectHeight; y++)
	{
		ib.position(y*scanLength);		
		
		ib.get(pixels);
		mCanvas.drawBitmap(pixels, 0, srcRectWidth, dstX, dstY+y, srcRectWidth, 1, true, mPaint);		
	}
	
	mMemDataSection.reset();
}

/**
 * Rectangle objects used for drawing in maDrawImageRegion().
 */
private Rect mMaDrawImageRegionTempSourceRect = new Rect();
private Rect mMaDrawImageRegionTempDestRect = new Rect();

#if 1 // New code
/**
 * @brief _maDrawImageRegion 
 *
 * Draw rectangular region of an image.
 *
 * @param image Handle to the image.
 * @param srcRectLeft Left coord of source rectangle.
 * @param srcRectTop Top coord of source rectangle.
 * @param srcRectWidth Width of source rectangle.
 * @param srcRectHeight Height of source rectangle.
 * @param dstLeft Left coord of destination point.
 * @param dstTop Top coord of destination point.
 * @param transformMode A TRANS_* constant.
 */
void _maDrawImageRegion(
	final int image, 
	final int srcRectLeft, 
	final int srcRectTop, 
	final int srcRectWidth, 
	final int srcRectHeight, 
	final int dstLeft, 
	final int dstTop, 
	final int transformMode)
{
	SYSLOG("_maDrawImageRegion");
	
	// Get image resource.
	ImageCache imageResource = (ImageCache)mImageResources.get(image);
	if (imageResource == null) { return; }

	// Get image dimension.
	final int imgHeight = imageResource.mBitmap.getHeight();
	final int imgWidth = imageResource.mBitmap.getWidth();
	
	// Make sure source rect is inside the image.
	// This is according to the syscall spec. 
	// TODO: Should we call maPanic()?
	if (srcRectLeft < 0) { return; }
	if (srcRectTop < 0) { return; }
	if (srcRectLeft + srcRectWidth > imgWidth) { return; }
	if (srcRectTop + srcRectHeight > imgHeight) { return; }
	
	// Set up image source rectangle.
	mMaDrawImageRegionTempSourceRect.left = srcRectLeft;
	mMaDrawImageRegionTempSourceRect.right = (srcRectLeft + srcRectWidth);
	mMaDrawImageRegionTempSourceRect.top = srcRectTop;
	mMaDrawImageRegionTempSourceRect.bottom = (srcRectTop + srcRectHeight);
	
	// Set up destination rectangle. 
	// We set origin to 0,0 and translate below.
	mMaDrawImageRegionTempDestRect.left = 0;
	mMaDrawImageRegionTempDestRect.right = srcRectWidth;
	mMaDrawImageRegionTempDestRect.top = 0;
	mMaDrawImageRegionTempDestRect.bottom = srcRectHeight;
	
	// Save the canvas matrix state.
	mCanvas.save(Canvas.MATRIX_SAVE_FLAG);
	
	// Set up canvas matrix for each transformation.
	// The transforms that mirror and rotate the image
	// might take some time to understand, because mirroring
	// flips the coordinate system, positive becomes negative,
	// rotation goes the other way, and so on.
    switch (transformMode)
	{
    	case TRANS_NONE:
    		mCanvas.translate(dstLeft, dstTop);
    		break;
			
    	case TRANS_ROT90:
    		mCanvas.translate(dstLeft + srcRectHeight, dstTop);
    		mCanvas.rotate(90);
    		break;
			
    	case TRANS_ROT180:
    		mCanvas.translate(dstLeft + srcRectWidth, dstTop + srcRectHeight);
    		mCanvas.rotate(180);
    		break;
			
    	case TRANS_ROT270:
    		mCanvas.translate(dstLeft, dstTop + srcRectWidth);
    		mCanvas.rotate(270);
    		break;
			
    	case TRANS_MIRROR:
    		mCanvas.translate(dstLeft + srcRectWidth, dstTop);
    		mCanvas.scale(-1, 1);
    		break;
			
    	case TRANS_MIRROR_ROT90:
    		mCanvas.translate(dstLeft + srcRectHeight, dstTop + srcRectWidth);
    		mCanvas.scale(-1, 1);
    		mCanvas.rotate(270);
    		break;
			
    	case TRANS_MIRROR_ROT180:
    		mCanvas.translate(dstLeft, dstTop + srcRectHeight);
    		mCanvas.scale(-1, 1);
    		mCanvas.rotate(180);
    		break;
			
    	case TRANS_MIRROR_ROT270:
    		mCanvas.translate(dstLeft, dstTop);
    		mCanvas.scale(-1, 1);
    		mCanvas.rotate(90);
			break;
			
		default:
			maPanic(0, "maDrawImageRegion - unsupported transform");
			break;
	}
		
	mCanvas.drawBitmap(
		imageResource.mBitmap, 
		mMaDrawImageRegionTempSourceRect, 
		mMaDrawImageRegionTempDestRect, 
		null);
	
	// Restore canvas matrix.
	mCanvas.restore();
}
#endif

#if 0 // Old code TODO: Delete
/**
 * @brief _maDrawImageRegion 
 *
 * Draw rectangular region of an image.
 *
 * @param image Handle to the image.
 * @param srcRectLeft Left coord of source rectangle.
 * @param srcRectTop Top coord of source rectangle.
 * @param srcRectWidth Width of source rectangle.
 * @param srcRectHeight Height of source rectangle.
 * @param dstLeft Left coord of destination point.
 * @param dstTop Top coord of destination point.
 * @param transformMode A TRANS_* constant.
 */
void _maDrawImageRegion(
	int image, 
	int srcRectLeft, 
	int srcRectTop, 
	int srcRectWidth, 
	int srcRectHeight, 
	int dstLeft, 
	int dstTop, 
	int transformMode)
{
	SYSLOG("maDrawImageRegion");

	ImageCache imageResource = (ImageCache)mImageResources.get(image);
	if (imageResource == null)
	{
		return;
	}

	// srcRectTop must be less than the image height.
	final int imgHeight = imageResource.mBitmap.getHeight();
	if (srcRectTop > imgHeight) 
	{
		return;
	}
	
	final int imgWidth = imageResource.mBitmap.getWidth();
	if (srcRectLeft > imgWidth) 
	{
		return;
	}
	
	if (srcRectTop < 0)
	{
		srcRectHeight += srcRectTop;
		srcRectTop = 0;
	}
	
	if (srcRectLeft < 0)
	{
		srcRectWidth += srcRectLeft;
		srcRectLeft = 0;
	}
	
	if (srcRectTop + srcRectHeight > imgHeight)
	{
		srcRectHeight = imgHeight - srcRectTop;
	}
	
	if (srcRectLeft + srcRectWidth > imgWidth)
	{
		srcRectWidth = imgWidth - srcRectLeft;
	}
	
	if (srcRectWidth <= 0 || srcRectHeight <= 0) 
	{
		return;
	}

	if (transformMode == TRANS_NONE)
	{
		mCanvas.clipRect(dstLeft, dstTop, dstLeft + srcRectWidth, dstTop + srcRectHeight, Region.Op.INTERSECT);
		mCanvas.drawBitmap(imageResource.mBitmap, dstLeft - srcRectLeft, dstTop - srcRectTop, mPaint);
		mCanvas.clipRect(mClipLeft, mClipTop, mClipLeft + mClipWidth, mClipTop + mClipHeight, Region.Op.REPLACE);
		return;
	}
	else
	{
		boolean mirror = false;
		int rotation = 0;

		switch (transformMode)
		{
		case TRANS_ROT90:
			rotation = 90;
			break;
		case TRANS_ROT180:
			rotation = 180;
			break;
		case TRANS_ROT270:
			rotation = 270;
			break;
		case TRANS_MIRROR:
			mirror = true;
			break;
		case TRANS_MIRROR_ROT90:
			mirror = true;
			rotation = 90;
			break;
		case TRANS_MIRROR_ROT180:
			mirror = true;
			rotation = 180;
			break;
		case TRANS_MIRROR_ROT270:
			mirror = true;
			rotation = 270;
			break;
		default:
			maPanic(0,"error");
		}

		mTempMatrix.reset();
		if (mirror)
		{
			mTempMatrix.setScale(-1, 1);
			mTempMatrix.postTranslate(imgWidth, 0);
		}
		if (rotation != 0) {
			mTempMatrix.postRotate(rotation);
		}

		// TODO: This implementation is really slow, needs to be fixed.
		mTempBitmap = Bitmap.createBitmap(imageResource.mBitmap, srcRectLeft, srcRectTop, srcRectWidth, srcRectHeight, mTempMatrix, false);

		// TODO: Clip
		mCanvas.drawBitmap(mTempBitmap, dstLeft, dstTop, mPaint);
		// TODO: Restore clip.
	}
}
#endif

/**
* @brief maGetImageSize
*/
int maGetImageSize(int image)
{
	SYSLOG("maGetImageSize");
	ImageCache imageResource = (ImageCache)mImageResources.get(new Integer(image));
	if (imageResource == null)
	{
		logError("maGetImageSize : no such resource");
		return -1;
	}

	return EXTENT(imageResource.mBitmap.getWidth(), imageResource.mBitmap.getHeight());
}

/**
* @brief maGetImageData
*
* This syscall takes an image resource and reads the pixels from the given
* rectangle and copies the pixels to the memory location given by the dst
* parameter
*
* @param image				The image resource index
* @param dst					The memory location to which the result should be written
* @param srcLeft			The left-most pixel of the rectangle
* @param srcTop			The top-most pixel of the rectangle
* @param srcWidth		The width of the rectangle
* @param srcHeight		The height of the rectangle
* @param scanLength	The scan length, the number of bytes per row in the source
										image
*/
void _maGetImageData(int image, int dst, int srcLeft, int srcTop, int srcWidth,
										int srcHeight, int scanLength)
{
	SYSLOG("maGetImageData");

	ImageCache imageResource = (ImageCache)mImageResources.get(image);
	if(null == imageResource)
	{
		maPanic(1,"maGetImageData failed, no image resource!");
	}
	
	int bitmapSize = scanLength * srcHeight;
	
	if ((srcTop + srcHeight) > imageResource.mBitmap.getHeight()) 
	{
		maPanic(
			-1, 
			"maGetImageData, (srcTop + srcHeight) > " +
			"imageResource.mBitmap.getHeight() : " +
			(srcTop + srcHeight) + 
			" > " +
			imageResource.mBitmap.getHeight() );
	}
	
	if ((srcLeft + srcWidth) > imageResource.mBitmap.getWidth())
	{
		maPanic(
			-1,
			"maGetImageData, (srcLeft + srcWidth) > "+ 
			"imageResource.mBitmap.getWidth() : " +
			(srcLeft + srcWidth) + 
			" > " +
			imageResource.mBitmap.getWidth() );	
	}
	
	int pixels[] = new int[srcWidth];	
	int colors[] = new int[srcWidth];
	int alpha[] = new int[srcWidth];
	
	/*
		The section generates a copy of the source image
		and renders that into a surface. The copy is then
		given full opaque since the color values wasn't 
		returned by the Android.Bitmap.getPixels when the
		alpha value of a pixel was zero.
		The alpha values are then read from the source 
		image and the result are added with the alpha values
		and the result is stored in the given memory location.
	*/
	Bitmap temporaryBitmap = Bitmap.createBitmap(
		srcWidth,
		srcHeight,
		Bitmap.Config.ARGB_8888);

	Canvas temporaryCanvas = new Canvas(temporaryBitmap);
	
	temporaryCanvas.drawBitmap(
		imageResource.mBitmap,
		new Matrix(),
		new Paint());
		
	temporaryCanvas.drawColor(0xff000000, Mode.DST_ATOP);
	
	mMemDataSection.mark();
	mMemDataSection.position(dst);

	IntBuffer intBuffer = mMemDataSection.asIntBuffer();
	
	for(int y = 0; y < srcHeight; y++)
	{
		intBuffer.position(y*scanLength);		
		
		imageResource.mBitmap.getPixels(
			alpha,
			0,
			srcWidth,
			srcLeft,
			srcTop+y,
			srcWidth,
			1);
	
		temporaryBitmap.getPixels(
			colors,
			0,
			srcWidth,
			srcLeft,
			srcTop+y,
			srcWidth,
			1);
		
		for( int i = 0; i < srcWidth; i++)
		{
			pixels[i] = (alpha[i]&0xff000000) + (colors[i]&0x00ffffff);
		}
		
		intBuffer.put(pixels);	
	}
	
	mMemDataSection.reset();
	
}


/**
* @brief maSetDrawTarget
*/
int maSetDrawTarget(int image)
{
	SYSLOG("maSetDrawTarget");
	if (0 == image)
	{
		mCanvas = mDrawTargetScreen.mCanvas;
		mBitmap = mDrawTargetScreen.mBitmap;
	}
	else
	{
		ImageCache imageResource = (ImageCache)mImageResources.get(new Integer(image));
		if (null == imageResource)
		{
			return -1;
		}

		mCanvas = imageResource.mCanvas;
		mBitmap = imageResource.mBitmap;
	}
	return 1;
}

/**
* @brief maCreateImageFromData
*
* Create an image from a resource and store it in an image object.
*
* @param placeholder The handle for the image
* @param data The handle of the resource where the image data is stored
* @param offset Byte offset into the resource data
* @param size Byte size of the image data
* @return Status code
*/
int maCreateImageFromData(int placeholder, int data, int offset, int size)
{
	SYSLOG("maCreateImageFromData");

	// Byte array to hold resource data. This is the data we will
	// use to create the image.
	byte[] resourceData = new byte[size];

	// If data is a binary resource it is found in the table mBinaryResources.
	ByteBuffer binData = (ByteBuffer)mBinaryResources.get(data);
	if (null != binData)
	{
		try
		{
			// Load binary data into resource memory.
			binData.position(offset);
			binData.get(resourceData);
		}
		catch(Exception e)
		{
			logError("maCreateImageFromData - Couldn't read data, exception : " + e, e);
			return RES_BAD_INPUT;
		}
	}
	else // ubin
	{
		// If it is an unloaded binary resource (.ubin) it is found in mUBinaryResources.
		UBinData uBinData = (UBinData) mUBinaryResources.get(data);
		if (null != uBinData)
		{
			// Sanity check that offset + size is not larger the resource itself. 
			if (uBinData.getSize() < offset + size)
			{
				logError("maCreateImageFromData " +
					"size error, uBinData.getSize(): " + uBinData.getSize() + 
					" size: " + size + 
					" offset: " + offset);
				return RES_BAD_INPUT;
			}
		
			try
			{	
				// Read data from the resource asset file. All resources are
				// bundled into this file.
				AssetManager assetManager = mContext.getAssets();
				InputStream resourceFileInputStream = assetManager.open(RESOURCE_FILE);
			
				// Here we position the stream pointer at the offset where 
				// the image data starts.
				resourceFileInputStream.skip(uBinData.getOffset() + offset);
				
				// Read from asset file into the data array.
				resourceFileInputStream.read(resourceData);
			}
			catch(Exception e)
			{
				logError("maCreateImageFromData - Couldn't read read stream, exception : " + e.toString(), e);
				return RES_BAD_INPUT;
			}
		}
	}
	
	try 
	{
		// Create a Bitmap object from the resoure data.
		Bitmap decodedImage = BitmapFactory.decodeByteArray(resourceData, 0, resourceData.length);
		if (decodedImage == null)
		{
			logError("maCreateImageFromData - could not decode image data (decodedImage == null)");
			return RES_BAD_INPUT;
		}
		mImageResources.put(placeholder, new ImageCache(null, decodedImage));
	} 
	catch(UnsupportedOperationException e) 
	{
		logError("maCreateImageFromData - Unsupported operation, exception : " + e, e);
		return RES_BAD_INPUT;
	} 
	catch (java.lang.IllegalArgumentException e) 
	{
		logError("maCreateImageFromData - Illegal argument, exception : " + e, e);
		return RES_BAD_INPUT;
	} 
	catch (java.lang.OutOfMemoryError e) 
	{
		logError("maCreateImageFromData - Out of memory, exception : " + e, e);
		return RES_OUT_OF_MEMORY;
	}
	return RES_OK;
}

ByteBuffer tempImageRawBuffer;

/**
* @brief _maCreateImageRawGetData
*
* This fucntion generates a ByteBuffer which then is sent to the JNI library for processing
*/
ByteBuffer _maCreateImageRawGetData(int size)
{
	tempImageRawBuffer = ByteBuffer.allocateDirect(size);
	tempImageRawBuffer.order(null);
	
	return tempImageRawBuffer;
}

/**
* @brief _maCreateImageRaw
*
* Takes the preprocessed raw image data and copies the contents to a bitmap
*/
int _maCreateImageRaw(int placeholder, int width, int height)
{
	SYSLOG("maCreateImageRaw");
	
	Bitmap bitmap = Bitmap.createBitmap(width, height, Bitmap.Config.ARGB_8888);
	if(null == bitmap)
	{
		maPanic(1, "Unable to create ");
	}
	
	tempImageRawBuffer.position(0);
	bitmap.copyPixelsFromBuffer(tempImageRawBuffer);
	
	mImageResources.put(placeholder, new ImageCache(null, bitmap));
		
	return RES_OK;
}

/**
* @brief maCreateDrawableImage
*/
int maCreateDrawableImage(int placeholder, int width, int height)
{
	SYSLOG("maCreateDrawableImage");
	try
	{
		Bitmap bitmap = Bitmap.createBitmap(width, height, Bitmap.Config.ARGB_8888);
		Canvas canvas = new Canvas(bitmap);
	
		mImageResources.put(placeholder, new ImageCache(canvas, bitmap));	
	}
	catch (UnsupportedOperationException e)
	{
		logError("maCreateDrawableImage - e: " + e.toString(), e);
		return -1;
	}
	catch (Exception e)
	{
		logError("maCreateDrawableImage - e: " + e.toString(), e);
		return -1;
	}
	catch (java.lang.OutOfMemoryError e)
	{
		logError("maCreateDrawableImage - Out of Memory e: " + e.toString(), e);
		return -1;
	}
	return 1;
}

Hashtable<Integer, String> mStores = new Hashtable<Integer, String>();

int mMaxStoreId = 0;

final static String storesPath = "MAStore";

/**
* @brief maOpenStore
*/
int maOpenStore(String name, int flags)
{
	SYSLOG("maOpenStore");
	
	try
	{
		File f = mContext.getFileStreamPath(storesPath);

		if (f.isFile()) 
		{
			return STERR_GENERIC;
		}
		else if (!f.isDirectory())
		{
			boolean success = f.mkdir();
			if (!success) return STERR_GENERIC;
		}
		
		String filePath = storesPath + File.pathSeparator + name;
		f = mContext.getFileStreamPath(filePath);
		
		if (f.isDirectory()) return STERR_GENERIC;
		
		if (!f.isFile())
		{
			if ((flags & MAS_CREATE_IF_NECESSARY) == 0) return STERR_NONEXISTENT;
			f.createNewFile();
		}
		
		mMaxStoreId++;
		mStores.put(new Integer(mMaxStoreId), filePath);
		return mMaxStoreId;
	} 
	catch(Exception e) 
	{
		logError("open store exception : " + e.toString(), e);
		return STERR_GENERIC;
	}
}

/**
* @brief maWriteStore
*/
int maWriteStore(int store, int data)
{
	SYSLOG("maWriteStore");
	try 
	{
		File f = mContext.getFileStreamPath((String)mStores.get(new Integer(store)));
		if (f.isFile())
		{
			ByteBuffer bb = (ByteBuffer)mBinaryResources.get(data);
			if (null != bb)
			{
				FileOutputStream fos = new FileOutputStream(f, false);
				FileChannel fc = fos.getChannel();
				
				// Make sure that the buffer is reading from the start
				bb.position(0);
				
				fc.write(bb);
				fc.force(false);
				fc.close();
				fos.close();
				return 1;
			}
			
			UBinData ubd = (UBinData)mUBinaryResources.get(data);
			if (null != ubd)
			{
				byte[] ra = new byte[ubd.getSize()];
			
				AssetManager assetManager = mContext.getAssets();
				InputStream is = assetManager.open(RESOURCE_FILE);
				
				is.skip(ubd.getOffset());
				is.read(ra);
			
				FileOutputStream fos = new FileOutputStream(f, false);
				fos.write(ra);
				fos.close();
				return 1;
			}

			logError("Write Store - didn't find buffer, data:" + data);
			return STERR_GENERIC;			
		}
	} 
	catch(Exception e) 
	{
		logError("write store exception : " + e.toString(), e);
	}
	return STERR_GENERIC;
}

/**
* @brief _maReadStore
*/
ByteBuffer _maReadStore(int store, int resourceIndex)
{
	SYSLOG("_maReadStore");
	
	try 
	{
		File f = mContext.getFileStreamPath((String)mStores.get(new Integer(store)));
		byte[] buffer;
		int length = 0;
		if (f.isFile())
		{
			length = (int)f.length();
			buffer = new byte[length];
			
			FileInputStream fis = new FileInputStream(f);
			int offset = 0;
			while (offset >= 0 && offset < length)
			{
				offset = fis.read(buffer, offset, (length-offset));
			}
			fis.close();	
		}
		else
		{
			buffer = new byte[0];
		}
		
		ByteBuffer bb = loadBinary(resourceIndex, length);
		bb.put(buffer);
		return bb;
		
	} 
	catch(Exception e) 
	{
		logError("read store exception : " + e.toString(), e);
		return null;
	}
}

/**
* @brief maCloseStore
*/
void maCloseStore(int store, int remove)
{
	SYSLOG("maCloseStore");
	
	String filePath = (String)mStores.get(new Integer(store));
	if (remove != 0) 
	{
		File f = mContext.getFileStreamPath(filePath);
		f.delete();
	} 
	
	if (!(mStores.remove(new Integer(store)) == filePath))
	{
		maPanic(1, "maCloseStore failed!");
	}
}

#include "MoSyncSound.jpp"

#include "MoSyncBluetooth.jpp"

#include "MoSyncNetwork.jpp"

#include "MoSyncLocation.jpp"

/**
* @brief maLoadProgram
*/
void maLoadProgram(int data, int reload)
{
	SYSLOG("maLoadProgram");
}

/**
* @brief maGetKeys
*/
int maGetKeys()
{
	SYSLOG("maGetKeys");
	return -1;
}

/**
* @brief maGetEvent
*/
int maGetEvent(int event)
{
	SYSLOG("maGetEvent");
	return -1;
}

/**
* @brief maWait
*/
void maWait(int timeout)
{
	SYSLOG("maWait");	

	try
	{
 		if (timeout<=0)
		{
			this.sleep(Long.MAX_VALUE);
		}
		else
		{
			this.sleep(timeout);
		}
	} 
	catch (InterruptedException ie) 
	{
		SYSLOG("Sleeping thread interrupted!");
	} 
	catch (Exception e) 
	{
		logError("Thread sleep failed : " + e.toString(), e);
	}
	
	SYSLOG("maWait returned");
}

/**
* @brief maTime
*/
int maTime()
{
	SYSLOG("maTime");
	Date d = new Date();
	return (int)(d.getTime() / 1000);
}

/**
* @brief maLocalTime
*/
int maLocalTime()
{
	SYSLOG("maLocalTime");
	Date d = new Date();
	TimeZone tz = TimeZone.getDefault();
	return (int)((d.getTime() + tz.getRawOffset()) / 1000);
}

/**
* @brief maGetMilliSecondCount
*/
int maGetMilliSecondCount()
{
	return (int)SystemClock.elapsedRealtime();
}

/**
* @brief maFreeObjectMemory 
*/
int maFreeObjectMemory()
{
	SYSLOG("maFreeObjectMemory");
	return -1;
}

/**
* @brief maTotalObjectMemory
*/
int maTotalObjectMemory()
{
	SYSLOG("maTotalObjectMemory");
	return -1;
}

/**
* @brief maVibrate
*/
int maVibrate(int millisecondsToVibrate)
{
	SYSLOG("maVibrate");
	
	Vibrator vibrator = (Vibrator) mContext.getSystemService(Context.VIBRATOR_SERVICE);
	if (null == vibrator) 
	{
		return 0; // No vibrator.
	}
	
	if (0 == millisecondsToVibrate)
	{
		vibrator.cancel();
	}
	else
	{
		vibrator.vibrate(millisecondsToVibrate);
	}
	
	return 1;
}

/**
* @brief maPanic
*/
void maPanic(int result, String message)
{
	SYSLOG("maPanic");
	
	threadPanic(result, message);
}

/**
* @brief maInvokeExtension
*/
int maInvokeExtension(int function, int a, int b, int c)
{
	SYSLOG("maInvokeExtension");
	return -1;
}

/**
* @brief maIOCtl
*/
int maIOCtl(int function, int a, int b, int c)
{
	SYSLOG("maIOCtl");
	return -1;
}

/**
* @brief _enableFramebuffer
*/
void _enableFramebuffer(int address)
{
	mUsingFrameBuffer = true;
	mFrameBufferAddress = address; // address is pointing at a byte but that array is an int array..
	mFrameBufferSize = mWidth*mHeight;
	mFrameBufferBitmap = Bitmap.createBitmap(mWidth, mHeight, Bitmap.Config.ARGB_8888 );
	
}

/**
* @brief _disableFramebuffer
*/
void _disableFramebuffer()
{
	mUsingFrameBuffer = false;
}

/**
* Implemation of the maWriteLog syscall which only sends the log message to the Android Logcat
*
* @param str	The string to send to Logcat
*		 size	The number of characters in the string
*/
int maWriteLog(String str, int size)
{
	Log.i("maWriteLog", str);
	return 1;
}

/**
* @brief maGetSystemProperty
*/
int maGetSystemProperty(String key, int buf, int size)
{
	String property = "";
	
	if(key.equals("mosync.imei"))
	{
		TelephonyManager manager = (TelephonyManager)mContext.getSystemService(Context.TELEPHONY_SERVICE);
		property = manager.getDeviceId();
	}
	else if(key.equals("mosync.imsi"))
	{
		TelephonyManager manager = (TelephonyManager)mContext.getSystemService(Context.TELEPHONY_SERVICE);
		property = manager.getSubscriberId();
	}
	else if(key.equals("mosync.iso-639-1"))
	{
		Locale locale = Locale.getDefault();
		property = locale.getLanguage();
	}
	else if(key.equals("mosync.iso-639-2"))
	{
		Locale locale = Locale.getDefault();
		property = locale.getISO3Language();
	}
	
	if(null == property) return -2;
	
	if(0 == property.compareTo("")) return -2;
	
	if(property.length() >= size)
		return property.length() + 1;
		
	// Write this property to memory
	
	byte[] ba = property.getBytes();
	
	mMemDataSection.mark();
	mMemDataSection.position(buf);
	mMemDataSection.put(ba);
	mMemDataSection.put((byte)0);
	mMemDataSection.reset();
	
	return property.length() + 1;
}

/**
* @brief maPlatformRequest
*/
int maPlatformRequest(String url)
{
	if (url.startsWith("http://"))
	{
		Log.i("maPlatformRequest","Starting browser:" + url);
		Intent intent = new Intent(Intent.ACTION_VIEW);
		intent.setData(Uri.parse(url));
		((Activity)mContext).startActivity(intent);
		
		return 0;
	}
	return -1;
}

/**
* @brief maShowVirtualKeyboard
*/
int maShowVirtualKeyboard()
{
	InputMethodManager mgr = (InputMethodManager) mContext.getSystemService(Context.INPUT_METHOD_SERVICE);
	mgr.showSoftInput(mMoSyncView, InputMethodManager.SHOW_FORCED);
	return 0;
}

Hashtable<Integer, ImageCache> mImageResources = new Hashtable<Integer, ImageCache>();

/**
* @brief loadImage
*
* Stores an image resource. Since Andriod differs a lot from
* the other runtimes this is necessary. There isn't a duplicate stored
* on the JNI side.
*/
boolean loadImage(int resourceIndex, int pos, int length, int binaryResource)
{
	SYSLOG("LoadImage");
	SYSLOG("ri:" + resourceIndex + " pos:" + pos + " length:" + length + " br:" + binaryResource );
	try
	{
		byte[] ra = new byte[length];
		
		if(binaryResource != 0)
		{
			SYSLOG("Reading image resource from binary resource");
			ByteBuffer bb = (ByteBuffer)mBinaryResources.get(binaryResource);
			if(null == bb)
				return false;
			
			int p = bb.position();
			bb.position(pos);
			bb.get(ra);
			bb.position(p);
		}
		else // is ubin
		{
			SYSLOG("Reading image resource from asset");
			int offset =  pos-(int)mResourceOffset;
			
			AssetManager assetManager = mContext.getAssets();
			InputStream is = assetManager.open(RESOURCE_FILE);
			
			is.skip(offset);
			is.read(ra);
		}
		
		SYSLOG("Decode a bitmap!");
		Bitmap bitmap = BitmapFactory.decodeByteArray(ra, 0, length);
		if(bitmap != null)
		{
			SYSLOG("Bitmap was created!");
			mImageResources.put(resourceIndex, new ImageCache(null, bitmap));
			return true;
		}
		logError("loadImage - Bitmap wasn't created from Resource: " + resourceIndex);
		return false;
	}
	catch (Exception e)
	{
		logError("loadImage - Bitmap exceptions : " + e.toString(), e);
		return false;
	}
}

Hashtable<Integer, ByteBuffer> mBinaryResources = new Hashtable<Integer, ByteBuffer>();

/**
* @brief loadBinary
*
* Stores a binary resource. Since Andriod differs a lot from
* the other runtimes this is necessary. There isn't a duplicate stored
* on the JNI side.
*/
ByteBuffer loadBinary(int resourceIndex, int size)
{
	SYSLOG("loadBinary index:" + resourceIndex);
	
	try
	{
		ByteBuffer data = ByteBuffer.allocateDirect(size);
		data.order(null);
		mBinaryResources.put(resourceIndex, data);
		return data;
	}
	catch(Exception e)
	{
		logError("loadBinary - Out of Memory!", e);
		maPanic(1,"Out of Memory!");
	}
	return null;
}


/**
* @brief UBinData class
*
* Class that stores offset and size of an unloaded binary resource (.ubin). 
* These a memory saving resources that are loaded on demand. Om Android we
* need to store audio resource as files to be able to play them, there is
* some special handling of audio resources in the Android runtime. See file
* MoSyncSound.jpp.
*/
class UBinData
{
	public UBinData(int offset, int size)
	{
		mOffset = offset;
		mSize = size;
	}
	
	public int getOffset()
	{
		// getResourceStartOffset() is where resources start (after the header of 
		// the asset file).
		// We need to subtract this offset because resourceFileInputStream
		// will begin at mResourceOffset and uBinData.mOffset is the offset
		// from the actual beginning of the asset file.
		return mOffset - getResourceStartOffset();
	}
	
	public int getSize()
	{
		return mSize;
	}
	
	/**
	 * The byte offset in the resource file to the 
	 * beginning of this ubin.
	 */
	private int mOffset;
	
	/**
	 * The byte size of this ubin.
	 */
	private int mSize;
};

/**
 * Table that stores ubin resources. 
 */
Hashtable<Integer, UBinData> mUBinaryResources = 
	new Hashtable<Integer, UBinData>();

/**
 * Store information about an unloaded binary resource. 
 *
 * If the resource is an audio ubin, we also write it to a file,
 * because on Android we play audio from files.
 *
 * @param resourceIndex The id of the ubin resource.
 * @param offset The offset of the reosurce in the resource file.
 * @param size The size of the resource.
 */
void loadUBinary(int resourceIndex, int offset, int size)
{
	SYSLOG("loadUBinary index:" + resourceIndex);
	
	// Create a ubin data object that holds information about the object.
	UBinData ubinData = new UBinData(offset, size);
	mUBinaryResources.put(resourceIndex, ubinData);
	
	// If this is an audio ubin, it is written to a file.
	storeIfAudioUBin(ubinData, resourceIndex);
}

/**
* @brief destroyResource
*
* @param 	resourceIndex the resource index which should be destroyed
*/
void destroyResource(int resourceIndex)
{
	SYSLOG("destroyBinary :" + resourceIndex);
	
	if(null != mBinaryResources.get(resourceIndex))
	{
		mBinaryResources.remove(resourceIndex);
	}

	if(null != mUBinaryResources.get(resourceIndex))
	{
		mUBinaryResources.remove(resourceIndex);
	}

	if(null != mImageResources.get(resourceIndex))
	{
		mImageResources.remove(resourceIndex);
	}
}

/**
* @brief maTextBox
*/
int maTextBox(String title, String inText, int outText, int maxSize, int constraints)
{
	Intent intent = new Intent(mContext, TextBox.class);
	Bundle bundle = new Bundle();
	bundle.putString("TITLE", title);
	bundle.putString("TEXT", inText);
	bundle.putInt("OUTPUT", outText);
	bundle.putInt("CONSTRAINTS", constraints);
	intent.putExtras(bundle);
	mContext.startActivity(intent);
	Log.i("MoSync", "New activity started for InputBox");
	return 0;
}

int maNotificationAdd(int type, int id, String title, String text)
{
	Log.i("MoSync", "maNotificationAdd");
	
	// This is the only notification type we support at the moment.
	if (NOTIFICATION_TYPE_APPLICATION_LAUNCHER != type)
	{
		// TODO: Implement case for regular notifications.
		
		return -1;
	}
	
	MoSyncService.startService(
		mContext.getApplicationContext(), 
		id, 
		title, 
		text);
	//MoSyncService.startService(mContext, id, title, text);
	
	return 0;
}

/**
 * Depending of whether this is a NOTIFICATION_TYPE_APPLICATION_LAUNCHER
 * or a regular notification we either stop the service or remove the
 * notification.
 */
int maNotificationRemove(int notificationId)
{
	Log.i("MoSync", "maNotificationRemove");
	
	// Stop the service if this is the service notification id.
	if (MoSyncService.sNotificationId == notificationId)
	{
		// If api level is below 5, then also remove the 
		// notification manually.
#ifdef _ANDROID_API_LEVEL_5_OR_HIGHER
		// Nothing special need to be done.
#else
		// We are below API level 5. 
		// Remove the notification we used for the service.
		maNotificationRemoveHelper(notificationId);
#endif
		// Stop the service.
		MoSyncService.stopService();
		return 0;
	}
	
	// TODO: Implement case for regular notifications.
	
	return -1;
}

/**
 * Remove the notification.
 */
void maNotificationRemoveHelper(int notificationId)
{
	Activity activity = (Activity) mContext;
	NotificationManager mNotificationManager = (NotificationManager) 
		activity.getSystemService(Context.NOTIFICATION_SERVICE);
	mNotificationManager.cancel(notificationId);
}

int maSendToBackground()
{
	Log.i("MoSync", "maSendToBackground");
	
	final Activity activity = (Activity) mContext;
	
	activity.moveTaskToBack(true);
	
	// Alternatively use an intent that shows the home screen.
	// The drawback is that the activity that displayed the
	// MoSync app will not be displayed. We will always go to
	// the home screen, so this solution is less desirable.
	/*
	Intent intent = new Intent(Intent.ACTION_MAIN);
	intent.addCategory(Intent.CATEGORY_HOME);
	intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
	activity.startActivity(intent);
	*/
	
	return 0;
}

int maScreenSetOrientation(int orientation)
{
	Log.i("MoSync", "maScreenSetOrientation");

	// Attention! There is a name clash between the 
	// MoSync and the Android SCREEN_ORIENTATION_LANDSCAPE
	// and SCREEN_ORIENTATION_PORTRAIT constants!
	// Preprecessing of .jpp files fuck things up.
	// We therefore use the numeric values of these
	// constants in place of the symbolic Android names.
	if (SCREEN_ORIENTATION_LANDSCAPE == orientation)
	{
		// ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE
		maScreenSetOrientationHelper(0);
	}
	else if (SCREEN_ORIENTATION_PORTRAIT == orientation)
	{
		// ActivityInfo.SCREEN_ORIENTATION_PORTRAIT
		maScreenSetOrientationHelper(1);
	}
	else if (SCREEN_ORIENTATION_DYNAMIC == orientation)
	{
		maScreenSetOrientationHelper(
			ActivityInfo.SCREEN_ORIENTATION_SENSOR);
	}
	else
	{
		return -1;
	}
	
	return 0;
}

void maScreenSetOrientationHelper(final int androidScreenOrientation)
{
	final Activity activity = (Activity) mContext;
	
    activity.runOnUiThread(new Runnable()
	{
		public void run()
		{
			activity.setRequestedOrientation(androidScreenOrientation);
		}
	});
}

int maScreenSetFullscreen(final int fullscreen)
{
	Log.i("MoSync", "maScreenSetFullscreen");
	
	if (1 == fullscreen)
	{
		maScreenSetFullscreenHelper(true);
	}
	else if (0 == fullscreen)
	{
		maScreenSetFullscreenHelper(false);
	}
	else
	{
		return -1;
	}
	
	return 0;
}

void maScreenSetFullscreenHelper(final boolean fullscreenOn)
{
	final Activity activity = (Activity) mContext;
	
    activity.runOnUiThread(new Runnable()
	{
		public void run()
		{
			if (fullscreenOn)
			{
				activity.getWindow().addFlags(
					WindowManager.LayoutParams.FLAG_FULLSCREEN);
				activity.getWindow().clearFlags(
					WindowManager.LayoutParams.FLAG_FORCE_NOT_FULLSCREEN);
			}
			else
			{
				activity.getWindow().addFlags(
					WindowManager.LayoutParams.FLAG_FORCE_NOT_FULLSCREEN);
				activity.getWindow().clearFlags(
					WindowManager.LayoutParams.FLAG_FULLSCREEN);
			}
		}
	});
}

/**
 * TODO: Make a version of maWallpaperSet for Android 1.5.
 * Set the background image of the phone's home screen.
 * @param data Handle to an image object (PNG of JPEG)
 */
int maWallpaperSet(final int data)
{
	Log.i("MoSync", "maWallpaperSet handle: " + data);
	
	homeScreenPanicIfPermissionsAreNotSet();
	
	try 
	{
		// Get the data object.
		ImageCache image = (ImageCache) mImageResources.get(data);
		if (image == null) { return -1; }
		
#ifdef _ANDROID_API_LEVEL_5_OR_HIGHER
		// Get the wallpaper manager.
		WallpaperManager manager = WallpaperManager.getInstance(mContext);
		
		// Set wallpaper dimension to screen size.
		DisplayMetrics metrics = new DisplayMetrics();
		((Activity)mContext).getWindowManager().getDefaultDisplay().getMetrics(metrics);
		manager.suggestDesiredDimensions(metrics.widthPixels, metrics.heightPixels);

		// Set the wallpaper.
		manager.setBitmap(image.mBitmap);
#else
		((Activity)mContext).setWallpaper(image.mBitmap);
#endif // _ANDROID_API_LEVEL_5_OR_HIGHER

		return 0;
	} 
	catch (IOException ex) 
	{
		ex.printStackTrace();
	}

	return -1;
}

/**
 * Add a shortcut icon to the home screen. If called multiple times
 * multiple icons will be added. The shortcut launches the current
 * application.
 * @param name The text that will be used for the shortcut label.
 * @return <0 on error
 */
int maHomeScreenShortcutAdd(String name)
{
	homeScreenPanicIfPermissionsAreNotSet();
	
	// Create intent for the shortcut launcher.
	Intent shortcutIntent = new Intent(Intent.ACTION_MAIN);
	shortcutIntent.setClassName(mContext, mContext.getClass().getName());
	shortcutIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
	shortcutIntent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP);
	shortcutIntent.addFlags(Intent.FLAG_ACTIVITY_REORDER_TO_FRONT);
	shortcutIntent.addFlags(Intent.FLAG_ACTIVITY_SINGLE_TOP);
	
	// Get icon resource.
	int icon = mContext.getResources().getIdentifier(
		"icon", 
		"drawable", 
		mContext.getPackageName());
	
	// Create intent for adding a shortcut icon.
	Intent intent = new Intent();
	intent.putExtra(Intent.EXTRA_SHORTCUT_INTENT, shortcutIntent);
	intent.putExtra(Intent.EXTRA_SHORTCUT_NAME, name);
	intent.putExtra(
		Intent.EXTRA_SHORTCUT_ICON_RESOURCE, 
		Intent.ShortcutIconResource.fromContext(mContext, icon));
	intent.setAction("com.android.launcher.action.INSTALL_SHORTCUT");
	// Alternative form: intent.setAction(Intent.ACTION_CREATE_SHORTCUT); 
	
	// Broadcast the intent.
	mContext.getApplicationContext().sendBroadcast(intent);
	
	return 1;
}

/**
 * Remove a shortcut icon to the home screen. 
 * @param name The shortcut(s) with this label will be removed.
 * @return <0 on error
 */
int maHomeScreenShortcutRemove(String name)
{
	homeScreenPanicIfPermissionsAreNotSet();
	
	Intent shortcutIntent = new Intent(Intent.ACTION_MAIN);
	shortcutIntent.setClassName(mContext, mContext.getClass().getName());
	
	Intent intent = new Intent();
	intent.putExtra(Intent.EXTRA_SHORTCUT_INTENT, shortcutIntent);
	intent.putExtra(Intent.EXTRA_SHORTCUT_NAME, name);
	intent.setAction("com.android.launcher.action.UNINSTALL_SHORTCUT");
	
	mContext.getApplicationContext().sendBroadcast(intent);
	
	return 1;
}

/**
 * Thread that checks if the home screen is visible.
 */
HomeScreenDetectionThread mHomeScreenDetectionThread = null;

/**
 * Turn on/off sending of HomeScreen events. Off by default.
 * @param eventsOn 1 = events on, 0 = events off
 */
int maHomeScreenEventsOnOff(final int eventsOn)
{
	Log.i("MoSync", "maHomeScreenEventsOnOff");
	
	homeScreenPanicIfPermissionsAreNotSet();
	
	// Start home screen event polling thread.
	if (1 == eventsOn)
	{
		// Thread should not be started.
		if (null != mHomeScreenDetectionThread)
		{
			Log.i("MoSyncSyscalls", 
				"maHomeScreenEventsOnOff - thread already running");
			return -1;
		}
		
		// Create and start thread.
    	mHomeScreenDetectionThread = new HomeScreenDetectionThread();
		mHomeScreenDetectionThread.start();
		
		return 0;
	}
	// Stop home screen event polling thread.
	else if (0 == eventsOn)
	{
		mHomeScreenDetectionThread.stopThread();
		mHomeScreenDetectionThread = null;
	}
	
	return -1;
}

/**
 * Check if permissions needed by home screen syscalls are set, 
 * and if not call maPanic().
 */
void homeScreenPanicIfPermissionsAreNotSet()
{
	if ((PackageManager.PERMISSION_GRANTED != 
		 mContext.checkCallingOrSelfPermission(
			android.Manifest.permission.GET_TASKS))
		||
		(PackageManager.PERMISSION_GRANTED != 
		 mContext.checkCallingOrSelfPermission(
			android.Manifest.permission.SET_WALLPAPER))
		||
		(PackageManager.PERMISSION_GRANTED != 
		 mContext.checkCallingOrSelfPermission(
			android.Manifest.permission.SET_WALLPAPER_HINTS))
		||
		(PackageManager.PERMISSION_GRANTED != 
		 mContext.checkCallingOrSelfPermission(
			"com.android.launcher.permission.INSTALL_SHORTCUT"))
		||
		(PackageManager.PERMISSION_GRANTED != 
		 mContext.checkCallingOrSelfPermission(
			"com.android.launcher.permission.UNINSTALL_SHORTCUT"))
		)
	{
		maPanic(1, 
			"Permission 'Home Screen and Wallpaper access' " +
			"is not set in the MoSync project");
	}
}

class HomeScreenDetectionThread extends Thread
{
	/**
	 * The id of the home screen task. -1 means that the id is unknown.
	 */
	int mHomeScreenTaskId = -1;

	/**
	 * Keep track of whether we are on the home screen or not.
	 */
	boolean mIsOnHomeScreen = false;

	/**
	 * This thread will run as long as this variable is true.
	 */
	boolean mIsRunning = false;
	
	/**
	 * Constructor.
	 */
	public HomeScreenDetectionThread()
	{
	}
	
	/**
	 * Stop the trhead.
	 */
	public void stopThread()
	{
		mIsRunning = false;
	}
	
	public void run()
	{
		Log.i("MoSyncSyscalls", "HomeScreenDetectionThread is starting");
		
		// Used for printing debug messages at a reduced interval.
		int debugPrintAliveCounter = 0;
		
		mIsRunning = true;
		while (mIsRunning)
		{
			try
			{
				// Will print every 10 seconds.
				if (debugPrintAliveCounter++ % 10 == 0)
				{
					Log.i("MoSyncSyscalls", 
						"HomeScreenDetectionThread is alive."
						+ " mHomeScreenTaskId: " + mHomeScreenTaskId 
						+ " Timestamp: " + System.currentTimeMillis());
				}
				
				boolean isOnHomeScreen = isHomeScreenVisible();
				
				// Only post event if the state has changed.
				if (isOnHomeScreen != mIsOnHomeScreen)
				{
					// Update current state.
					mIsOnHomeScreen = isOnHomeScreen;
					
					// Post state change event.
					int[] event = new int[1];
					if (mIsOnHomeScreen)
					{
						Log.i("MoSyncSyscalls", 
							"HOMESCREEN IS SHOWN Timestamp: " 
							+ System.currentTimeMillis());
						event[0] = EVENT_TYPE_HOMESCREEN_SHOWN;
					}
					else
					{
						Log.i("MoSyncSyscalls", 
							"HOMESCREEN IS HIDDEN Timestamp: " 
							+ System.currentTimeMillis());
						event[0] = EVENT_TYPE_HOMESCREEN_HIDDEN;
					}
					postEvent(event);
				}
				
				Thread.sleep(1000);
			}
			catch (Exception ex)
			{
				Log.e("MoSyncSyscalls", 
					"HomeScreenDetectionThread exception: " + ex);
				ex.printStackTrace();
			}
		}
	}
	
	/**
	 * @return true if the home screen is visible.
	 */
    private boolean isHomeScreenVisible()
    {
		// We will use the ActivityManager to get info about the top task.
    	ActivityManager activityManager = (ActivityManager) 
    		mContext.getSystemService(Context.ACTIVITY_SERVICE);
    	if (null == activityManager) { return false; }
    	
		// Get a list with the top task.
    	List<RunningTaskInfo> taskList = activityManager.getRunningTasks(1);
    	if (null == taskList) { return false; }
		
		//int i = 0; 
		//for (RunningTaskInfo task : taskList)
		//{
		//	if (++i > 5) break;
		//	Log.i("@@@@@@@@", "@ " + task.baseActivity 
		//		+ " " + task.topActivity + " id: " + task.id);
		//}
    	
		// If the home screen task id is -1 it is not known.
		// Get it from the task list.
		if (-1 == mHomeScreenTaskId)
		{
			mHomeScreenTaskId = getHomeScreenTaskId();
		}
		
    	// Is the first task in the task list the home screen?
    	boolean isHomeScreen = mHomeScreenTaskId == taskList.get(0).id;
		
		// If we have not found the home screen, we make an extra
		// check of the class name. The home screen class is named
		// "Launcher" on the systems we have tested. It might be that
		// some other app, in another package, has the same name, and
		// then we will mistakenly think that we are on the home screen.
		// But if the mHomeScreenTaskId has been set this will not be
		// an issue. The background to this problem is that maSendToBack
		// (which calls moveTaskToBack) does not put the home screen task
		// in the RunningTaskInfo list. But pressingt the home key on the
		// device does so.
		if (-1 == mHomeScreenTaskId && !isHomeScreen)
		{
			isHomeScreen = taskList.get(0).baseActivity
				.getClassName().endsWith(".Launcher");
		}
		
    	return isHomeScreen;
    }
    
	/**
	 * @return The id of the home screen task, -1 on error or if not found.
	 */
    private int getHomeScreenTaskId()
    {
		// Get the ActivityManager.
    	ActivityManager activityManager = (ActivityManager) 
    		mContext.getSystemService(Context.ACTIVITY_SERVICE);
    	if (null == activityManager) { return -1; }
		
		// Get a list of recent tasks. This list contains info about 
		// The tasks so that we can determine which task is the
		// home screen. 
    	List<RecentTaskInfo> taskList = activityManager.getRecentTasks(
    		100,
    		ActivityManager.RECENT_WITH_EXCLUDED
    		);
			
    	if (null != taskList)
    	{
			// Search for the home screen task.
	    	for (ActivityManager.RecentTaskInfo taskInfo : taskList)
	    	{
		    	Intent intent = taskInfo.baseIntent;
		    	if (null == intent) { break; }
			
		    	// Get task categories.
		    	Set<String> categories = intent.getCategories();
		    	if (null == categories) { break; }
		    	
		    	// If this is a CATEGORY_HOME intent we are on the home screen.
		    	boolean isHomeScreen  = categories.contains(Intent.CATEGORY_HOME);
	    		if (isHomeScreen)
	    		{
					// We found the id of the home screen task.
	    			return taskInfo.id;
	    		}
	    	}
    	}
		
		// We did not find the id of the home screen task.
    	return -1;
    }
}
