/* Copyright (C) 2010 MoSync AB

This program is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License, version 2, as published by
the Free Software Foundation.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
for more details.

You should have received a copy of the GNU General Public License
along with this program; see the file COPYING.  If not, write to the Free
Software Foundation, 59 Temple Place - Suite 330, Boston, MA
02111-1307, USA.
*/

#include "helpers.h"
#include "config_platform.h"
#include "generated\MAAPI_consts.h"
#include "generated\IX_WEBVIEW_CONSTS.h"

//#define SYSLOG(a) Log.i("Dalvik Syscalls", a);
#define SYSLOG(...)

final class ImageCache
{
	Bitmap mBitmap;
	Canvas mCanvas;

	ImageCache(Canvas canvas, Bitmap bitmap)
	{
		mCanvas = canvas;
		mBitmap = bitmap;
	}
}


ByteBuffer mMemDataSection;
ByteBuffer mResourceFile;

Canvas mCanvas;
Bitmap mBitmap;

int mWidth;
int mHeight;

int mClipLeft, mClipTop, mClipWidth, mClipHeight;

boolean mUsingFrameBuffer;
int mFrameBufferAddress;
int mFrameBufferSize;
Bitmap mFrameBufferBitmap;

ImageCache mDrawTargetScreen = null;
ImageCache mDrawTarget = null;
int mDrawTargetHandle = 0;

int mSoundVolume;
MediaPlayer mMediaPlayer;

Paint mPaint = new Paint();
Paint mBlitPaint = new Paint();

boolean initSyscalls()
{
	SYSLOG("initSyscalls");
	 mUsingFrameBuffer = false;

	 mClipLeft = 0;
	 mClipTop = 0;
	 mClipWidth = mWidth;
	 mClipHeight = mHeight;

	 mPaint.setStyle(Paint.Style.FILL);
	 mPaint.setAntiAlias(false);
	 mPaint.setColor(0xffffffff);
	 
	 mBlitPaint.setAntiAlias(false);
	 mBlitPaint.setColor(0xffffffff);
	 
	 mSoundVolume = 50;
	 mMediaPlayer = new MediaPlayer();
	 mMediaPlayer.reset();

	 return true;
}

int maSetColor(int rgb)
{
	//SYSLOG("maSetColor");

	int t = mPaint.getColor();
	mPaint.setColor(rgb);
	mPaint.setAlpha(255);
	return t;
}

void maSetClipRect(int left, int top, int width, int height)
{
	SYSLOG("maSetClipRect");

	mClipLeft = left;
	mClipTop = top;
	mClipWidth = width;
	mClipHeight = height;

	mCanvas.clipRect(left, top, left+width, top+height, Region.Op.REPLACE );
}

void maPlot(int posX, int posY)
{
	SYSLOG("maPlot");

	mCanvas.drawPoint(posX, posY, mPaint);
}

void maLine(int startX, int startY, int endX, int endY)
{
	SYSLOG("maLine");

	mCanvas.drawLine(startX, startY, endX, endY, mPaint);
}

void maFillRect(int left, int top, int width, int height)
{
	SYSLOG("maFillRect");

	mCanvas.drawRect(left, top, left+width, top+height, mPaint);
	
}

void maFillTriangleStrip(int address, int count)
{
	SYSLOG("maFillTriangleStrip - NOT IMPLEMENTED");
}

void maFillTriangleFan(int address, int count)
{
	SYSLOG("maFillTriangleFan");
}

Rect mTextSizeRect = new Rect();
int maGetTextSize(final String str)
{
	//SYSLOG("maGetTextSize");
	mPaint.getTextBounds(str, 0, str.length(), mTextSizeRect);
	return EXTENT(mTextSizeRect.width(), mTextSizeRect.height());
}

int maGetTextSizeW(final String str)
{
	//SYSLOG("maGetTextSizeW");
	mPaint.getTextBounds(str, 0, str.length(), mTextSizeRect);
	return EXTENT(mTextSizeRect.width(), mTextSizeRect.height());
}

void maDrawText(int left, int top, final String str)
{
	//SYSLOG("maDrawText");
	MAExtent e = maGetTextSize(str);
	mCanvas.drawText(str, left, top+EXTENT_Y(e), mPaint);
}

void maDrawTextW(int left, int top, final String str)
{
 	//SYSLOG("maDrawTextW");
	MAExtent e = maGetTextSize(str);
	mCanvas.drawText(str, left, top+EXTENT_Y(e), mPaint);
}

void maUpdateScreen()
{
	SYSLOG("maUpdateScreen");
	Canvas lockedCanvas = null;

	long st = System.currentTimeMillis();
	
	MoSyncView moSyncView = ((MoSync) mContext).getMoSyncView();
	
	if(moSyncView == null) return;

	try 
	{
		lockedCanvas = moSyncView.mSurfaceHolder.lockCanvas();
		synchronized (moSyncView.mSurfaceHolder)
		{
			if(mUsingFrameBuffer)
			{				
				mMemDataSection.mark();
				mMemDataSection.position(mFrameBufferAddress);
				mFrameBufferBitmap.copyPixelsFromBuffer(mMemDataSection);
				mMemDataSection.reset();
				
				lockedCanvas.drawBitmap(mFrameBufferBitmap, 0, 0, mBlitPaint);
			}
			else
			{
				if(null != lockedCanvas)
				{
					lockedCanvas.drawBitmap(mBitmap, 0, 0, mBlitPaint);
				}
			}
		}
	} 
	catch(Exception e)
	{
		SYSLOG("updateScreen Exception : " + e.toString());
		return;
	}
		
	if (lockedCanvas != null)
	{
		moSyncView.mSurfaceHolder.unlockCanvasAndPost(lockedCanvas);
	}
	
	long t = System.currentTimeMillis() - st;
	Log.i("Dalvik Syscalls", "Update screen took: " + t + "ms");
	
}

void maResetBacklight()
{
	SYSLOG("maResetBacklight");
}

int maGetScrSize()
{
	SYSLOG("maGetScrSize");
	return EXTENT(mWidth, mHeight);
}

void maDrawImage(int image, int left, int top)
{
	SYSLOG("maDrawImage");
	
	ImageCache imageResource = (ImageCache)mImageResources.get(new Integer(image));
	if(imageResource == null)
	{
		return;
	}

	mCanvas.drawBitmap(imageResource.mBitmap, left, top, mPaint);
}

void maDrawRGB(int dstPoint, int src, int srcRect, int scanlength)
{
	SYSLOG("maDrawRGB");
}

private Bitmap mTempBitmap;
private Matrix mTempMatrix = new Matrix();

void _maDrawImageRegion(int image, int srcRectLeft, int srcRectTop, int srcRectWidth, int srcRectHeight, int dstLeft, int dstTop, int transformMode)
{
	SYSLOG("maDrawImageRegion");

	ImageCache imageResource = (ImageCache)mImageResources.get(image);
	if(imageResource == null)
	{
		return;
	}

	final int imgHeight = imageResource.mBitmap.getHeight();
	if(srcRectTop > imgHeight) return;
	
	final int imgWidth = imageResource.mBitmap.getWidth();
	if(srcRectLeft > imgWidth) return;
	
	if(srcRectTop < 0)
	{
		srcRectHeight += srcRectTop;
		srcRectTop = 0;
	}
	
	if(srcRectLeft < 0)
	{
		srcRectWidth += srcRectLeft;
		srcRectLeft = 0;
	}
	
	if(srcRectTop + srcRectHeight > imgHeight)
	{
		srcRectHeight = imgHeight - srcRectTop;
	}
	
	if(srcRectLeft + srcRectWidth > imgWidth)
	{
		srcRectWidth = imgWidth - srcRectLeft;
	}
	
	if(srcRectWidth <= 0 || srcRectHeight <= 0)
		return;

	if(transformMode == TRANS_NONE)
	{
		mCanvas.clipRect(dstLeft, dstTop, dstLeft+srcRectWidth, dstTop+srcRectHeight, Region.Op.REPLACE);
		mCanvas.drawBitmap(imageResource.mBitmap, dstLeft-srcRectLeft, dstTop-srcRectTop, mPaint);
		mCanvas.clipRect(mClipLeft, mClipTop, mClipLeft+mClipWidth, mClipTop+mClipHeight, Region.Op.REPLACE );
		return;
	}
	else
	{
		boolean mirror = false;
		int rotation = 0;

		switch(transformMode)
		{
		case TRANS_ROT90:
			rotation = 90;
			break;
		case TRANS_ROT180:
			rotation = 180;
			break;
		case TRANS_ROT270:
			rotation = 270;
			break;
		case TRANS_MIRROR:
			mirror = true;
			break;
		case TRANS_MIRROR_ROT90:
			mirror = true;
			rotation = 90;
			break;
		case TRANS_MIRROR_ROT180:
			mirror = true;
			rotation = 180;
		break;
		case TRANS_MIRROR_ROT270:
			mirror = true;
			rotation = 270;
			break;
		default:
		maPanic(0,"error");
		}

		mTempMatrix.reset();
		if(mirror)
		{
			mTempMatrix.setScale(-1, 1);
			mTempMatrix.postTranslate(imgWidth, 0);
		}
		if(rotation != 0) {
			mTempMatrix.postRotate(rotation);
		}

		/* TO-DO: This implementation is really slow, needs to be fixed */
		mTempBitmap = Bitmap.createBitmap(imageResource.mBitmap, srcRectLeft, srcRectTop, srcRectWidth, srcRectHeight, mTempMatrix, false);

		mCanvas.drawBitmap(mTempBitmap, dstLeft, dstTop, mPaint);

	}
}

int maGetImageSize(int image)
{
	SYSLOG("maGetImageSize");
	ImageCache imageResource = (ImageCache)mImageResources.get(new Integer(image));
	if(imageResource == null)
	{
		return -1;
	}

	return EXTENT(imageResource.mBitmap.getWidth(), imageResource.mBitmap.getHeight());
}

void maGetImageData(int image, int dst, int srcRect, int scanlength)
{
	SYSLOG("maGetImageData");
/*	
	mMemDataSection.mark();
	mMemDataSection.position(mFrameBufferAddress);
	mFrameBufferBitmap.copyPixelsFromBuffer(mMemDataSection);
	mMemDataSection.reset();
*/	
	
/*	
	Bitmap bitmap = ((ImageCache)getResource(image)).mBitmap;
	int[] mem_ds = CORE.mMem_ds;
	bitmap.getPixels(mCore.mMem_ds, dst>>2, scanlength, MARect_left(srcRect), MARect_top(srcRect),
		MARect_width(srcRect), MARect_height(srcRect));
*/
}

int maSetDrawTarget(int image)
{
	SYSLOG("maSetDrawTarget");
	if(0 == image)
	{
		mCanvas = mDrawTargetScreen.mCanvas;
		mBitmap = mDrawTargetScreen.mBitmap;
	}
	else
	{
		ImageCache imageResource = (ImageCache)mImageResources.get(new Integer(image));
		if(null == imageResource)
		{
			return -1;
		}

		mCanvas = imageResource.mCanvas;
		mBitmap = imageResource.mBitmap;
	}
	return 1;
}

int maCreateImageFromData(int placeholder, int data, int offset, int size)
{
	SYSLOG("maCreateImageFromData");

	ByteBuffer bb = (ByteBuffer)mBinaryResources.get(data);
	if(null == bb)
	{
		return RES_BAD_INPUT;
	}
	
	byte[] ra = new byte[size];
	try
	{
		bb.position(offset);
		bb.get(ra);
	}catch(Exception e){
		return RES_BAD_INPUT;
	}

	try {
		Log.i("Decode image","size:" + size + " offset:" + offset + " ra.length:" + ra.length);
		Bitmap decodedImage = BitmapFactory.decodeByteArray(ra, 0, ra.length);
		if(decodedImage == null)
		{
			return RES_BAD_INPUT;
		}
		mImageResources.put(placeholder, new ImageCache(null, decodedImage));
		
	} catch(UnsupportedOperationException e) {
		Log.e("maCreateImageFromData exception",e.toString());
		return RES_BAD_INPUT;
	} catch(java.lang.IllegalArgumentException e) {
		return RES_BAD_INPUT;
	} catch(java.lang.OutOfMemoryError e) {
		return RES_OUT_OF_MEMORY;
	}
	return RES_OK;
}

ByteBuffer tempImageRawBuffer;
ByteBuffer _maCreateImageRawGetData(int size)
{
	tempImageRawBuffer = ByteBuffer.allocateDirect(size);
	return tempImageRawBuffer;
}

// This function takes the content of the tempImageRawBuffer and creates an Image from it.
// 
//
int _maCreateImageRaw(int placeholder, int width, int height)
{
	SYSLOG("maCreateImageRaw");
	
	Bitmap bitmap = Bitmap.createBitmap(width, height, Bitmap.Config.ARGB_8888);
	bitmap.copyPixelsFromBuffer(tempImageRawBuffer);
	
	mImageResources.put(placeholder, new ImageCache(null, bitmap));
	
	return RES_OK;
}

int maCreateDrawableImage(int placeholder, int width, int height)
{
	SYSLOG("maCreateDrawableImage");
	SYSLOG("ph: " + placeholder + " width; " + width + " height: " + height);
	try
	{
		Bitmap bitmap = Bitmap.createBitmap(width, height, Bitmap.Config.ARGB_8888);
		Canvas canvas = new Canvas(bitmap);
	
		mImageResources.put(placeholder, new ImageCache(canvas, bitmap));
	}
	catch(UnsupportedOperationException e)
	{
		Log.i("maCreateDrawableImage","e: " + e.toString());
		return -1;
	}
	catch(Exception e)
	{
		Log.i("maCreateDrawableImage","e: " + e.toString());
		return -1;
	}
	catch(java.lang.OutOfMemoryError e)
	{
		return -1;
	}
	return 1;
}

Hashtable<Integer, String> mStores = new Hashtable<Integer, String>();
int mMaxStoreId = 0;

final static String storesPath = "MAStore";
int maOpenStore(String name, int flags)
{
	SYSLOG("maOpenStore");
	
	try
	{
		File f = mContext.getFileStreamPath(storesPath);

		if(f.isFile()) return STERR_GENERIC;
		else if(!f.isDirectory())
		{
			boolean success = f.mkdir();
			if(!success) return STERR_GENERIC;
		}
		
		String filePath = storesPath + File.pathSeparator + name;
		f = mContext.getFileStreamPath(filePath);
		
		if(f.isDirectory()) return STERR_GENERIC;
		if(!f.isFile())
		{
			if ((flags & MAS_CREATE_IF_NECESSARY) == 0) return STERR_NONEXISTENT;
			f.createNewFile();
		}
		
		mMaxStoreId++;
		mStores.put(new Integer(mMaxStoreId), filePath);
		return mMaxStoreId;

	} catch(Exception e) {
		PRINT_STACK_TRACE;
		SYSLOG("open store exception : " + e.toString());
		return STERR_GENERIC;
	}
}

int maWriteStore(int store, int data)
{
	SYSLOG("maWriteStore");
	try {
		File f = mContext.getFileStreamPath((String)mStores.get(new Integer(store)));
		if(f.isFile())
		{
			SYSLOG("Looking for binary resource..");
			ByteBuffer bb = (ByteBuffer)mBinaryResources.get(data);
			if(null != bb)
			{
				SYSLOG("Found it!");
				FileOutputStream fos = new FileOutputStream(f, false);
				FileChannel fc = fos.getChannel();
				
				fc.write(bb);
				
				fos.close();
				return 1;
			}
			
			SYSLOG("Looking for ubinary resource..");
			UBinData ubd = (UBinData)mUBinaryResources.get(data);
			if(null != ubd)
			{
				SYSLOG("Found it!");
				byte[] ra = new byte[ubd.mSize];
			
				AssetManager assetManager = mContext.getAssets();
				InputStream is = assetManager.open("resources.mp3");
				
				is.skip(ubd.mOffset - (int)mResourceOffset);
				is.read(ra);
			
				FileOutputStream fos = new FileOutputStream(f, false);
				fos.write(ra);
				fos.close();
				return 1;
			}
			
			SYSLOG("didn't find buffer, data:" + data);
			return STERR_GENERIC;			
		}
	} catch(Exception e) {
		SYSLOG("write store exception : " + e.toString());
		PRINT_STACK_TRACE;
	}
	return STERR_GENERIC;
}

ByteBuffer _maReadStore(int store, int resourceIndex)
{
	SYSLOG("_maReadStore");
	
	try {
		File f = mContext.getFileStreamPath((String)mStores.get(new Integer(store)));
		byte[] buffer;
		int length = 0;
		if(f.isFile())
		{
			length = (int)f.length();
			buffer = new byte[length];
			
			FileInputStream fis = new FileInputStream(f);
			int offset = 0;
			while(offset >= 0 && offset < length)
				offset = fis.read(buffer, offset, (length-offset));
			fis.close();	
		}
		else
		{
			buffer = new byte[0];
		}
		
		ByteBuffer bb = loadBinary(resourceIndex, length);
		bb.put(buffer);
		return bb;
		
	} catch(Exception e) {
		SYSLOG("read store exception : " + e.toString());
		PRINT_STACK_TRACE;
		return null;
	}
}

void maCloseStore(int store, int remove)
{
	SYSLOG("maCloseStore");
	
	String filePath = (String)mStores.get(new Integer(store));
	if(remove != 0) {
		File f = mContext.getFileStreamPath(filePath);
		f.delete();
	} 
	
	if(!(mStores.remove(new Integer(store)) == filePath))
		maPanic(1, "maCloseStore failed!");
}

#include "MoSyncSound.jpp"

#ifdef _ANDROID_BLUETOOTH
#include "MoSyncBluetooth.jpp"
#endif

#include "MoSyncNetwork.jpp"

#include "MoSyncLocation.jpp"

void maLoadProgram(int data, int reload)
{
	SYSLOG("maLoadProgram");
}

int maGetKeys()
{
	SYSLOG("maGetKeys");
	return -1;
}

int maGetEvent(int event)
{
	SYSLOG("maGetEvent");
	return -1;
}

void maWait(int timeout)
{
	SYSLOG("maWait");	

	try
	{
		Log.i("MoSyncThread","sleep for :" + timeout);
		if(timeout<=0)
			this.sleep(Long.MAX_VALUE);
		else
			this.sleep(timeout);

	} catch(InterruptedException ie) {
		Log.i("MoSync View","Sleeping thread interrupted!");
	} catch(Exception e) {
		Log.i("MoSync View","Thread sleep failed : " + e.toString());
	}
	
	SYSLOG("maWait returned");
}

int maTime()
{
	SYSLOG("maTime");
	Date d = new Date();
	return (int)(d.getTime() / 1000);
}

int maLocalTime()
{
	SYSLOG("maLocalTime");
	Date d = new Date();
	TimeZone tz = TimeZone.getDefault();
	return (int)((d.getTime() + tz.getRawOffset()) / 1000);
}

int maGetMilliSecondCount()
{
	return (int)System.currentTimeMillis();
}

int maFreeObjectMemory()
{
	SYSLOG("maFreeObjectMemory");
	return -1;
}

int maTotalObjectMemory()
{
	SYSLOG("maTotalObjectMemory");
	return -1;
}

int maVibrate(int ms)
{
	SYSLOG("maVibrate");
	return -1;
}

void maPanic(int result, String message)
{
	SYSLOG("maPanic");
	
	threadPanic(result, message);
}

int maInvokeExtension(int function, int a, int b, int c)
{
	SYSLOG("maInvokeExtension");
	return -1;
}

int maIOCtl(int function, int a, int b, int c)
{
	SYSLOG("maIOCtl");
	return -1;
}

void _enableFramebuffer(int address)
{
	mUsingFrameBuffer = true;
	mFrameBufferAddress = address; // address is pointing at a byte but that array is an int array..
	mFrameBufferSize = mWidth*mHeight;
	mFrameBufferBitmap = Bitmap.createBitmap(mWidth, mHeight, Bitmap.Config.ARGB_8888 );
}

void _disableFramebuffer()
{
	mUsingFrameBuffer = false;
}

/**
* Implemation of the maWriteLog syscall which only sends the log message to the Android Logcat
*
* @param str	The string to send to Logcat
*		 size	The number of characters in the string
*/
int maWriteLog(String str, int size)
{
	Log.i("maWriteLog", str);
	return 1;
}

int maGetSystemProperty(String key, int buf, int size)
{
	String property = "";
	
	if(key.equals("mosync.imei"))
	{
		TelephonyManager manager = (TelephonyManager)mContext.getSystemService(Context.TELEPHONY_SERVICE);
		property = manager.getDeviceId();
	}
	else if(key.equals("mosync.imsi"))
	{
		TelephonyManager manager = (TelephonyManager)mContext.getSystemService(Context.TELEPHONY_SERVICE);
		property = manager.getSubscriberId();
	}
	else if(key.equals("mosync.iso-639-1"))
	{
		Locale locale = Locale.getDefault();
		property = locale.getLanguage();
	}
	else if(key.equals("mosync.iso-639-2"))
	{
		Locale locale = Locale.getDefault();
		property = locale.getISO3Language();
	}
	
	if(null == property)
		return -2;
	
	if(property.length() >= size)
		return property.length() + 1;
		
	// Write this property to memory
	
	byte[] ba = property.getBytes();
	
	mMemDataSection.mark();
	mMemDataSection.position(buf);
	mMemDataSection.put(ba);
	mMemDataSection.put((byte)0);
	mMemDataSection.reset();
	
	return property.length() + 1;
}

int maPlatformRequest(String url)
{
	if(url.startsWith("http://"))
	{
		Log.i("maPlatformRequest","Starting browser:" + url);
		Intent i = new Intent(Intent.ACTION_VIEW);
		i.setData(Uri.parse(url));
		((Activity)mContext).startActivity(i);
		
		return 0;
	}
	return -1;
}

int maShowVirtualKeyboard()
{
	MoSyncView moSyncView = ((MoSync) mContext).getMoSyncView();
	if(moSyncView == null) return -1;
	InputMethodManager mgr = (InputMethodManager) mContext.getSystemService(Context.INPUT_METHOD_SERVICE);
	mgr.showSoftInput(moSyncView, InputMethodManager.SHOW_FORCED);
	return 0;
}

int maWebViewOpen()
{
	Log.i("MoSync", "maWebViewOpen");
	return ((MoSync) mContext).maWebViewOpen();
}

int maWebViewClose()
{
	Log.i("MoSync", "maWebViewClose");
	// Old code: WebViewActivity.getInstance().close();
	return ((MoSync) mContext).maWebViewClose();
}

int maWebViewSetHTML(String html)
{
	Log.i("MoSync", "maWebViewSetHTML");
	// Old code: WebViewActivity.getInstance().setHTML(html);
	return ((MoSync) mContext).maWebViewSetHTML(html);
}

int maWebViewLoadURL(String url)
{
	Log.i("MoSync", "maWebViewLoadURL");
	// Old code: WebViewActivity.getInstance().loadURL(url);
	return ((MoSync) mContext).maWebViewLoadURL(url);
}

int maWebViewEvaluateScript(String script)
{
	Log.i("MoSync", "maWebViewEvaluateScript");
	// Old code: WebViewActivity.getInstance().evaluateScript(script);
	return ((MoSync) mContext).maWebViewEvaluateScript(script);
}

int maWebViewGetRequestSize(int requestID)
{
	Log.i("MoSync", "maWebViewGetRequestSize");
	// Old code: return WebViewActivity.getInstance().getRequestSize(requestID);
	return ((MoSync) mContext).maWebViewGetRequestSize(requestID);
}

int maWebViewGetRequest(int requestID, int buf, int bufSize)
{
	Log.i("MoSync", "maWebViewGetRequest");
	
	// Old code: int size = WebViewActivity.getInstance().getRequestSize(requestID);
	int size = ((MoSync) mContext).maWebViewGetRequestSize(requestID);
	if (bufSize < size)
	{
		Log.i("MoSync", "maWebViewGetRequest - error");
		return WEBVIEW_ERROR;
	}
		
	// Write request to memory.
	
	// Old code: byte[] bytes = WebViewActivity.getInstance().getRequestBytes(requestID);
	byte[] bytes = ((MoSync) mContext).maWebViewGetRequestBytes(requestID);
	
	mMemDataSection.mark();
	mMemDataSection.position(buf);
	mMemDataSection.put(bytes);
	mMemDataSection.put((byte)0);
	mMemDataSection.reset();
	
	return size;
}

/*
// This is a test method that pops up a Toast.
int maWebViewOpenToast()
{
	Log.i("MoSync", "maWebViewOpen1");

	final Activity activity = (Activity) mContext;
	activity.runOnUiThread(new Runnable() 
	{
		public void run() 
		{
			try 
			{	
				android.widget.Toast.makeText(
					activity,
					"Hello World!", 
					android.widget.Toast.LENGTH_SHORT).show();
			}
			catch (Throwable e)
			{
				Log.i("MoSync", "maWebViewOpenToast - error: " + e);
			}
		}
	});
	
	return 1;
}
*/

Hashtable<Integer, ImageCache> mImageResources = new Hashtable<Integer, ImageCache>();

boolean loadImage(int resourceIndex, int pos, int length, int binaryResource)
{
	SYSLOG("LoadImage");
	SYSLOG("ri:" + resourceIndex + " pos:" + pos + " length:" + length + " br:" + binaryResource );
	try
	{
		byte[] ra = new byte[length];
		
		if(binaryResource != 0)
		{
			SYSLOG("Reading image resource from binary resource");
			ByteBuffer bb = (ByteBuffer)mBinaryResources.get(binaryResource);
			if(null == bb)
				return false;
			
			int p = bb.position();
			bb.position(pos);
			bb.get(ra);
			bb.position(p);
		}
		else
		{
			SYSLOG("Reading image resource from asset");
			int offset =  pos-(int)mResourceOffset;
			SYSLOG("resoff:" + mResourceOffset + " pos: " + pos + " finaloffset: " + offset);
			
			AssetManager assetManager = mContext.getAssets();
			InputStream is = assetManager.open("resources.mp3");
			
			SYSLOG("read stream");
			is.skip(offset);
			is.read(ra);
			SYSLOG("stream finished");
		}
		
		SYSLOG("Decode a bitmap!");
		Bitmap bitmap = BitmapFactory.decodeByteArray(ra, 0, length);
		if(bitmap != null)
		{
			SYSLOG("Bitmap was created!");
			mImageResources.put(resourceIndex, new ImageCache(null, bitmap));
			return true;
		}
		SYSLOG("Bitmap wasn't created!");
		return false;
	}
	catch (Exception e)
	{
		SYSLOG("Bitmap exceptions : " + e.toString());
		return false;
	}
}

Hashtable<Integer, ByteBuffer> mBinaryResources = new Hashtable<Integer, ByteBuffer>();

ByteBuffer loadBinary(int resourceIndex, int size)
{
	SYSLOG("loadBinary index:" + resourceIndex);
	
	try
	{
		ByteBuffer data = ByteBuffer.allocateDirect(size);
		mBinaryResources.put(resourceIndex, data);
		return data;
	}
	catch(Exception e)
	{
		Log.i("MoSyncThread", "Out of Memory!");
	}
	return null;
}

class UBinData
{
	public UBinData(int offset, int size)
	{
		mOffset = offset;
		mSize = size;
	}
	public int mOffset;
	public int mSize;
}

Hashtable<Integer, UBinData> mUBinaryResources = new Hashtable<Integer, UBinData>();

void loadUBinary(int resourceIndex, int offset, int size)
{
	SYSLOG("loadUBinary index:" + resourceIndex);
	UBinData ubd = new UBinData(offset, size);
	mUBinaryResources.put(resourceIndex, ubd);
	
	// UBIN must always point to the resource file.
	try
	{
		AssetManager assetManager = mContext.getAssets();
		AssetFileDescriptor pAfd = assetManager.openFd("resources.mp3");
	
		FileInputStream fis = pAfd.createInputStream();
		fis.skip(offset);
	
		if(true == checkIfMimeAudioType(fis))
			storeAudioUBin(ubd, resourceIndex);
	}
	catch(IOException ioe)
	{
	
	}
	catch(Exception e)
	{
	
	}
}

void destroyResource(int resourceIndex)
{
	SYSLOG("destroyBinary :" + resourceIndex);
	
	if(mBinaryResources.contains(resourceIndex))
	{
		mBinaryResources.remove(resourceIndex);
		return;
	}

	if(mUBinaryResources.contains(resourceIndex))
	{
		mUBinaryResources.remove(resourceIndex);
		return;
	}

	if(mImageResources.contains(resourceIndex))
	{
		mImageResources.remove(resourceIndex);
		return;
	}
}
