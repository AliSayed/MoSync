/* Copyright (C) 2010 MoSync AB

This program is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License, version 2, as published by
the Free Software Foundation.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
for more details.

You should have received a copy of the GNU General Public License
along with this program; see the file COPYING.  If not, write to the Free
Software Foundation, 59 Temple Place - Suite 330, Boston, MA
02111-1307, USA.
*/

#include "helpers.h"
#include "config_platform.h"
#include "generated/MAAPI_consts.h"

//#define SYSLOG(a) Log.i("Dalvik Syscalls", a);
#define SYSLOG(...)

final class ImageCache
{
	Bitmap mBitmap;
	Canvas mCanvas;

	ImageCache(Canvas canvas, Bitmap bitmap)
	{
		mCanvas = canvas;
		mBitmap = bitmap;
	}
}

public ByteBuffer mMemDataSection;
ByteBuffer mResourceFile;

Canvas mCanvas;
Bitmap mBitmap;

int mWidth;
int mHeight;

int mClipLeft, mClipTop, mClipWidth, mClipHeight;

boolean mUsingFrameBuffer;
int mFrameBufferAddress;
int mFrameBufferSize;
Bitmap mFrameBufferBitmap;

ImageCache mDrawTargetScreen = null;
ImageCache mDrawTarget = null;
int mDrawTargetHandle = 0;

int mSoundVolume;
MediaPlayer mMediaPlayer;

Paint mPaint = new Paint();
Paint mBlitPaint = new Paint();

boolean initSyscalls()
{
	SYSLOG("initSyscalls");
	 mUsingFrameBuffer = false;

	 mClipLeft = 0;
	 mClipTop = 0;
	 mClipWidth = mWidth;
	 mClipHeight = mHeight;

	 mPaint.setStyle(Paint.Style.FILL);
	 mPaint.setAntiAlias(false);
	 mPaint.setColor(0xffffffff);
	 
	 mBlitPaint.setAntiAlias(false);
	 mBlitPaint.setColor(0xffffffff);
	 mBlitPaint.setAlpha(255);
	 
	 mSoundVolume = 50;
	 
	 return true;
}

/**
* @brief maSetColor
*/
int maSetColor(int rgb)
{
	SYSLOG("maSetColor");

	int t = mPaint.getColor();
	mPaint.setColor(rgb);
	mPaint.setAlpha(255);
	return t;
}

/**
* @brief maSetClipRect
*/
void maSetClipRect(int left, int top, int width, int height)
{
	SYSLOG("maSetClipRect");

	mClipLeft = left;
	mClipTop = top;
	mClipWidth = width;
	mClipHeight = height;

	mCanvas.clipRect(left, top, left+width, top+height, Region.Op.REPLACE );
}

/**
* @brief maPlot
*/
void maPlot(int posX, int posY)
{
	SYSLOG("maPlot");

	mCanvas.drawPoint(posX, posY, mPaint);
}

/**
* @brief maLine
*/
void maLine(int startX, int startY, int endX, int endY)
{
	SYSLOG("maLine");

	mCanvas.drawLine(startX, startY, endX, endY, mPaint);
}

/**
* @brief maFillRect
*/
void maFillRect(int left, int top, int width, int height)
{
	SYSLOG("maFillRect");

	mCanvas.drawRect(left, top, left+width, top+height, mPaint);
}

/*
This implementation might seem a bit strange but it works so much better than using Canvas.drawVertices..
*/
/**
* @brief maFillTriangleStrip
*/
void maFillTriangleStrip(int address, int count)
{
	SYSLOG("maFillTriangleStrip");

	if(count < 3) maPanic(1,"maFillTriangleStrip takes more than 3 vertices");

	mMemDataSection.mark();
	mMemDataSection.position(address);

	IntBuffer ib = mMemDataSection.asIntBuffer();
	
	int[] vertices = new int[count*2];
	ib.get(vertices);
	
	Path path = new Path();

	int i = 0;
	
	int xa = vertices[i++];
	int ya = vertices[i++];

	int xb = vertices[i++];
	int yb = vertices[i++];
	for(;;) {
		int xc = vertices[i++];
		int yc = vertices[i++];
		path.moveTo(xa,ya);
		path.lineTo(xb,yb);
		path.lineTo(xc,yc);
		path.close();
		
		if(i >= count*2)
			break;
		xa = vertices[i++];
		ya = vertices[i++];
		path.moveTo(xb,yb);
		path.lineTo(xc,yc);
		path.lineTo(xa,ya);
		path.close();
		
		if(i >= count*2)
			break;
		xb = vertices[i++];
		yb = vertices[i++];
		path.moveTo(xc,yc);
		path.lineTo(xa,ya);
		path.lineTo(xb,yb);
		path.close();
		
		if(i >= count*2)
			break;			
	}
	mCanvas.drawPath(path, mPaint);
	
	mMemDataSection.reset();
	
}


/**
* @brief maFillTriangleFan
*/
void maFillTriangleFan(int address, int count)
{
	SYSLOG("maFillTriangleFan");

	if(count < 3) maPanic(1,"maFillTriangleFan takes more than 3 vertices");

	mMemDataSection.mark();
	mMemDataSection.position(address);

	IntBuffer ib = mMemDataSection.asIntBuffer();
	
	int[] vertices = new int[count*2];
	ib.get(vertices);
	
	Path path = new Path();

	int i = 0;
	
	int xa = vertices[i++];
	int ya = vertices[i++];

	int xb = vertices[i++];
	int yb = vertices[i++];
	for(;;) {
		int xc = vertices[i++];
		int yc = vertices[i++];
		path.moveTo(xa,ya);
		path.lineTo(xb,yb);
		path.lineTo(xc,yc);
		path.close();
		
		if(i >= count*2)
			break;
		xa = vertices[i++];
		ya = vertices[i++];
		path.moveTo(xa,ya);
		path.lineTo(xc,yc);
		path.lineTo(xb,yb);
		path.close();
		
		if(i >= count*2)
			break;			
	}
	mCanvas.drawPath(path, mPaint);
	
	mMemDataSection.reset();
}


Rect mTextSizeRect = new Rect();

/**
* @brief msGetTextSize
*/
int maGetTextSize(final String str)
{
	SYSLOG("maGetTextSize");
	
	mPaint.getTextBounds(str, 0, str.length(), mTextSizeRect);
	return EXTENT(mTextSizeRect.width(), mTextSizeRect.height());
}

/**
* @brief maGetTextSizeW
*/
int maGetTextSizeW(final String str)
{
	SYSLOG("maGetTextSizeW");
	
	mPaint.getTextBounds(str, 0, str.length(), mTextSizeRect);
	return EXTENT(mTextSizeRect.width(), mTextSizeRect.height());
}

/**
* @brief maDrawText
*/
void maDrawText(int left, int top, final String str)
{
	SYSLOG("maDrawText");
	
	MAExtent e = maGetTextSize(str);
	mCanvas.drawText(str, left, top+EXTENT_Y(e), mPaint);
}

/**
* @brief maDrawTextW
*/
void maDrawTextW(int left, int top, final String str)
{
 	SYSLOG("maDrawTextW");
	
	MAExtent e = maGetTextSize(str);
	mCanvas.drawText(str, left, top+EXTENT_Y(e), mPaint);
}

/**
* @brief maUpdateScreen
*/
void maUpdateScreen()
{
	SYSLOG("maUpdateScreen");
	Canvas lockedCanvas = null;
	
	if (mMoSyncView == null) return;

	try 
	{
		lockedCanvas = mMoSyncView.mSurfaceHolder.lockCanvas();
		synchronized (mMoSyncView.mSurfaceHolder)
		{
			if (mUsingFrameBuffer)
			{				
				mMemDataSection.mark();
				mMemDataSection.position(mFrameBufferAddress);
				mFrameBufferBitmap.copyPixelsFromBuffer(mMemDataSection);
				mMemDataSection.reset();
				
				// Clear the screen.. in this case draw the canvas black
				lockedCanvas.drawRGB(0,0,0);
				
				// Blit the framebuffer
				lockedCanvas.drawBitmap(mFrameBufferBitmap, 0, 0, mBlitPaint);
			}
			else
			{
				if (null != lockedCanvas)
				{
					lockedCanvas.drawBitmap(mBitmap, 0, 0, mBlitPaint);
				}
			}
		}
	} 
	catch (Exception e)
	{
		SYSLOG("updateScreen Exception : " + e.toString());
		return;
	}
		
	if (lockedCanvas != null)
	{
		mMoSyncView.mSurfaceHolder.unlockCanvasAndPost(lockedCanvas);
	}
	
}

/**
* @brief maResetBacklight
*/
void maResetBacklight()
{
	SYSLOG("maResetBacklight");
}

/**
* @brief maGetScrSize
*/
int maGetScrSize()
{
	SYSLOG("maGetScrSize");
	return EXTENT(mWidth, mHeight);
}

/**
* @brief maDrawImage
*/
void maDrawImage(int image, int left, int top)
{
	SYSLOG("maDrawImage");
	
	ImageCache imageResource = (ImageCache)mImageResources.get(new Integer(image));
	if (imageResource == null)
	{
		return;
	}

	mCanvas.drawBitmap(imageResource.mBitmap, left, top, null);//mPaint);
}

/**
* @brief _maDrawRGB
*/
void _maDrawRGB(int dstX, int dstY, int mem, int srcRectLeft, int srcRectTop, int srcRectWidth, int srcRectHeight, int scanLength)
{
	SYSLOG("maDrawRGB");

	int pixels[] = new int[srcRectWidth];
	
	mMemDataSection.mark();
	mMemDataSection.position(mem);

	IntBuffer ib = mMemDataSection.asIntBuffer();
	
	for(int y = 0; y < srcRectHeight; y++)
	{
		ib.position(y*scanLength);		
		
		ib.get(pixels);
		mCanvas.drawBitmap(pixels, 0, srcRectWidth, dstX, dstY+y, srcRectWidth, 1, true, mPaint);		
	}
	
	mMemDataSection.reset();
}

private Bitmap mTempBitmap;
private Matrix mTempMatrix = new Matrix();

/**
* @brief _maDrawImageRegion 
*/
void _maDrawImageRegion(int image, int srcRectLeft, int srcRectTop, int srcRectWidth, int srcRectHeight, int dstLeft, int dstTop, int transformMode)
{
	SYSLOG("maDrawImageRegion");

	ImageCache imageResource = (ImageCache)mImageResources.get(image);
	if (imageResource == null)
	{
		return;
	}

	final int imgHeight = imageResource.mBitmap.getHeight();
	if (srcRectTop > imgHeight) 
	{
		return;
	}
	
	final int imgWidth = imageResource.mBitmap.getWidth();
	if (srcRectLeft > imgWidth) 
	{
		return;
	}
	
	if (srcRectTop < 0)
	{
		srcRectHeight += srcRectTop;
		srcRectTop = 0;
	}
	
	if (srcRectLeft < 0)
	{
		srcRectWidth += srcRectLeft;
		srcRectLeft = 0;
	}
	
	if (srcRectTop + srcRectHeight > imgHeight)
	{
		srcRectHeight = imgHeight - srcRectTop;
	}
	
	if (srcRectLeft + srcRectWidth > imgWidth)
	{
		srcRectWidth = imgWidth - srcRectLeft;
	}
	
	if (srcRectWidth <= 0 || srcRectHeight <= 0) 
	{
		return;
	}

	if (transformMode == TRANS_NONE)
	{
		mCanvas.clipRect(dstLeft, dstTop, dstLeft+srcRectWidth, dstTop+srcRectHeight, Region.Op.REPLACE);
		mCanvas.drawBitmap(imageResource.mBitmap, dstLeft-srcRectLeft, dstTop-srcRectTop, mPaint);
		mCanvas.clipRect(mClipLeft, mClipTop, mClipLeft+mClipWidth, mClipTop+mClipHeight, Region.Op.REPLACE );
		return;
	}
	else
	{
		boolean mirror = false;
		int rotation = 0;

		switch (transformMode)
		{
		case TRANS_ROT90:
			rotation = 90;
			break;
		case TRANS_ROT180:
			rotation = 180;
			break;
		case TRANS_ROT270:
			rotation = 270;
			break;
		case TRANS_MIRROR:
			mirror = true;
			break;
		case TRANS_MIRROR_ROT90:
			mirror = true;
			rotation = 90;
			break;
		case TRANS_MIRROR_ROT180:
			mirror = true;
			rotation = 180;
			break;
		case TRANS_MIRROR_ROT270:
			mirror = true;
			rotation = 270;
			break;
		default:
			maPanic(0,"error");
		}

		mTempMatrix.reset();
		if (mirror)
		{
			mTempMatrix.setScale(-1, 1);
			mTempMatrix.postTranslate(imgWidth, 0);
		}
		if (rotation != 0) {
			mTempMatrix.postRotate(rotation);
		}

		/* TO-DO: This implementation is really slow, needs to be fixed */
		mTempBitmap = Bitmap.createBitmap(imageResource.mBitmap, srcRectLeft, srcRectTop, srcRectWidth, srcRectHeight, mTempMatrix, false);

		mCanvas.drawBitmap(mTempBitmap, dstLeft, dstTop, mPaint);

	}
}

/**
* @brief maGetImageSize
*/
int maGetImageSize(int image)
{
	SYSLOG("maGetImageSize");
	ImageCache imageResource = (ImageCache)mImageResources.get(new Integer(image));
	if (imageResource == null)
	{
		Log.i("MoSync Dalvik","maGetImageSize : no such resource");
		return -1;
	}

	return EXTENT(imageResource.mBitmap.getWidth(), imageResource.mBitmap.getHeight());
}

/**
* @brief maGetImageData
*/
void _maGetImageData(int image, int dst, int srcLeft, int srcTop, int srcWidth, int srcHeight, int scanLength)
{
	SYSLOG("maGetImageData");

	ImageCache imageResource = (ImageCache)mImageResources.get(image);
	if(null == imageResource)
	{
		maPanic(1,"maGetImageData failed, no image resource!");
	}
	
	int bitmapSize = scanLength * srcHeight;
	
	if ((srcTop + srcHeight) > imageResource.mBitmap.getHeight()) maPanic(-1, "maGetImageData, (srcTop + srcHeight) > imageResource.mBitmap.getHeight() : " + (srcTop + srcHeight) + " > " + imageResource.mBitmap.getHeight());
	if ((srcLeft + srcWidth) > imageResource.mBitmap.getWidth()) maPanic(-1, "maGetImageData, (srcLeft + srcWidth) > imageResource.mBitmap.getWidth() : " + (srcLeft + srcWidth) + " > " + imageResource.mBitmap.getWidth());	


	int pixels[] = new int[srcWidth];
	
	mMemDataSection.mark();
	mMemDataSection.position(dst);

	IntBuffer ib = mMemDataSection.asIntBuffer();
	
	for(int y = 0; y < srcHeight; y++)
	{
		ib.position(y*scanLength);		
		imageResource.mBitmap.getPixels(pixels, 0, srcWidth, srcLeft, srcTop+y, srcWidth, 1);
		
		ib.put(pixels);	
	}
	
	mMemDataSection.reset();
	
}

/**
* @brief maSetDrawTarget
*/
int maSetDrawTarget(int image)
{
	SYSLOG("maSetDrawTarget");
	if (0 == image)
	{
		mCanvas = mDrawTargetScreen.mCanvas;
		mBitmap = mDrawTargetScreen.mBitmap;
	}
	else
	{
		ImageCache imageResource = (ImageCache)mImageResources.get(new Integer(image));
		if (null == imageResource)
		{
			return -1;
		}

		mCanvas = imageResource.mCanvas;
		mBitmap = imageResource.mBitmap;
	}
	return 1;
}

/**
* @brief maCreateImageFromData
*/
int maCreateImageFromData(int placeholder, int data, int offset, int size)
{
	SYSLOG("maCreateImageFromData");

	byte[] ra = new byte[size];

	ByteBuffer bb = (ByteBuffer)mBinaryResources.get(data);
	if (null != bb)
	{
		try
		{
			bb.position(offset);
			bb.get(ra);
		}
		catch(Exception e)
		{
			return RES_BAD_INPUT;
		}
	}
	else
	{
		UBinData ubd = (UBinData)mUBinaryResources.get(data);
		if (null != ubd)
		{
			if(ubd.mSize != size)
			{
				return RES_BAD_INPUT;
			}
		
			try
			{	
				AssetManager assetManager = mContext.getAssets();
				InputStream is = assetManager.open(RESOURCE_FILE);
			
				is.skip(ubd.mOffset - (int)mResourceOffset);
				is.read(ra);
			}
			catch(Exception e)
			{
				return RES_BAD_INPUT;
			}
		}
	}
	
	try 
	{
		Bitmap decodedImage = BitmapFactory.decodeByteArray(ra, 0, ra.length);
		if (decodedImage == null)
		{
			return RES_BAD_INPUT;
		}
		mImageResources.put(placeholder, new ImageCache(null, decodedImage));
	} 
	catch(UnsupportedOperationException e) 
	{
		return RES_BAD_INPUT;
	} 
	catch (java.lang.IllegalArgumentException e) 
	{
		return RES_BAD_INPUT;
	} 
	catch (java.lang.OutOfMemoryError e) 
	{
		return RES_OUT_OF_MEMORY;
	}
	return RES_OK;
}

ByteBuffer tempImageRawBuffer;

/**
* @brief _maCreateImageRawGetData
*
* This fucntion generates a ByteBuffer which then is sent to the JNI library for processing
*/
ByteBuffer _maCreateImageRawGetData(int size)
{
	tempImageRawBuffer = ByteBuffer.allocateDirect(size);
	tempImageRawBuffer.order(null);
	
	return tempImageRawBuffer;
}

/**
* @brief _maCreateImageRaw
*
* Takes the preprocessed raw image data and copies the contents to a bitmap
*/
int _maCreateImageRaw(int placeholder, int width, int height)
{
	SYSLOG("maCreateImageRaw");
	
	Bitmap bitmap = Bitmap.createBitmap(width, height, Bitmap.Config.ARGB_8888);
	if(null == bitmap)
	{
		maPanic(1, "Unable to create ");
	}
	
	tempImageRawBuffer.position(0);
	bitmap.copyPixelsFromBuffer(tempImageRawBuffer);
	
	mImageResources.put(placeholder, new ImageCache(null, bitmap));
		
	return RES_OK;
}

/**
* @brief maCreateDrawableImage
*/
int maCreateDrawableImage(int placeholder, int width, int height)
{
	SYSLOG("maCreateDrawableImage");
	try
	{
		Bitmap bitmap = Bitmap.createBitmap(width, height, Bitmap.Config.ARGB_8888);
		Canvas canvas = new Canvas(bitmap);
	
		mImageResources.put(placeholder, new ImageCache(canvas, bitmap));	
	}
	catch (UnsupportedOperationException e)
	{
		Log.i("maCreateDrawableImage","e: " + e.toString());
		return -1;
	}
	catch (Exception e)
	{
		Log.i("maCreateDrawableImage","e: " + e.toString());
		return -1;
	}
	catch (java.lang.OutOfMemoryError e)
	{
		return -1;
	}
	return 1;
}

Hashtable<Integer, String> mStores = new Hashtable<Integer, String>();

int mMaxStoreId = 0;

final static String storesPath = "MAStore";

/**
* @brief maOpenStore
*/
int maOpenStore(String name, int flags)
{
	SYSLOG("maOpenStore");
	
	try
	{
		File f = mContext.getFileStreamPath(storesPath);

		if (f.isFile()) 
		{
			return STERR_GENERIC;
		}
		else if (!f.isDirectory())
		{
			boolean success = f.mkdir();
			if (!success) return STERR_GENERIC;
		}
		
		String filePath = storesPath + File.pathSeparator + name;
		f = mContext.getFileStreamPath(filePath);
		
		if (f.isDirectory()) return STERR_GENERIC;
		
		if (!f.isFile())
		{
			if ((flags & MAS_CREATE_IF_NECESSARY) == 0) return STERR_NONEXISTENT;
			f.createNewFile();
		}
		
		mMaxStoreId++;
		mStores.put(new Integer(mMaxStoreId), filePath);
		return mMaxStoreId;
	} 
	catch(Exception e) 
	{
		PRINT_STACK_TRACE;
		SYSLOG("open store exception : " + e.toString());
		return STERR_GENERIC;
	}
}

/**
* @brief maWriteStore
*/
int maWriteStore(int store, int data)
{
	SYSLOG("maWriteStore");
	try 
	{
		File f = mContext.getFileStreamPath((String)mStores.get(new Integer(store)));
		if (f.isFile())
		{
			SYSLOG("Looking for binary resource..");
			ByteBuffer bb = (ByteBuffer)mBinaryResources.get(data);
			if (null != bb)
			{
				SYSLOG("Found it!");
				FileOutputStream fos = new FileOutputStream(f, false);
				FileChannel fc = fos.getChannel();
				
				fc.write(bb);
				
				fos.close();
				return 1;
			}
			
			SYSLOG("Looking for ubinary resource..");
			UBinData ubd = (UBinData)mUBinaryResources.get(data);
			if (null != ubd)
			{
				SYSLOG("Found it!");
				byte[] ra = new byte[ubd.mSize];
			
				AssetManager assetManager = mContext.getAssets();
				InputStream is = assetManager.open(RESOURCE_FILE);
				
				is.skip(ubd.mOffset - (int)mResourceOffset);
				is.read(ra);
			
				FileOutputStream fos = new FileOutputStream(f, false);
				fos.write(ra);
				fos.close();
				return 1;
			}
			
			SYSLOG("didn't find buffer, data:" + data);
			return STERR_GENERIC;			
		}
	} 
	catch(Exception e) 
	{
		SYSLOG("write store exception : " + e.toString());
		PRINT_STACK_TRACE;
	}
	return STERR_GENERIC;
}

/**
* @brief _maReadStore
*/
ByteBuffer _maReadStore(int store, int resourceIndex)
{
	SYSLOG("_maReadStore");
	
	try 
	{
		File f = mContext.getFileStreamPath((String)mStores.get(new Integer(store)));
		byte[] buffer;
		int length = 0;
		if (f.isFile())
		{
			length = (int)f.length();
			buffer = new byte[length];
			
			FileInputStream fis = new FileInputStream(f);
			int offset = 0;
			while (offset >= 0 && offset < length)
			{
				offset = fis.read(buffer, offset, (length-offset));
			}
			fis.close();	
		}
		else
		{
			buffer = new byte[0];
		}
		
		ByteBuffer bb = loadBinary(resourceIndex, length);
		bb.put(buffer);
		return bb;
		
	} 
	catch(Exception e) 
	{
		SYSLOG("read store exception : " + e.toString());
		PRINT_STACK_TRACE;
		return null;
	}
}

/**
* @brief maCloseStore
*/
void maCloseStore(int store, int remove)
{
	SYSLOG("maCloseStore");
	
	String filePath = (String)mStores.get(new Integer(store));
	if (remove != 0) 
	{
		File f = mContext.getFileStreamPath(filePath);
		f.delete();
	} 
	
	if (!(mStores.remove(new Integer(store)) == filePath))
	{
		maPanic(1, "maCloseStore failed!");
	}
}

#include "MoSyncSound.jpp"

#include "MoSyncBluetooth.jpp"

#include "MoSyncNetwork.jpp"

#include "MoSyncLocation.jpp"

/**
* @brief maLoadProgram
*/
void maLoadProgram(int data, int reload)
{
	SYSLOG("maLoadProgram");
}

/**
* @brief maGetKeys
*/
int maGetKeys()
{
	SYSLOG("maGetKeys");
	return -1;
}

/**
* @brief maGetEvent
*/
int maGetEvent(int event)
{
	SYSLOG("maGetEvent");
	return -1;
}

/**
* @brief maWait
*/
void maWait(int timeout)
{
	SYSLOG("maWait");	

	try
	{
 		if (timeout<=0)
		{
			this.sleep(Long.MAX_VALUE);
		}
		else
		{
			this.sleep(timeout);
		}
	} 
	catch (InterruptedException ie) 
	{
		SYSLOG("Sleeping thread interrupted!");
	} 
	catch (Exception e) 
	{
		Log.i("MoSync View","Thread sleep failed : " + e.toString());
	}
	
	SYSLOG("maWait returned");
}

/**
* @brief maTime
*/
int maTime()
{
	SYSLOG("maTime");
	Date d = new Date();
	return (int)(d.getTime() / 1000);
}

/**
* @brief maLocalTime
*/
int maLocalTime()
{
	SYSLOG("maLocalTime");
	Date d = new Date();
	TimeZone tz = TimeZone.getDefault();
	return (int)((d.getTime() + tz.getRawOffset()) / 1000);
}

/**
* @brief maGetMilliSecondCount
*/
int maGetMilliSecondCount()
{
	return (int)SystemClock.elapsedRealtime();
}

/**
* @brief maFreeObjectMemory 
*/
int maFreeObjectMemory()
{
	SYSLOG("maFreeObjectMemory");
	return -1;
}

/**
* @brief maTotalObjectMemory
*/
int maTotalObjectMemory()
{
	SYSLOG("maTotalObjectMemory");
	return -1;
}

/**
* @brief maVibrate
*/
int maVibrate(int millisecondsToVibrate)
{
	SYSLOG("maVibrate");
	
	Vibrator vibrator = (Vibrator) mContext.getSystemService(Context.VIBRATOR_SERVICE);
	if (null == vibrator) 
	{
		return 0; // No vibrator.
	}
	
	if (0 == millisecondsToVibrate)
	{
		vibrator.cancel();
	}
	else
	{
		vibrator.vibrate(millisecondsToVibrate);
	}
	
	return 1;
}

/**
* @brief maPanic
*/
void maPanic(int result, String message)
{
	SYSLOG("maPanic");
	
	threadPanic(result, message);
}

/**
* @brief maInvokeExtension
*/
int maInvokeExtension(int function, int a, int b, int c)
{
	SYSLOG("maInvokeExtension");
	return -1;
}

/**
* @brief maIOCtl
*/
int maIOCtl(int function, int a, int b, int c)
{
	SYSLOG("maIOCtl");
	return -1;
}

/**
* @brief _enableFramebuffer
*/
void _enableFramebuffer(int address)
{
	mUsingFrameBuffer = true;
	mFrameBufferAddress = address; // address is pointing at a byte but that array is an int array..
	mFrameBufferSize = mWidth*mHeight;
	mFrameBufferBitmap = Bitmap.createBitmap(mWidth, mHeight, Bitmap.Config.ARGB_8888 );
	
}

/**
* @brief _disableFramebuffer
*/
void _disableFramebuffer()
{
	mUsingFrameBuffer = false;
}

/**
* Implemation of the maWriteLog syscall which only sends the log message to the Android Logcat
*
* @param str	The string to send to Logcat
*		 size	The number of characters in the string
*/
int maWriteLog(String str, int size)
{
	Log.i("maWriteLog", str);
	return 1;
}

/**
* @brief maGetSystemProperty
*/
int maGetSystemProperty(String key, int buf, int size)
{
	String property = "";
	
	if(key.equals("mosync.imei"))
	{
		TelephonyManager manager = (TelephonyManager)mContext.getSystemService(Context.TELEPHONY_SERVICE);
		property = manager.getDeviceId();
	}
	else if(key.equals("mosync.imsi"))
	{
		TelephonyManager manager = (TelephonyManager)mContext.getSystemService(Context.TELEPHONY_SERVICE);
		property = manager.getSubscriberId();
	}
	else if(key.equals("mosync.iso-639-1"))
	{
		Locale locale = Locale.getDefault();
		property = locale.getLanguage();
	}
	else if(key.equals("mosync.iso-639-2"))
	{
		Locale locale = Locale.getDefault();
		property = locale.getISO3Language();
	}
	
	if(null == property)
		return -2;
	
	if(property.length() >= size)
		return property.length() + 1;
		
	// Write this property to memory
	
	byte[] ba = property.getBytes();
	
	mMemDataSection.mark();
	mMemDataSection.position(buf);
	mMemDataSection.put(ba);
	mMemDataSection.put((byte)0);
	mMemDataSection.reset();
	
	return property.length() + 1;
}

/**
* @brief maPlatformRequest
*/
int maPlatformRequest(String url)
{
	if(url.startsWith("http://"))
	{
		Log.i("maPlatformRequest","Starting browser:" + url);
		Intent i = new Intent(Intent.ACTION_VIEW);
		i.setData(Uri.parse(url));
		((Activity)mContext).startActivity(i);
		
		return 0;
	}
	return -1;
}

/**
* @brief maShowVirtualKeyboard
*/
int maShowVirtualKeyboard()
{
	InputMethodManager mgr = (InputMethodManager) mContext.getSystemService(Context.INPUT_METHOD_SERVICE);
	mgr.showSoftInput(mMoSyncView, InputMethodManager.SHOW_FORCED);
	return 0;
}

Hashtable<Integer, ImageCache> mImageResources = new Hashtable<Integer, ImageCache>();

/**
* @brief loadImage
*
* Stores an image resource. Since Andriod differs a lot from
* the other runtimes this is necessary. There isn't a duplicate stored
* on the JNI side.
*/
boolean loadImage(int resourceIndex, int pos, int length, int binaryResource)
{
	SYSLOG("LoadImage");
	SYSLOG("ri:" + resourceIndex + " pos:" + pos + " length:" + length + " br:" + binaryResource );
	try
	{
		byte[] ra = new byte[length];
		
		if(binaryResource != 0)
		{
			SYSLOG("Reading image resource from binary resource");
			ByteBuffer bb = (ByteBuffer)mBinaryResources.get(binaryResource);
			if(null == bb)
				return false;
			
			int p = bb.position();
			bb.position(pos);
			bb.get(ra);
			bb.position(p);
		}
		else
		{
			SYSLOG("Reading image resource from asset");
			int offset =  pos-(int)mResourceOffset;
			
			AssetManager assetManager = mContext.getAssets();
			InputStream is = assetManager.open(RESOURCE_FILE);
			
			is.skip(offset);
			is.read(ra);
		}
		
		SYSLOG("Decode a bitmap!");
		Bitmap bitmap = BitmapFactory.decodeByteArray(ra, 0, length);
		if(bitmap != null)
		{
			SYSLOG("Bitmap was created!");
			mImageResources.put(resourceIndex, new ImageCache(null, bitmap));
			return true;
		}
		SYSLOG("Bitmap wasn't created!");
		return false;
	}
	catch (Exception e)
	{
		SYSLOG("Bitmap exceptions : " + e.toString());
		return false;
	}
}

Hashtable<Integer, ByteBuffer> mBinaryResources = new Hashtable<Integer, ByteBuffer>();

/**
* @brief loadBinary
*
* Stores a binary resource. Since Andriod differs a lot from
* the other runtimes this is necessary. There isn't a duplicate stored
* on the JNI side.
*/
ByteBuffer loadBinary(int resourceIndex, int size)
{
	SYSLOG("loadBinary index:" + resourceIndex);
	
	try
	{
		ByteBuffer data = ByteBuffer.allocateDirect(size);
		data.order(null);
		mBinaryResources.put(resourceIndex, data);
		return data;
	}
	catch(Exception e)
	{
		Log.i("MoSyncThread", "Out of Memory!");
		maPanic(1,"Out of Memory!");
	}
	return null;
}


/**
* @brief UBinData class
*/
class UBinData
{
	public UBinData(int offset, int size)
	{
		mOffset = offset;
		mSize = size;
	}
	public int mOffset;
	public int mSize;
};

Hashtable<Integer, UBinData> mUBinaryResources = new Hashtable<Integer, UBinData>();


/**
* @brief loadUBinary
*
* Stores an unloaded binary resource. Since Andriod differs a lot from
* the other runtimes this is necessary. There isn't a duplicate stored
* on the JNI side.
*/
void loadUBinary(int resourceIndex, int offset, int size)
{
	SYSLOG("loadUBinary index:" + resourceIndex);
	UBinData ubd = new UBinData(offset, size);
	mUBinaryResources.put(resourceIndex, ubd);
	
	// UBIN must always point to the resource file.
	try
	{
		AssetManager assetManager = mContext.getAssets();
		AssetFileDescriptor pAfd = assetManager.openFd(RESOURCE_FILE);
	
		FileInputStream fis = pAfd.createInputStream();
		fis.skip(offset);
	
		if(true == checkIfMimeAudioType(fis))
			storeAudioUBin(ubd, resourceIndex);
	}
	catch(IOException ioe)
	{
	
	}
	catch(Exception e)
	{
	
	}
}

/**
* @brief destroyResource
*
* @param 	resourceIndex the resource index which should be destroyed
*/
void destroyResource(int resourceIndex)
{
	SYSLOG("destroyBinary :" + resourceIndex);
	Log.i("destroyResource","Trying to destroy resources : " + resourceIndex);
	
	if(null != mBinaryResources.get(resourceIndex))
	{
		mBinaryResources.remove(resourceIndex);
		Log.i("destroyResource","Binary resource removed");
	}

	if(null != mUBinaryResources.get(resourceIndex))
	{
		mUBinaryResources.remove(resourceIndex);
		Log.i("destroyResource","UBinary resource removed");
	}

	if(null != mImageResources.get(resourceIndex))
	{
		mImageResources.remove(resourceIndex);
		Log.i("destroyResource","Image resource removed");
	}


}

/**
* @brief maTextBox
*/
int maTextBox(String title, String inText, int outText, int maxSize, int constraints)
{
	Intent intent = new Intent(mContext, TextBox.class);
	Bundle bundle = new Bundle();
	bundle.putString("TITLE", title);
	bundle.putString("TEXT", inText);
	bundle.putInt("OUTPUT", outText);
	intent.putExtras(bundle);
	mContext.startActivity(intent);
	Log.i("MoSync", "New activity started for InputBox");
	return 0;
}

