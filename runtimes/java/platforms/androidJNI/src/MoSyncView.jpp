/* Copyright (C) 2010 MoSync AB

This program is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License, version 2, as published by
the Free Software Foundation.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
for more details.

You should have received a copy of the GNU General Public License
along with this program; see the file COPYING.  If not, write to the Free
Software Foundation, 59 Temple Place - Suite 330, Boston, MA
02111-1307, USA.
*/

package com.mosync.java.android;

import android.view.SurfaceView;
import android.view.SurfaceHolder;
import android.view.SurfaceHolder.Callback;
import android.view.MotionEvent;
import android.view.KeyEvent;

import android.content.Context;

import android.util.Log;

import android.graphics.Rect;
import android.graphics.Canvas;

import android.app.Service;

#include "generated\MAAPI_consts.h"

public class MoSyncView extends SurfaceView implements SurfaceHolder.Callback
{
	public SurfaceHolder mSurfaceHolder;
	
	private Context mContext;
	private MoSyncThread mMoSyncThread;

	public MoSyncView(Context context, MoSyncThread moSyncThread) throws Exception
	{
		super(context);
		
		Log.i("MoSyncView", "Constructor");
		
		mContext = context;
		mMoSyncThread = moSyncThread;

		// register our interest in hearing about changes to our surface
		mSurfaceHolder = getHolder();
/*		
		// Use a normal buffer.. if there is GPU or Hardware types available they will be used
		mSurfaceHolder.setType(android.view.SurfaceHolder.SURFACE_TYPE_NORMAL);
*/
		// Use accelerated surfaces if available
		int mode = 0;
		try {
			mode = 1;
			mSurfaceHolder.setType(android.view.SurfaceHolder.SURFACE_TYPE_HARDWARE);
		} catch(Exception e) {
			try {
				mode = 2;
				mSurfaceHolder.setType(android.view.SurfaceHolder.SURFACE_TYPE_GPU);
			} catch(Exception e2) {
				mSurfaceHolder.setType(android.view.SurfaceHolder.SURFACE_TYPE_NORMAL);
				// if this didn't work we can do nothing...
			}
		}

		switch(mode)
		{
			case 1: Log.i("MoSync", "Hardware accelerated surface"); break;
			case 2: Log.i("MoSync", "GPU accelerated surface"); break;
			default: Log.i("MoSync", "No hardware acceleration available");
		}

				
		mSurfaceHolder.addCallback(this);    
		
		setVisibility(VISIBLE);
		
		setFocusableInTouchMode(true);
	}

	/*
	* This function is called directly after that a change which affects the structure of the surface has changed
	*/
	public void surfaceChanged(SurfaceHolder holder, int format, int width, int height)
	{
		Log.i("MoSyncView", "surfaceChanged");
		mMoSyncThread.updateSurfaceSize(width, height);
	}

	/*
	* Function which is called directly after the surface has been created
	*/
	public void surfaceCreated(SurfaceHolder holder)
	{
		Log.i("MoSyncView", "surfaceCreated");
		
		if(!mMoSyncThread.isAlive())
		{
			mMoSyncThread.updateSurfaceSize(getWidth(), getHeight());
			mMoSyncThread.initSyscalls();
			mMoSyncThread.start();
		}
		//mMoSyncThread.setMoSyncView(this);
		
		//drawSomething();
	}

	public void drawSomething()
	{
		mMoSyncThread.maSetColor(0xff00ff);
		mMoSyncThread.maLine(0, 0, 43, 432);
		mMoSyncThread.maUpdateScreen();
	}
	
	/*
	* Function that is called directly before the surface is destroyed  
	*/
	public void surfaceDestroyed(SurfaceHolder holder)
	{
		Log.i("MoSyncView", "surfaceDestroyed");
	}

	@Override
	protected void onDraw(Canvas canvas)
	{
		super.onDraw(canvas);
		Log.i("MoSync View","onDraw");
	}

	protected void onFocusChanged(boolean gainFocus, int direction, Rect previouslyFocusedRect)
	{
		Log.i("MoSyncView","onFocusChanged");
	}

/*	
	public int getKeys() {
		return mKeyState;
	}
*/	
	public boolean onTouchEvent(MotionEvent motionEvent)
	{
		Log.i("MoSyncView","onTouchEvent");
		
		int action = motionEvent.getAction();

		int[] event = new int[3];
		event[0] = EVENT_TYPE_POINTER_RELEASED;
		
		event[1] = (int)motionEvent.getRawX();
		event[2] = (int)motionEvent.getRawY();
		
		switch(motionEvent.getAction())
		{
			case 0:
				event[0] = EVENT_TYPE_POINTER_PRESSED;
				break;
			case 1:
				event[0] = EVENT_TYPE_POINTER_RELEASED;
				break;
			case 2:
				event[0] = EVENT_TYPE_POINTER_DRAGGED;
				break;
			default:
				return false;
		}
		mMoSyncThread.nativePostEvent(event);
		
		return true;
	}
/*
	synchronized public final int[] getEvent()
	{	
		if(mEventBuffer.isEmpty())
		{
			return null;
		}
		int[] event = (int[]) mEventBuffer.firstElement();
		mEventBuffer.removeElementAt(0);
		return event;
		
	}
*/	
	synchronized public final void postEvent(int[] event)
	{	
		Log.i("MoSyncView","postEvent\n");
/*		
		mCoreThread.interrupt();
		Log.i("MoSyncView","interrupt returned\n");
		if(!mEventOverflow)
		{
			if(mEventBuffer.size() + 1 == EVENT_BUFFER_SIZE)
			{
				mEventOverflow = true;
				mEventBuffer.removeAllElements();
			}
			mEventBuffer.addElement(event);
		}
*/		
	}

#include "generated\MAAPI_consts.h"
	
	// Defines used to map Android keycodes to MoSync 	
#define DEVICE_KEYS(m) m(0) m(1) m(2) m(3) m(4)	m(5) m(6) m(7) m(8) m(9) m(STAR) m(POUND) m(CLEAR)
#define DEVICE_DPAD_KEYS(m) m(LEFT) m(RIGHT) m(UP) m(DOWN)
#define DEVICE_SPECIAL(m) m(DPAD_CENTER, FIRE) m(SOFT_LEFT, SOFTLEFT) m(SOFT_RIGHT, SOFTRIGHT)

	private final int convertToMoSyncKeyCode(int keyCode)
	{
#define CONVERT_KEYCODE(k) if(keyCode == KeyEvent.KEYCODE_##k) return MAK_##k;
#define CONVERT_DPAD_KEYCODE(k) if(keyCode == KeyEvent.KEYCODE_DPAD_##k) return MAK_##k;
#define CONVERT_SPECIAL(kIn, kOut) if(keyCode == KeyEvent.KEYCODE_##kIn) return MAK_##kOut;
		DEVICE_KEYS(CONVERT_KEYCODE);
		DEVICE_DPAD_KEYS(CONVERT_DPAD_KEYCODE);
		DEVICE_SPECIAL(CONVERT_SPECIAL);
		return 0;
	}
	
	private final int convertToMoSyncKeyByteCode(int keyCode) {
#define CONVERT_KEYCODEB(k) if(keyCode == KeyEvent.KEYCODE_##k) return MAKB_##k;
#define CONVERT_DPAD_KEYCODEB(k) if(keyCode == KeyEvent.KEYCODE_DPAD_##k) return MAKB_##k;
#define CONVERT_SPECIALB(kIn, kOut) if(keyCode == KeyEvent.KEYCODE_##kIn) return MAKB_##kOut;
		DEVICE_KEYS(CONVERT_KEYCODEB);
		DEVICE_DPAD_KEYS(CONVERT_DPAD_KEYCODEB);
		DEVICE_SPECIAL(CONVERT_SPECIALB);
		return 0;
	}
	
	public boolean onKeyUp(int keyCode, KeyEvent keyEvent)
	{
		Log.i("MoSyncView", "key up event :" + keyEvent.toString() + "/n");
/*		
		int convertedKeyCode = convertToMoSyncKeyCode(keyCode);
		Log.i("MoSyncView", "android key :" + keyCode + " - MoSync key :" + convertedKeyCode + "/n");
		
		int[] event = new int[2];
		mKeyState &= ~convertToMoSyncKeyByteCode(keyCode);
		
		EI_TYPE = EVENT_TYPE_KEY_RELEASED;
		EI_KEY = convertedKeyCode;
		postEvent(event);
*/	
		int[] event = new int[3];
		
		event[0] = EVENT_TYPE_KEY_RELEASED;
		event[1] = convertToMoSyncKeyByteCode(keyCode);
		event[2] = keyCode;
	
		mMoSyncThread.nativePostEvent(event);
		return true;
	}
	
	public boolean onKeyDown(int keyCode, KeyEvent keyEvent)
	{
		Log.i("MoSyncView", "key down event :" + keyEvent.toString() + "/n");
/*		
		int convertedKeyCode = convertToMoSyncKeyCode(keyCode);
		Log.i("MoSyncView", "android key :" + keyCode + " - MoSync key :" + convertedKeyCode + "/n");
			
		int[] event = new int[2];
		mKeyState |= convertToMoSyncKeyByteCode(keyCode);
		
		EI_TYPE = EVENT_TYPE_KEY_PRESSED;
		EI_KEY = convertedKeyCode;
		postEvent(event);
*/		
		int[] event = new int[3];
		
		event[0] = EVENT_TYPE_KEY_PRESSED;
		event[1] = convertToMoSyncKeyByteCode(keyCode);
		event[2] = keyCode;
	
		mMoSyncThread.nativePostEvent(event);
		return true;
	}
	
}
