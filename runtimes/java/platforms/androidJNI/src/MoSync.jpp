/* Copyright (C) 2010 MoSync AB

This program is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License, version 2, as published by
the Free Software Foundation.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
for more details.

You should have received a copy of the GNU General Public License
along with this program; see the file COPYING.  If not, write to the Free
Software Foundation, 59 Temple Place - Suite 330, Boston, MA
02111-1307, USA.
*/

package com.mosync.java.android;

import android.app.Activity;
import android.content.Context;
import android.content.Intent;
import android.content.pm.ActivityInfo;
import android.content.res.Configuration;
import android.os.Bundle;
import android.os.Handler;
import android.util.Log;
import android.view.Window;
import android.view.WindowManager;

import java.util.Locale;
import java.util.concurrent.LinkedBlockingQueue;

import com.mosync.internal.android.MoSyncThread;
import com.mosync.internal.android.MoSyncView;
import com.mosync.internal.android.MoSyncWebView;

#include "generated\IX_WIDGET_CONSTS.h"

/**
*
* Main MoSync activity
*
* As long as this activity is running the application is running.
*/
public class MoSync extends Activity
{
	static public MoSyncThread mMoSyncThread;
	MoSyncView mMoSyncView;
	MoSyncWebView mMoSyncWebView;

	Intent mMoSyncServiceIntent;
	
	/**
	 * Handler used to run code on the UI thread.
	 */
	Handler mHandler;
	
	boolean mThreadHasDied = false;
	boolean mIsPaused = false;
	
	/**
	*
	* onCreate
	*
	* Informs the underlying system that a fullscreen windows with no title bar shall be used.
	*
	* Creates and initializes the MoSync thread
	*
	* Calls the createMoSyncView method and then shows the created view
	*
	*/
    @Override
    public void onCreate(Bundle savedInstanceState) {
	
		Log.i("MoSync", "onCreate");
		
		super.onCreate(savedInstanceState);
		
		if(mThreadHasDied) this.finish();
		
        this.requestWindowFeature(Window.FEATURE_NO_TITLE);
        //this.getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN, WindowManager.LayoutParams.FLAG_FULLSCREEN);
	
		mMoSyncView = null;
		mMoSyncWebView = null;
		
		mHandler = new Handler();
		
		try 
		{
			mMoSyncThread = new MoSyncThread(this, mHandler);
		}
		catch(Exception e) 
		{
			Log.e("MoSync", "Unable to create thread! Application is closed!");
			super.onDestroy();
			this.finish();
		}
		
		createMoSyncView();
		
		setContentView(mMoSyncView);
		// TODO: Restore if needed: mMoSyncThread.setMoSyncView(mMoSyncView);
		
    }
	
	/**
	*
	* createMoSyncView 
	* Creates a MoSyncView. If it fails the Activity is destroyed.
	*
	*/
	private void createMoSyncView()
	{
		Log.i("MoSync", "createMoSyncView");
		try 
		{
			mMoSyncView = new MoSyncView(this, mMoSyncThread);
        } 
		catch(Exception e) 
		{
			Log.e("MoSync", "No view was generated.. app could not start!");
			super.onDestroy();
			this.finish();
		}
	}
	
	public MoSyncView getMoSyncView()
	{
		return mMoSyncView;
	}

	/**
	*
	* onConfigurationChanged
	* Handles the new configurations when the screen rotates and/or the keyboard was opened.
	*
	*/
	@Override
	public void onConfigurationChanged(Configuration config)
	{
		super.onConfigurationChanged(config);

		setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_PORTRAIT);
		setContentView(mMoSyncView);
	}
	
	/**
	*
	* onStop
	* 
	*/
    @Override
    protected void onStop()
	{
		super.onStop();
		Log.i("MoSync","onStop");
		
		mThreadHasDied = mMoSyncThread.isDead();
		
		// The view is destroyed, inform the thread about this
		// TODO: Restore if needed.
		/*if(!mThreadHasDied)
			mMoSyncThread.setMoSyncView(null); 
		*/
	}

	@Override
    protected void onRestart()
	{
		super.onRestart();
		Log.i("MoSync","onRestart");
		
		if(mThreadHasDied) this.finish();
		
		// create a new view and inform the thread about this
		createMoSyncView();
	}
	
	@Override
    protected void onResume()
	{
		super.onResume();
		Log.i("MoSync","onResume");
		
		if(mThreadHasDied) this.finish();
		
		// this should be dealt with differently
		//registerReceiver(mBatteryReciever, new IntentFilter(Intent.ACTION_BATTERY_CHANGED)); 
		
		if(mIsPaused == true)
		{
			mIsPaused = false;
			
			//mMoSyncView.postFocusGainedEvent();
			setContentView(mMoSyncView);
			// TODO: Delete this line: mMoSyncThread.setMoSyncView(mMoSyncView);
		}
    }

	@Override
    protected void onPause()
	{
		super.onPause();
		Log.i("MoSync","onPause");
		
		mThreadHasDied = mMoSyncThread.isDead();
			
		//unregisterReceiver(mBatteryReciever);
		
		mIsPaused = true;
  
		//mMoSyncView.postFocusLostEvent();		
    }

	@Override
    protected void onDestroy()
	{
		super.onDestroy();	
    	Log.i("MoSync","onDestroy");
		
		mThreadHasDied = mMoSyncThread.isDead();
		
		//stopService(mMoSyncServiceIntent);
		
		//mMoSyncView.stopThread();
		finish();
		//mMosyncView.killApplication();
    }
	
	public int maWidgetCreate(final int widgetType)
	{
		if (WIDGET_TYPE_WEBVIEW == widgetType)
		{
			// Limited to one instance.
			// TODO: Add lookup table for widgets.
			if (null == mMoSyncWebView)
			{
				final WidgetResult result = new WidgetResult();
				final Context context = this;
				// TODO: Add handle counter, add widget to lookup table.
				final int widgetHandle = 1;
				mHandler.post(new Runnable() 
				{ 
					public void run() 
					{
						mMoSyncWebView = new MoSyncWebView(
							context, 
							mMoSyncThread, 
							widgetHandle);
						Log.i("MoSync.maWidgetCreate", "MoSyncWebView created");
						result.setValue(widgetHandle);
					} 
				});
				
				return result.waitForValue(500);
			}
		}
		
		// We could not create the requested widget.
		return WIDGET_ERROR;
	}
	
	public int maWidgetDestroy(final int widgetHandle)
	{
		// TODO: Find a general way of destroying widgets.
		// We should also make sure the widget is closed,
		// or automatically close the widget.
		if (null != mMoSyncWebView)
		{
			mMoSyncWebView = null;
			return WIDGET_OK;
		}
		
		// We could not open the requested widget.
		return WIDGET_ERROR;
	}
	
	public int maWidgetOpen(final int widgetHandle, final int widgetParentHandle)
	{
		// Open the single WebView in the Activity.
		// TODO: Use widgetHandle to get the widget.
		if (null != mMoSyncWebView && WIDGET_ROOT == widgetParentHandle)
		{
			final WidgetResult result = new WidgetResult();
			final Context context = this;
			mHandler.post(new Runnable() 
			{ 
				public void run() 
				{
					setContentView(mMoSyncWebView);
					mMoSyncWebView.requestFocus();
					
					// Post notification message to MoSync.
					// TODO: Comment out/remove.
					mMoSyncWebView.postEvent(EVENT_TYPE_WIDGET_OPENED, 0);
					
					Log.i("MoSync.maWidgetOpen", "MoSyncWebView opened");
					
					result.setValue(WIDGET_OK);
				} 
			});
			
			return result.waitForValue(1000);
		}
		
		Log.i("MoSync.maWidgetOpen", "WIDGET_ERROR");
					
		// We could not open the requested widget.
		return WIDGET_ERROR;
	}
	
	public int maWidgetClose(final int widgetHandle)
	{
		// TODO: Use widgetHandle to get the widget.
		if (null != mMoSyncWebView)
		{
			mHandler.post(new Runnable() 
			{ 
				public void run() 
				{ 
					mMoSyncWebView.close();
					mMoSyncWebView = null;
					// Restore the MoSyncView.
					setContentView(mMoSyncView); 
				} 
			});
			return WIDGET_OK;
		}
		else
		{
			return WIDGET_ERROR;
		}
	}
	
	public int maWidgetLoadHTML(final int widgetHandle, final String html)
	{
		// TODO: Use widgetHandle to get the widget.
		if (null != mMoSyncWebView)
		{
			mHandler.post(new Runnable() 
			{ 
				public void run() 
				{ 
					mMoSyncWebView.loadHTML(html); 
				} 
			});
			return WIDGET_OK;
		}
		else
		{
			return WIDGET_ERROR;
		}
	}

	public int maWidgetLoadURL(final int widgetHandle, final String url)
	{
		// TODO: Use widgetHandle to get the widget.
		if (null != mMoSyncWebView)
		{
			mHandler.post(new Runnable() 
			{ 
				public void run() 
				{ 
					mMoSyncWebView.loadURL(url); 
				} 
			});
			return WIDGET_OK;
		}
		else
		{
			return WIDGET_ERROR;
		}
	}

	public int maWidgetEvaluateScript(final int widgetHandle, final String script)
	{
		Log.i("maWidgetEvaluateScript", script);
		// TODO: Use widgetHandle to get the widget.
		if (null != mMoSyncWebView)
		{
			mHandler.post(new Runnable() 
			{ 
				public void run() 
				{ 
					mMoSyncWebView.evaluateScript(script); 
					Log.i("maWidgetEvaluateScript", "*** DONE ***");
				} 
			});
			return WIDGET_OK;
		}
		else
		{
			return WIDGET_ERROR;
		}
	}
	
	public int maWidgetGetCommandSize(final int commandId)
	{
		// TODO: Store commands in a lookup table. Use commandId to get command.
		if (null != mMoSyncWebView)
		{
			return mMoSyncWebView.getCommandSize(commandId);
		}
		else
		{
			return WIDGET_ERROR;
		}
	}
	
	public byte[] maWidgetGetCommandBytes(final int commandId)
	{
		// TODO: Store commands in a lookup table. Use commandId to get command.
		if (null != mMoSyncWebView)
		{
			return mMoSyncWebView.getCommandBytes(commandId);
		}
		else
		{
			return null;
		}
	}
	
	private int waitForIntQueueResult(LinkedBlockingQueue<Integer> queue)
	{
		Integer result = null;
		while (null == result)
		{
			try 
			{
				result = queue.take();
			}
			catch (InterruptedException consume)
			{
			}
		}
		return result.intValue();
	}
	
	/**
	 * This is a helper class that sets and waits for an integer value
	 * in a thread safe way. The class is used to communicate results of 
	 * widgets operations in a synchronous way.
	 */
	class WidgetResult
	{
		final LinkedBlockingQueue<Integer> mQueue = new LinkedBlockingQueue<Integer>(1);

		/**
		 * Set the integer value.
		 * @param value The value to set.
		 */
		public void setValue(int value)
		{
			try
			{
				mQueue.put(new Integer(value));
			}
			catch (InterruptedException ex)
			{
				ex.printStackTrace();
			}
		}
		
		/**
		 * Wait for a value.
		 * @param timeOutMillis Max time to wait for the value.
		 * @return On error, returns WIDGET_ERROR.
		 */
		public int waitForValue(int timeOutMillis)
		{
			long timeOut = System.currentTimeMillis() + timeOutMillis;

			Integer result = null;
			while (null == result)
			{
				if (System.currentTimeMillis() >= timeOut)
				{
					return WIDGET_ERROR;
				}
				
				try 
				{
					result = mQueue.take();
				}
				catch (InterruptedException consume)
				{
				}
			}
			return result.intValue();
		}
	}
}
