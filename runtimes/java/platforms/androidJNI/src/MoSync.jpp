/* Copyright (C) 2010 MoSync AB

This program is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License, version 2, as published by
the Free Software Foundation.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
for more details.

You should have received a copy of the GNU General Public License
along with this program; see the file COPYING.  If not, write to the Free
Software Foundation, 59 Temple Place - Suite 330, Boston, MA
02111-1307, USA.
*/

package com.mosync.java.android;

import android.app.Activity;
import android.content.Context;
import android.content.Intent;
import android.content.pm.ActivityInfo;
import android.content.res.Configuration;
import android.os.Bundle;
import android.os.Handler;
import android.util.Log;
import android.view.View;
import android.view.Window;
import android.view.WindowManager;

import java.util.Locale;
import java.util.concurrent.LinkedBlockingQueue;

import com.mosync.internal.android.MoSyncThread;
import com.mosync.internal.android.MoSyncView;
import com.mosync.internal.android.MoSyncWebView;

#include "helpers.h"
#include "generated\IX_WIDGET_CONSTS.h"

/**
*
* Main MoSync activity
*
* As long as this activity is running the application is running.
*/
public class MoSync extends Activity
{
	static public MoSyncThread mMoSyncThread;
	MoSyncView mMoSyncView;

	Intent mMoSyncServiceIntent;
	
	/**
	 * Handler used to run code on the UI thread.
	 */
	Handler mHandler;
	
	boolean mThreadHasDied = false;
	boolean mIsPaused = false;
	
	/**
	*
	* onCreate
	*
	* Informs the underlying system that a fullscreen windows with no title bar shall be used.
	*
	* Creates and initializes the MoSync thread
	*
	* Calls the createMoSyncView method and then shows the created view
	*
	*/
    @Override
    public void onCreate(Bundle savedInstanceState) {
	
		Log.i("MoSync", "onCreate");
		
		super.onCreate(savedInstanceState);
		
		if(mThreadHasDied) this.finish();
		
        this.requestWindowFeature(Window.FEATURE_NO_TITLE);
        //this.getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN, WindowManager.LayoutParams.FLAG_FULLSCREEN);
	
		mMoSyncView = null;
		
		mHandler = new Handler();
		
		try 
		{
			mMoSyncThread = new MoSyncThread(this, mHandler);
		}
		catch(Exception e) 
		{
			Log.e("MoSync", "Unable to create thread! Application is closed!");
			super.onDestroy();
			this.finish();
		}
		
		createMoSyncView();
		
		setContentView(mMoSyncView);
		// TODO: Restore if needed: mMoSyncThread.setMoSyncView(mMoSyncView);
		
    }
	
	/**
	*
	* createMoSyncView 
	* Creates a MoSyncView. If it fails the Activity is destroyed.
	*
	*/
	private void createMoSyncView()
	{
		Log.i("MoSync", "createMoSyncView");
		try 
		{
			mMoSyncView = new MoSyncView(this, mMoSyncThread);
			mMoSyncThread.mWidgetTable.putWidget(WIDGET_MAIN_VIEW, mMoSyncView);
        } 
		catch(Exception e) 
		{
			Log.e("MoSync", "No view was generated.. app could not start!");
			super.onDestroy();
			this.finish();
		}
	}
	
	public MoSyncView getMoSyncView()
	{
		return mMoSyncView;
	}

	/**
	*
	* onConfigurationChanged
	* Handles the new configurations when the screen rotates and/or the keyboard was opened.
	*
	*/
	@Override
	public void onConfigurationChanged(Configuration config)
	{
		super.onConfigurationChanged(config);

		setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_PORTRAIT);
		setContentView(mMoSyncView);
	}
	
	/**
	*
	* onStop
	* 
	*/
    @Override
    protected void onStop()
	{
		super.onStop();
		Log.i("MoSync","onStop");
		
		mThreadHasDied = mMoSyncThread.isDead();
		
		// The view is destroyed, inform the thread about this
		// TODO: Restore if needed.
		/*if(!mThreadHasDied)
			mMoSyncThread.setMoSyncView(null); 
		*/
	}

	@Override
    protected void onRestart()
	{
		super.onRestart();
		Log.i("MoSync","onRestart");
		
		if(mThreadHasDied) this.finish();
		
		// create a new view and inform the thread about this
		createMoSyncView();
		
		// TODO: What do we do if a native widget was open?
		// How do we recreate it? Perhaps add a message to create the UI.
		// Is there already such a message?
	}
	
	@Override
    protected void onResume()
	{
		super.onResume();
		Log.i("MoSync","onResume");
		
		if(mThreadHasDied) this.finish();
		
		// this should be dealt with differently
		//registerReceiver(mBatteryReciever, new IntentFilter(Intent.ACTION_BATTERY_CHANGED)); 
		
		if(mIsPaused == true)
		{
			mIsPaused = false;
			
			//mMoSyncView.postFocusGainedEvent();
			setContentView(mMoSyncView);
			// TODO: Set other widgets here?
			
			// TODO: Delete this line: mMoSyncThread.setMoSyncView(mMoSyncView);
		}
    }

	@Override
    protected void onPause()
	{
		super.onPause();
		Log.i("MoSync","onPause");
		
		mThreadHasDied = mMoSyncThread.isDead();
			
		//unregisterReceiver(mBatteryReciever);
		
		mIsPaused = true;
  
		//mMoSyncView.postFocusLostEvent();		
    }

	@Override
    protected void onDestroy()
	{
		super.onDestroy();	
    	Log.i("MoSync","onDestroy");
		
		mThreadHasDied = mMoSyncThread.isDead();
		
		//stopService(mMoSyncServiceIntent);
		
		//mMoSyncView.stopThread();
		finish();
		//mMosyncView.killApplication();
    }
	
	public int maWidgetCreate(final int widgetType)
	{
		Log.i("MoSync.maWidgetCreate", "widgetType: " + widgetType);
		
		if (WIDGET_TYPE_WEBVIEW == widgetType)
		{
			final WidgetResult result = new WidgetResult();
			final Context context = this;
			mHandler.post(new Runnable() 
			{ 
				public void run() 
				{
					MAHandle widgetHandle = mMoSyncThread.mWidgetTable.getNextHandle();
					MoSyncWebView webView = new MoSyncWebView(
						context, 
						mMoSyncThread, 
						widgetHandle);
					mMoSyncThread.mWidgetTable.putWidget(widgetHandle, webView);
					Log.i("MoSync.maWidgetCreate", "MoSyncWebView created");
					result.setValue(widgetHandle);
				} 
			});
			
			return result.waitForValue(500);
		}
		
		// We could not create the requested widget.
		return WIDGET_ERROR;
	}
	
	public int maWidgetDestroy(final MAHandle widgetHandle)
	{
		Log.i("MoSync.maWidgetDestroy", "widgetHandle: " + widgetHandle);
		
		// TODO: Find a general way of destroying widgets.
		// We should also make sure the widget is closed,
		// or automatically close the widget.
		mMoSyncThread.mWidgetTable.removeWidget(widgetHandle);
		return WIDGET_OK;
	}
	
	public int maWidgetOpen(final MAHandle widgetHandle, final MAHandle widgetParentHandle)
	{
		Log.i("MoSync.maWidgetOpen", "widgetHandle: " + widgetHandle);
		
		// Get the native widget.
		final View nativeWidget = mMoSyncThread.mWidgetTable.getWidget(widgetHandle);
		if (null == nativeWidget)
		{
			return WIDGET_ERROR;
		}
		
		// Open the widget in the content pane of the Activity.
		if (WIDGET_ROOT == widgetParentHandle)
		{
			final WidgetResult result = new WidgetResult();
			final Context context = this;
			mHandler.post(new Runnable() 
			{ 
				public void run() 
				{
					setContentView(nativeWidget);
					nativeWidget.requestFocus();
					
					Log.i("MoSync.maWidgetOpen", "Widget opened 1");
					
					// Post notification message to MoSync.
					postWidgetEvent(EVENT_TYPE_WIDGET_OPENED, widgetHandle, 0);
					
					Log.i("MoSync.maWidgetOpen", "Widget opened 2");
					
					result.setValue(WIDGET_OK);
					
					Log.i("MoSync.maWidgetOpen", "Widget opened 3");
				} 
			});
			
			Log.i("MoSync.maWidgetOpen", "waitForValue");
					
			return result.waitForValue(1000);
		}
		
		Log.i("MoSync.maWidgetOpen", "WIDGET_ERROR");
					
		// We could not open the requested widget.
		return WIDGET_ERROR;
	}
	
	public int maWidgetClose(final MAHandle widgetHandle)
	{
		Log.i("MoSync.maWidgetClose", "widgetHandle: " + widgetHandle);
		
		// Get the native widget.
		final View nativeWidget = mMoSyncThread.mWidgetTable.getWidget(widgetHandle);
		if (null == nativeWidget)
		{
			return WIDGET_ERROR;
		}
		
		final WidgetResult result = new WidgetResult();
		final Context context = this;
		mHandler.post(new Runnable() 
		{ 
			public void run() 
			{
				// TODO: Need to check if there is a parent view. If so, close
				// this view, and do not restore the MoSyncView.
				setContentView(mMoSyncView); // Restore the MoSyncView.
		
				// Post notification message to MoSync.
				postWidgetEvent(EVENT_TYPE_WIDGET_CLOSED, widgetHandle, 0);
	
				Log.i("MoSync.maWidgetOpen", "Widget closed");
				
				result.setValue(WIDGET_OK);
			} 
		});
		
		return result.waitForValue(1000);
	}
	
	public int maWidgetLoadHTML(final MAHandle widgetHandle, final String html)
	{
		Log.i("MoSync.maWidgetLoadHTML", html);
		
		// Get the native widget.
		final View nativeWidget = mMoSyncThread.mWidgetTable.getWidget(widgetHandle);
		if (null == nativeWidget)
		{
			return WIDGET_ERROR;
		}
		
		if (!(nativeWidget instanceof MoSyncWebView))
		{
			return WIDGET_ERROR;
		}
		
		final MoSyncWebView webView = (MoSyncWebView) nativeWidget;
		mHandler.post(new Runnable() 
		{ 
			public void run() 
			{
				webView.loadHTML(html); 
			} 
		});
		
		return WIDGET_OK;
	}

	public int maWidgetLoadURL(final MAHandle widgetHandle, final String url)
	{
		Log.i("MoSync.maWidgetLoadURL", url);
		
		// Get the native widget.
		final View nativeWidget = mMoSyncThread.mWidgetTable.getWidget(widgetHandle);
		if (null == nativeWidget)
		{
			return WIDGET_ERROR;
		}
		
		if (!(nativeWidget instanceof MoSyncWebView))
		{
			return WIDGET_ERROR;
		}
		
		final MoSyncWebView webView = (MoSyncWebView) nativeWidget;
		mHandler.post(new Runnable() 
		{ 
			public void run() 
			{
				webView.loadURL(url);
			} 
		});
		
		return WIDGET_OK;
	}

	public int maWidgetEvaluateScript(final MAHandle widgetHandle, final String script)
	{
		Log.i("MoSync.maWidgetEvaluateScript", script);
		
		// Get the native widget.
		final View nativeWidget = mMoSyncThread.mWidgetTable.getWidget(widgetHandle);
		if (null == nativeWidget)
		{
			return WIDGET_ERROR;
		}
		
		if (!(nativeWidget instanceof MoSyncWebView))
		{
			return WIDGET_ERROR;
		}
		
		final MoSyncWebView webView = (MoSyncWebView) nativeWidget;
		mHandler.post(new Runnable() 
		{ 
			public void run() 
			{
				webView.evaluateScript(script);
			} 
		});
		
		return WIDGET_OK;
	}
	
	/**
	 * Post a widget event to the MoSync event queue.
	 * The event data is organised as an array of ints.
	 * The first element is the type of the event.
	 */
	public void postWidgetEvent(int eventType, MAHandle widgetHandle, int messageId)
	{
		//Log.i("MoSyncWebView", "postWidgetEvent: " + event[0]);
		
		int[] event = new int[3];
		event[0] = eventType;
		event[1] = widgetHandle;
		event[2] = messageId;
		
		mMoSyncThread.nativePostEvent(event);
		mMoSyncThread.interrupt();
	}
	
	/**
	 * This is a helper class that sets and waits for an integer value
	 * in a thread safe way. The class is used to communicate results of 
	 * widgets operations in a synchronous way.
	 */
	class WidgetResult
	{
		final LinkedBlockingQueue<Integer> mQueue = new LinkedBlockingQueue<Integer>(1);

		/**
		 * Set the integer value.
		 * @param value The value to set.
		 */
		public void setValue(int value)
		{
			try
			{
				mQueue.put(new Integer(value));
			}
			catch (InterruptedException ex)
			{
				ex.printStackTrace();
			}
		}
		
		/**
		 * Wait for a value.
		 * @param timeOutMillis Max time to wait for the value.
		 * @return On error, returns WIDGET_ERROR.
		 */
		public int waitForValue(int timeOutMillis)
		{
			long timeOut = System.currentTimeMillis() + timeOutMillis;

			Integer result = null;
			while (null == result)
			{
				if (System.currentTimeMillis() >= timeOut)
				{
					
					Log.i("MoSync.WidgetResult", "WIDGET_ERROR");
					return WIDGET_ERROR;
				}
				
				try 
				{
					result = mQueue.take();
					Log.i("MoSync.WidgetResult", "mQueue.take result: " + result);
				}
				catch (InterruptedException consume)
				{
				}
			}
			return result.intValue();
		}
	}
}
