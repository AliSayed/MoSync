/* Copyright (C) 2010 MoSync AB

This program is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License, version 2, as published by
the Free Software Foundation.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
for more details.

You should have received a copy of the GNU General Public License
along with this program; see the file COPYING.  If not, write to the Free
Software Foundation, 59 Temple Place - Suite 330, Boston, MA
02111-1307, USA.
*/

final static int REQUEST_ENABLE_BT = 2;
static BluetoothAdapter mBluetoothAdapter = null;
//static boolean mBluetoothGetNames = false;

/**
 * Thread that runs the discovery process.
 */
BluetoothDeviceDiscoveryThread mBluetoothDeviceDiscoveryThread = null;

/**
 * List that holds discovered Bluetooth devices.
 */
ConcurrentLinkedQueue<BluetoothDevice> mBluetoothDevices = new ConcurrentLinkedQueue<BluetoothDevice>();

/**
 * Start discovery of Bluetooth devices.
 * Parameter "names" is not used on Android.
 */
int maBtStartDeviceDiscovery(int names) throws Exception
{
	if (null == mBluetoothDeviceDiscoveryThread)
	{
		// This is where devices will be saved for retrieval.
		mBluetoothDevices = new ConcurrentLinkedQueue<BluetoothDevice>();
		
		// Create and start device discovery thread.
		mBluetoothDeviceDiscoveryThread = new BluetoothDeviceDiscoveryThread();
		mBluetoothDeviceDiscoveryThread.start();
		
		return 0; // Zero means success.
	}
	else
	{
		return -1; // Error.
	}
}

/**
 * Returns actual length of device name, -1 on error.
 */
int maBtGetNewDevice(
	Address nameBufPointer,
	int nameBufSize,
	Address actualNameLengthPointer,
	Address addressPointer)
{
	ConcurrentLinkedQueue<BluetoothDevice> deviceList = mBluetoothDevices;
	
	if (null == deviceList)
	{
		return -1; // Error.
	}
	
	// Get and remove head element of the queue.
	// Why do we need to cast here?
	BluetoothDevice device = (BluetoothDevice) deviceList.poll();
	if (null == device)
	{
		return 0; // No more elements.
	}
	
	// Get device name.
	String name = device.getName();
	if (null == name)
	{
		// Name that is unsed if there is no name.
		name = "Unknown Device";
	}
	
	// Get length of name.
	int nameLength = name.length();
	
	// Can the buffer hold the name? (Take null termination char into account.)
	if (nameLength >= nameBufSize - 1)
	{
		// Truncate name if too long.
		name = name.substring(nameBufSize - 1);
	}
	
	// Copy name to memory buffer.
	mMemDataSection.mark();
	mMemDataSection.position(nameBufPointer);
	mMemDataSection.put(name.getBytes());
	mMemDataSection.put((byte)0); // Terminating null char.
	mMemDataSection.reset();
	
	// Copy actual length to memory buffer.
	mMemDataSection.mark();
	mMemDataSection.position(actualNameLengthPointer);
	ByteOrder oldOrder = mMemDataSection.order();
	mMemDataSection.order(ByteOrder.LITTLE_ENDIAN);
	mMemDataSection.asIntBuffer().put(nameLength);
	mMemDataSection.order(oldOrder);
	mMemDataSection.reset();
	
	// Copy device hardware address to memory buffer.
	byte addr1 = 0; // I made up zero as default value.
	byte addr2 = 0;
	byte addr3 = 0;
	byte addr4 = 0;
	byte addr5 = 0;
	byte addr6 = 0;
	String address = device.getAddress();
	// Format of address string is "00:11:22:AA:BB:CC", should be 17 characters.
	if (17 == address.length())
	{
		addr1 = (byte) Integer.parseInt(address.substring(0, 2), 16);
		addr2 = (byte) Integer.parseInt(address.substring(3, 5), 16);
		addr3 = (byte) Integer.parseInt(address.substring(6, 8), 16);
		addr4 = (byte) Integer.parseInt(address.substring(9, 11), 16);
		addr5 = (byte) Integer.parseInt(address.substring(12, 14), 16);
		addr6 = (byte) Integer.parseInt(address.substring(15, 17), 16);
	}
	mMemDataSection.mark();
	mMemDataSection.position(addressPointer);
	mMemDataSection.put(addr1);
	mMemDataSection.put(addr2);
	mMemDataSection.put(addr3);
	mMemDataSection.put(addr4);
	mMemDataSection.put(addr5);
	mMemDataSection.put(addr6);
	mMemDataSection.reset();
	
	return 1; // Success retrieving device info.
}

int maBtStartServiceDiscovery(Address dev, Address uuid) throws Exception
{
	/* FIX-ME */
	return -1;
}

int maBtGetNewService(Address dst) throws Exception
{
	/* FIX-ME */
	return -1;
}

int maBtGetNextServiceSize(Address dst) throws Exception
{
	/* FIX-ME */
	return -1;
}

int maBtCancelDiscovery() throws Exception
{
	// Cancel Android Bluetooth discovery.
	if (mBluetoothAdapter.isDiscovering()) 
	{
		mBluetoothAdapter.cancelDiscovery();
	}
	
	if (null != mBluetoothDeviceDiscoveryThread)
	{
		if (mBluetoothDeviceDiscoveryThread.isAlive())
		{
			// Device discovery thread is running, terminate it.
			mBluetoothDeviceDiscoveryThread.cancelDeviceDiscovery();
			
			return 1; // These was an active operation
		}
	}
	
	// TODO: Add cancel of service discovery.
	
	return 0; // No active operation.
}

/**
 * Thread that performs discovery of Bluetooth devices.
 */
class BluetoothDeviceDiscoveryThread extends Thread
{
	Looper mLooper;
	BroadcastReceiver mBluetoothReciever;

	public BluetoothDeviceDiscoveryThread()
	{
	}

	public void run()
	{
		try
		{
			Looper.prepare();
			mLooper = Looper.myLooper();
			initiateDeviceDiscovery();
			Looper.loop();
		}
		catch (Throwable e)
		{
			Log.i("BluetoothDeviceDiscoveryThread", "Error: " + e);
			e.printStackTrace();
			mContext.unregisterReceiver(mBluetoothReciever);
		}
	}
	
	int initiateDeviceDiscovery()
	{
		// if (0 != names) mBluetoothGetNames = true;
		
		Log.i("****** BluetoothDeviceDiscoveryThread.initiateDeviceDiscovery", "begin");
		
		if (null == mBluetoothAdapter)
		{
			mBluetoothAdapter = BluetoothAdapter.getDefaultAdapter();
			if (null == mBluetoothAdapter)
			{
				Log.i("****** BluetoothDeviceDiscoveryThread.initiateDeviceDiscovery", "NO DEFAULT ADAPTER AVAILABLE!");
				return -1;
			}
		}

		// If not enabled, open an activity for the user to enable Bluetooth.
		// TODO: Fix this code.
		if (!mBluetoothAdapter.isEnabled())
		{
			Log.i("****** BluetoothDeviceDiscoveryThread.initiateDeviceDiscovery", "!mBluetoothAdapter.isEnabled()");
		
			// Open the activity.
			Intent btPermissionIntent = new Intent(BluetoothAdapter.ACTION_REQUEST_ENABLE);
			((Activity) mContext).startActivityForResult(btPermissionIntent, REQUEST_ENABLE_BT);
			
			// Register receiver for Bluetooth state changes.
			mContext.registerReceiver(new BroadcastReceiver()
			{
				@Override
				public void onReceive(Context context, Intent i)
				{		
					int newState = i.getIntExtra(BluetoothAdapter.EXTRA_STATE, BluetoothAdapter.STATE_OFF);
					if (newState == BluetoothAdapter.STATE_ON)
					{
						// Bluetooth is now enabled, start discovery.
						context.unregisterReceiver(this); // Finished using this listener.
						startDeviceDiscovery();
					}
				}
			}, new IntentFilter(BluetoothAdapter.ACTION_STATE_CHANGED));
			
			// Do not call explictly: mBluetoothAdapter.enable();
		}
		else
		{
			// Start discovery.
			startDeviceDiscovery();
		}
		
		Log.i("****** BluetoothDeviceDiscoveryThread.initiateDeviceDiscovery", "end");
		
		return 0;
	}
	
	void startDeviceDiscovery()
	{
		// Create device listener.
		mBluetoothReciever = new BroadcastReceiver()
		{
			@Override
			public void onReceive(Context context, Intent intent)
			{		
				final String action = intent.getAction();
				
				Log.i("BluetoothDeviceDiscoveryThread.startDeviceDiscovery", "******** intent action = " + action);
				
				if (action.equals(BluetoothDevice.ACTION_FOUND))
				{
					Log.i("BluetoothDeviceDiscoveryThread.startDeviceDiscovery", "****** x Found device!");
					
					// Add found device to list of devices.
					BluetoothDevice device = intent.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE);
					deviceFound(device);
					
					//BluetoothDevice rbd = (BluetoothDevice) intent.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE);
					//int rssi = intent.getIntExtra(BluetoothDevice.EXTRA_RSSI, Integer.MIN_VALUE);
					//RemoteDevice2Impl tobounce = new RemoteDevice2Impl(rbd, rssi);
					//scanListener.deviceFound(tobounce);
				}
				else if (action.equals(BluetoothAdapter.ACTION_DISCOVERY_FINISHED))
				{
					Log.i("BluetoothDeviceDiscoveryThread.startDeviceDiscovery", "***************** Scan complete!");
					deviceDiscoveryFinished();
					stopDeviceDiscovery();
					//scanListener.scanCompleted();
				}
			}
		};
		
		// Register receiver.
		// TODO: When should we unregister?
		//   on BluetoothAdapter.ACTION_DISCOVERY_FINISHED
		//   on abort (maBtCancelDiscovery)
		//   on error
		IntentFilter filter = new IntentFilter();
		filter.addAction(BluetoothDevice.ACTION_FOUND);
		filter.addAction(BluetoothAdapter.ACTION_DISCOVERY_FINISHED);
		mContext.registerReceiver(mBluetoothReciever, filter);
		
		// Cancel any ongoing discovery on the Android level.
		if (mBluetoothAdapter.isDiscovering()) 
		{
			mBluetoothAdapter.cancelDiscovery();
		}
		
		// Start discovery on the Android level.
		mBluetoothAdapter.startDiscovery();
	}
	
	void stopDeviceDiscovery()
	{
		mLooper.quit();
		mContext.unregisterReceiver(mBluetoothReciever);
		mBluetoothDeviceDiscoveryThread = null;
	}
	
	void cancelDeviceDiscovery()
	{
		deviceDiscoveryCanceled();
		stopDeviceDiscovery();
	}
	
	void deviceFound(BluetoothDevice device)
	{
		ConcurrentLinkedQueue<BluetoothDevice> deviceList = mBluetoothDevices;
		if (null != deviceList)
		{
			mBluetoothDevices.add(device);
			postBluetoothMessage(0); // State zero means "still working"
		}
	}
	
	void deviceDiscoveryFinished()
	{
		ConcurrentLinkedQueue<BluetoothDevice> deviceList = mBluetoothDevices;
		if (null != deviceList)
		{
			postBluetoothMessage(deviceList.size() + 1); // State is number of devices found + 1
		}
	}
	
	void deviceDiscoveryCanceled()
	{
		ConcurrentLinkedQueue<BluetoothDevice> deviceList = mBluetoothDevices;
		if (null != deviceList)
		{
			// Might be a good idea to make sure queue is empty if
			// there is some other reference to it.
			while (null != deviceList.poll()) { }
		}
		mBluetoothDevices = null;
		postBluetoothMessage(CONNERR_CANCELED); 
	}
	
	void postBluetoothMessage(int state)
	{
		Log.i("BluetoothDeviceDiscoveryThread.postBluetoothMessage", "state = " + state);
		int[] event = new int[2];
		event[0] = EVENT_TYPE_BT;
		event[1] = state;
		postEvent(event);
	}
}

