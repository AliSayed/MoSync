/* Copyright (C) 2010 MoSync AB

This program is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License, version 2, as published by
the Free Software Foundation.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
for more details.

You should have received a copy of the GNU General Public License
along with this program; see the file COPYING.  If not, write to the Free
Software Foundation, 59 Temple Place - Suite 330, Boston, MA
02111-1307, USA.
*/


// 00001101-0000-1000-8000-00805F9B34FB
// 00001101-0000-1000-8000-00805F9B34FB
// http://stackoverflow.com/questions/3397071/android-bluetooth-service-discovery-failed-exception

/*
I got it working, the problem was that I needed to pair with the
device first (for some reason it kept an incorrect PIN and wouldn't
pair). Here is a snippet
BluetoothDevice device;
BluetoothSocket tmpsock = null;
int port = 1;
...
try
{
Method m = device.getClass().getMethod("createRfcommSocket", new
Class[] { int.class });
tmpsock = (BluetoothSocket)m.invoke(device, port);
Log.d(TAG, "CONNECTING...");
tmpsock.connect();
...
}
catch (Exception e)
{
Log.e(TAG, "Failed to connect", e);
...
}
*/

final static int REQUEST_ENABLE_BT = 2;

//static boolean mBluetoothGetNames = false;

/**
 * Reference to the Bluetooth adapter.
 */
BluetoothAdapter mBluetoothAdapter = null;

/**
 * Thread that runs the discovery process.
 */
BluetoothDeviceDiscoveryThread mBluetoothDeviceDiscoveryThread = null;

/**
 * List that holds discovered Bluetooth devices.
 */
ConcurrentLinkedQueue<BluetoothDevice> mBluetoothDevices = new ConcurrentLinkedQueue<BluetoothDevice>();

/**
 * Flag that tells us whether the device scan was canceled or not.
 */
AtomicBoolean mDeviceDiscoveryAborted = new AtomicBoolean();

/**
 * Start discovery of Bluetooth devices.
 * Parameter "names" is not used on Android.
 */
int maBtStartDeviceDiscovery(int names) throws Exception
{
	if (null == mBluetoothDeviceDiscoveryThread)
	{
		// The discovery is not aborted (yet).
		mDeviceDiscoveryAborted.set(false);
		
		// List where devices are saved for retrieval.
		mBluetoothDevices = new ConcurrentLinkedQueue<BluetoothDevice>();
		
		// Create and start device discovery thread.
		mBluetoothDeviceDiscoveryThread = new BluetoothDeviceDiscoveryThread();
		mBluetoothDeviceDiscoveryThread.start();
		
		return 0; // Zero means success.
	}
	else
	{
		return -1; // Error.
	}
}

/**
 * Returns actual length of device name, -1 on error.
 */
int maBtGetNewDevice(
	Address nameBufPointer,
	int nameBufSize,
	Address actualNameLengthPointer,
	Address addressPointer)
{
	ConcurrentLinkedQueue<BluetoothDevice> deviceList = mBluetoothDevices;
	
	if (mDeviceDiscoveryAborted.get())
	{
		return -1; // Error.
	}
	
	if (null == deviceList)
	{
		return -1; // Error.
	}
	
	// Get and remove head element of the queue.
	// Why do we need to cast here?
	BluetoothDevice device = (BluetoothDevice) deviceList.poll();
	if (null == device)
	{
		return 0; // No more elements.
	}
	
	// Get device name.
	String name = device.getName();
	if (null == name)
	{
		// Name that is unsed if there is no name.
		name = "Unknown Device";
	}
	
	// Get length of name.
	int nameLength = name.length();
	
	// Can the buffer hold the name? (Take null termination char into account.)
	if (nameLength >= nameBufSize - 1)
	{
		// Truncate name if too long.
		name = name.substring(nameBufSize - 1);
	}
	
	// Copy name to memory buffer.
	mMemDataSection.mark();
	mMemDataSection.position(nameBufPointer);
	mMemDataSection.put(name.getBytes());
	mMemDataSection.put((byte)0); // Terminating null char.
	mMemDataSection.reset();
	
	// Copy actual length to memory buffer.
	mMemDataSection.mark();
	mMemDataSection.position(actualNameLengthPointer);
	ByteOrder oldOrder = mMemDataSection.order();
	mMemDataSection.order(ByteOrder.LITTLE_ENDIAN);
	mMemDataSection.asIntBuffer().put(nameLength);
	mMemDataSection.order(oldOrder);
	mMemDataSection.reset();
	
	// Copy device hardware address to memory buffer.
	byte addr1 = 0; // I made up zero as default value.
	byte addr2 = 0;
	byte addr3 = 0;
	byte addr4 = 0;
	byte addr5 = 0;
	byte addr6 = 0;
	String address = device.getAddress();
	// Format of address string is "00:11:22:AA:BB:CC", should be 17 characters.
	if (17 == address.length())
	{
		addr1 = (byte) Integer.parseInt(address.substring(0, 2), 16);
		addr2 = (byte) Integer.parseInt(address.substring(3, 5), 16);
		addr3 = (byte) Integer.parseInt(address.substring(6, 8), 16);
		addr4 = (byte) Integer.parseInt(address.substring(9, 11), 16);
		addr5 = (byte) Integer.parseInt(address.substring(12, 14), 16);
		addr6 = (byte) Integer.parseInt(address.substring(15, 17), 16);
	}
	mMemDataSection.mark();
	mMemDataSection.position(addressPointer);
	mMemDataSection.put(addr1);
	mMemDataSection.put(addr2);
	mMemDataSection.put(addr3);
	mMemDataSection.put(addr4);
	mMemDataSection.put(addr5);
	mMemDataSection.put(addr6);
	mMemDataSection.reset();
	
	return 1; // Success retrieving device info.
}

int maBtStartServiceDiscovery(Address dev, Address uuid) throws Exception
{
	/* FIX-ME */
	return -1;
}

int maBtGetNewService(Address dst) throws Exception
{
	/* FIX-ME */
	return -1;
}

int maBtGetNextServiceSize(Address dst) throws Exception
{
	/* FIX-ME */
	return -1;
}

int maBtCancelDiscovery() throws Exception
{
	// Is there an device discovery thread?
	if (null != mBluetoothDeviceDiscoveryThread)
	{
		Log.i("maBtCancelDiscovery", "************* ONE");
		
		// Set aborted flag.
		mDeviceDiscoveryAborted.set(true);
		
		// Cancel Android Bluetooth discovery. This will send an
		// event with action "BluetoothAdapter.ACTION_DISCOVERY_FINISHED".
		// There we trap the aborted flag, do cleanup, and send canceled MoSync 
		// event rather than a discovery finished event.
		if (mBluetoothAdapter.isDiscovering()) 
		{
			Log.i("maBtCancelDiscovery", "************* TWO");
			mBluetoothAdapter.cancelDiscovery();
			return 1;
		}
	
	/*
		if (mBluetoothDeviceDiscoveryThread.isAlive())
		{
			Log.i("maBtCancelDiscovery", "************* THREE");
			// Device discovery thread is running, terminate it.
			mBluetoothDeviceDiscoveryThread.cancelDeviceDiscovery();
			
			return 1; // These was an active operation
		}
	*/
	}
	
	// TODO: Add cancel of service discovery.
	
	return 0; // No active operation.
}

// E/BluetoothService.cpp( 1285): stopDiscoveryNative: D-Bus error in StopDiscovery: org.bluez.Error.Failed (Invalid discovery session)

/**
 * Thread that performs discovery of Bluetooth devices.
 */
class BluetoothDeviceDiscoveryThread extends Thread
{
	Looper mLooper;
	BroadcastReceiver mBluetoothReciever;

	public BluetoothDeviceDiscoveryThread()
	{
	}

	public void run()
	{
		try
		{
			Looper.prepare();
			mLooper = Looper.myLooper();
			initiateDeviceDiscovery();
			Log.i("@@@@@@@@@@@@ run", "******** ONE");
			Looper.loop();
			Log.i("@@@@@@@@@@@@ run", "******** TWO");
		}
		catch (Throwable e)
		{
			Log.i("BluetoothDeviceDiscoveryThread", "Error: " + e);
			e.printStackTrace();
			mContext.unregisterReceiver(mBluetoothReciever);
		}
		
		Log.i("@@@@@@@@@@@@ run", "******** THREE");
	}
	
	int initiateDeviceDiscovery()
	{
		// if (0 != names) mBluetoothGetNames = true;
		
		Log.i("****** BluetoothDeviceDiscoveryThread.initiateDeviceDiscovery", "begin");
		
		if (null == mBluetoothAdapter)
		{
			mBluetoothAdapter = BluetoothAdapter.getDefaultAdapter();
			if (null == mBluetoothAdapter)
			{
				Log.i("****** BluetoothDeviceDiscoveryThread.initiateDeviceDiscovery", "NO DEFAULT ADAPTER AVAILABLE!");
				return -1;
			}
		}

		// If not enabled, open an activity for the user to enable Bluetooth.
		// TODO: Test this code.
		if (!mBluetoothAdapter.isEnabled())
		{
			Log.i("****** BluetoothDeviceDiscoveryThread.initiateDeviceDiscovery", "!mBluetoothAdapter.isEnabled()");
		
			// Open the activity.
			Intent btPermissionIntent = new Intent(BluetoothAdapter.ACTION_REQUEST_ENABLE);
			((Activity) mContext).startActivityForResult(btPermissionIntent, REQUEST_ENABLE_BT);
			
			// Register receiver for Bluetooth state changes.
			mContext.registerReceiver(new BroadcastReceiver()
			{
				@Override
				public void onReceive(Context context, Intent i)
				{		
					int newState = i.getIntExtra(BluetoothAdapter.EXTRA_STATE, BluetoothAdapter.STATE_OFF);
					if (newState == BluetoothAdapter.STATE_ON)
					{
						// Bluetooth is now enabled, start discovery.
						context.unregisterReceiver(this); // Finished using this listener.
						startDeviceDiscovery();
					}
				}
			}, new IntentFilter(BluetoothAdapter.ACTION_STATE_CHANGED));
			
			// Do not call explictly: mBluetoothAdapter.enable();
		}
		else
		{
			// Start discovery.
			startDeviceDiscovery();
		}
		
		Log.i("****** BluetoothDeviceDiscoveryThread.initiateDeviceDiscovery", "end");
		
		return 0;
	}
	
	void startDeviceDiscovery()
	{
		// Cancel any ongoing discovery on the Android level.
		if (mBluetoothAdapter.isDiscovering()) 
		{
			mBluetoothAdapter.cancelDiscovery();
		}
		
		// Create device listener.
		mBluetoothReciever = new BroadcastReceiver()
		{
			@Override
			public void onReceive(Context context, Intent intent)
			{		
				final String action = intent.getAction();
				
				Log.i("BluetoothDeviceDiscoveryThread.startDeviceDiscovery", "******** intent action = " + action);
				
				if (action.equals(BluetoothDevice.ACTION_FOUND))
				{
					Log.i("BluetoothDeviceDiscoveryThread.startDeviceDiscovery", "****** x Found device!");
					
					// Add found device to list of devices.
					BluetoothDevice device = intent.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE);
					deviceFound(device);
					
					//BluetoothDevice rbd = (BluetoothDevice) intent.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE);
					//int rssi = intent.getIntExtra(BluetoothDevice.EXTRA_RSSI, Integer.MIN_VALUE);
					//RemoteDevice2Impl tobounce = new RemoteDevice2Impl(rbd, rssi);
					//scanListener.deviceFound(tobounce);
				}
				else if (action.equals(BluetoothAdapter.ACTION_DISCOVERY_FINISHED))
				{					
					if (mDeviceDiscoveryAborted.get())
					{
						Log.i("BluetoothDeviceDiscoveryThread.startDeviceDiscovery", "@@@@@@@@@@@@@@@@@ ACTION_DISCOVERY_FINISHED - SCAN ABORTED");

						// Scan was canceled, report Bluetooth event with state CONNERR_CANCELED.
						deviceDiscoveryCanceled();
						
						// Stop discovery thread and cleanup.
						stopDeviceDiscovery();
					}
					else
					{
						Log.i("BluetoothDeviceDiscoveryThread.startDeviceDiscovery", "***************** ACTION_DISCOVERY_FINISHED - SCAN FINISHED");
						
						// Scan is successfully finished, report Bluetooth with result.
						deviceDiscoveryFinished();
						
						// Stop discovery thread and cleanup.
						stopDeviceDiscovery();
						
						//scanListener.scanCompleted();
					}
				}
			}
		};
		
		// Register receiver.
		// Unregister
		//   on BluetoothAdapter.ACTION_DISCOVERY_FINISHED
		//   on abort (maBtCancelDiscovery)
		//   on error (in catch clause)
		IntentFilter filter = new IntentFilter();
		filter.addAction(BluetoothDevice.ACTION_FOUND);
		filter.addAction(BluetoothAdapter.ACTION_DISCOVERY_FINISHED);
		mContext.registerReceiver(mBluetoothReciever, filter);
		
		// Start discovery on the Android level.
		mBluetoothAdapter.startDiscovery();
	}
	
	void stopDeviceDiscovery()
	{
		Log.i("stopDeviceDiscovery", "******** ONE");
		
		// Quit the thread and set thread variable to null.
		mContext.unregisterReceiver(mBluetoothReciever);
		mLooper.quit();
		mBluetoothDeviceDiscoveryThread = null;
		
		Log.i("stopDeviceDiscovery", "******** TWO");
	}
	
	void cancelDeviceDiscovery()
	{
		deviceDiscoveryCanceled();
		stopDeviceDiscovery();
	}
	
	void deviceFound(BluetoothDevice device)
	{
		// Add device to list.
		ConcurrentLinkedQueue<BluetoothDevice> deviceList = mBluetoothDevices;
		if (null != deviceList)
		{
			mBluetoothDevices.add(device);
			postBluetoothMessage(0); // State zero means "still working"
		}
	}
	
	void deviceDiscoveryFinished()
	{
		// Post event with number of devices found + 1.
		ConcurrentLinkedQueue<BluetoothDevice> deviceList = mBluetoothDevices;
		if (null != deviceList)
		{
			postBluetoothMessage(deviceList.size() + 1); // State is number of devices found + 1
		}
	}
	
	void deviceDiscoveryCanceled()
	{
		// Empty device list and set to null.
		ConcurrentLinkedQueue<BluetoothDevice> deviceList = mBluetoothDevices;
		if (null != deviceList)
		{
			// Might be a good idea to make sure queue is empty if
			// there is some other reference to it.
			while (null != deviceList.poll()) { }
		}
		mBluetoothDevices = null;
		
		// Post cancel event.
		postBluetoothMessage(CONNERR_CANCELED); 
	}
	
	void postBluetoothMessage(int state)
	{
		Log.i("BluetoothDeviceDiscoveryThread.postBluetoothMessage", "state = " + state);
		int[] event = new int[2];
		event[0] = EVENT_TYPE_BT;
		event[1] = state;
		postEvent(event);
	}
}

