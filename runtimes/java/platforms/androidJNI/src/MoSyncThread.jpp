/* Copyright (C) 2010 MoSync AB

This program is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License, version 2, as published by
the Free Software Foundation.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
for more details.

You should have received a copy of the GNU General Public License
along with this program; see the file COPYING.  If not, write to the Free
Software Foundation, 59 Temple Place - Suite 330, Boston, MA
02111-1307, USA.
*/

package com.mosync.java.android;

import java.nio.ByteBuffer;
import java.nio.channels.Channels;
import java.nio.channels.FileChannel;
import java.nio.channels.ReadableByteChannel;

import java.io.InputStream;
import java.io.File;
import java.io.FileOutputStream;

import android.content.Context;
import android.os.Handler;

import android.graphics.Canvas;
import android.graphics.Bitmap;
import android.graphics.Paint;
import android.graphics.Region;
import android.graphics.BitmapFactory;
import android.graphics.Rect;
import android.graphics.Matrix;

import java.util.Date;
import java.util.TimeZone;
import java.util.Hashtable;

import android.util.Log;

class MoSyncThread extends Thread
{
	private Context mContext;
	private Handler mHandler;
	private MoSyncView mMoSyncView;
	
	public MoSyncThread(Context context, Handler handler) throws Exception
	{	
		mContext = context;
		mHandler = handler;
	
		Log.i("MoSync Thread", "Constructor");

		nativeInitRuntime();	
		//initSyscalls();
	}
	
	public void setMoSyncView(MoSyncView moSyncView)
	{
		mMoSyncView = moSyncView;
	}
	
	public void updateSurfaceSize(int width, int height)
	{
		Log.i("MoSync Thread","updateSurfaceSize");		
		//mCore.resizeScreen(mWidth, mHeight);

		mWidth = width;
		mHeight = height;
		
		Bitmap bitmap = Bitmap.createBitmap(mWidth, mHeight, Bitmap.Config.ARGB_8888);
		Canvas canvas = new Canvas(bitmap);
		mDrawTargetScreen = new ImageCache(canvas, bitmap);
		
		mCanvas = mDrawTargetScreen.mCanvas;
		mBitmap = mDrawTargetScreen.mBitmap;
		
		Log.i("MoSync Thread","input width:" + width + " height:" + height);
		Log.i("MoSync Thread","mBitmap width:" + mBitmap.getWidth() + " height:" + mBitmap.getHeight());
	}

	public ByteBuffer generateDataSection(int size)
	{
		try
		{
			Log.i("MoSyncThread","generate data section");
			mMemDataSection = ByteBuffer.allocateDirect(size);
			Log.i("MoSyncThread","generate data section - SUCCESS");
		}
		catch(Exception e)
		{
			Log.i("MoSyncThread", "Out of Memory!");
		}
		return mMemDataSection;
	}

	public void waitThread()
	{
		Log.i("MoSyncThread","waitThread");
		try
		{
			sleep(1000);
		}
		catch(Exception e)
		{
			Log.i("MoSyncThread","sleep exception:" + e.toString());
		}
	}
	
	public boolean loadProgram()
	{
		Log.i("MoSync Thread", "load program");
		try
		{
			ByteBuffer programBuffer = readInputStream(mContext.getResources().openRawResource(R.raw.program));
			int programBufferSize = programBuffer.position();
			programBuffer.position(0);
			
			mResourceFile = readInputStream(mContext.getResources().openRawResource(R.raw.resources));
			int resourceFileSize = mResourceFile.position();
			mResourceFile.position(0);
		
			if(programBuffer != null && mResourceFile != null)
			{
			
				if(false == nativeLoad(programBuffer, programBufferSize, mResourceFile, resourceFileSize))
				{
					Log.e("MoSync Thread", "ERROR Load program was unsuccesfull");
					return false;
				}

				Log.i("MoSync Thread", "Load program was succesfull");
				return true;
			}
			Log.e("MoSyncService", "No program buffer created!");
		}
		catch(Exception e)
		{
			Log.e("MoSyncService", "Exception while loading program:" + e.toString());
		}
		return false;
	}


private static final int CHUNK_READ_SIZE = 1024;   

	public ByteBuffer readInputStream(InputStream is) throws Exception
	{  
		Log.i("MoSync Thread", "Read Input Stream");
		
		ReadableByteChannel byteChannel = Channels.newChannel(is);  
		ByteBuffer byteBuffer = ByteBuffer.allocateDirect(CHUNK_READ_SIZE);  

		while (byteChannel.read(byteBuffer) != -1)
		{  
			if (byteBuffer.remaining() < CHUNK_READ_SIZE)
			{
				ByteBuffer temp = ByteBuffer.allocateDirect(byteBuffer.capacity() * 2);  
				byteBuffer.flip();  
				temp.put(byteBuffer);
				byteBuffer = temp;
			}	
		}
		
		Log.i("MoSync Thread", "position : " + byteBuffer.position());
		
		//byteBuffer.position(0);  
		
		return byteBuffer;  
	}  

	public void stopNow()
	{
		Log.i("MoSync Thread","stopNow");
	}
	
	@Override public void run()
	{
		Log.i("MoSync Thread", "run");

		if(false == loadProgram())
		{
			Log.i("MoSync Thread", "load program failed!! :(");
			return;
		}
		
		Log.i("MoSync Thread", "load program worked!!");
		
		nativeRun();
		
		Log.i("MoSync Thread", "loop has ended");
	}

	#include "MoSyncSyscalls.jpp"

	public native boolean nativeInitRuntime();
	public native boolean nativeLoad(ByteBuffer program, int programSize, ByteBuffer resource, int resourceSize);
	public native boolean nativeLoadResource(ByteBuffer resource);
	public native ByteBuffer nativeLoadCombined(ByteBuffer combined);
	public native void nativeRun();	
	public native void nativePostEvent(int[] eventBuffer);
	
	static 
	{ 
		System.loadLibrary("mosync"); 
	}
}
