/* Copyright (C) 2010 MoSync AB

This program is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License, version 2, as published by
the Free Software Foundation.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
for more details.

You should have received a copy of the GNU General Public License
along with this program; see the file COPYING.  If not, write to the Free
Software Foundation, 59 Temple Place - Suite 330, Boston, MA
02111-1307, USA.
*/

package com.mosync.internal.android;

import android.app.Activity;
import android.app.ActivityManager;
import android.app.ActivityManager.RecentTaskInfo;
import android.app.ActivityManager.RunningTaskInfo;
import android.app.WallpaperManager;

#ifdef _ANDROID_BLUETOOTH
import android.bluetooth.*;
#endif

import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.content.pm.ActivityInfo;
import android.content.pm.PackageManager;
import android.content.res.AssetFileDescriptor;
import android.content.res.AssetManager;

import android.graphics.Canvas;
import android.graphics.Bitmap;
import android.graphics.Paint;
import android.graphics.Region;
import android.graphics.BitmapFactory;
import android.graphics.Rect;
import android.graphics.Matrix;
import android.graphics.Path;
import android.graphics.PorterDuff.Mode;

import android.location.Location;
import android.location.LocationManager;
import android.location.LocationListener;
import android.location.LocationProvider;

import android.media.MediaPlayer;

import android.net.SSLCertificateSocketFactory;
import android.net.Uri;

import android.os.Handler;
import android.os.Looper;
import android.os.Message;
import android.os.Bundle;
import android.os.SystemClock;
import android.os.Vibrator;

import android.telephony.TelephonyManager;

import android.util.DisplayMetrics;
import android.util.Log;

import android.view.WindowManager;
import android.view.inputmethod.InputMethodManager;

import com.mosync.java.android.MoSync;
import com.mosync.java.android.TextBox;
import com.mosync.java.android.MoSyncPanicDialog;

import java.lang.reflect.Method;

import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.FileDescriptor;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.FileNotFoundException;
import java.io.InputStream;
import java.io.InterruptedIOException;
import java.io.IOException;
import java.io.OutputStream;

import java.net.*;

import java.nio.BufferUnderflowException;
import java.nio.ByteBuffer;
import java.nio.ByteOrder;
import java.nio.IntBuffer;
import java.nio.channels.Channels;
import java.nio.channels.FileChannel;
import java.nio.channels.ReadableByteChannel;

import java.util.Date;
import java.util.Hashtable;
import java.util.Locale;
import java.util.List;
import java.util.Set;
import java.util.TimeZone;
import java.util.UUID;

import java.util.concurrent.ConcurrentLinkedQueue;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicInteger;

import java.nio.ByteOrder;

import javax.net.SocketFactory;

import com.mosync.java.android.MoSync;
import com.mosync.java.android.MoSyncPanicDialog;
import com.mosync.java.android.MoSyncService;

#include "helpers.h"

//#define SYSLOG(a) Log.i("MoSyncThread SYSLOG", a);
#define SYSLOG(...)

public class MoSyncThread extends Thread
{
	static final String PROGRAM_FILE = "program.mp3";
	static final String RESOURCE_FILE = "resources.mp3";
	
	/**
	 * Chunk size used when loading resources.
	 */
	private static final int CHUNK_READ_SIZE = 1024; 

	private MoSync mContext;
	private Handler mHandler;
	private MoSyncView mMoSyncView;
	private boolean mHasDied;
	
	/**
	 * This is the size of the header of the asset file
	 * (an Android file header, this is not a MoSync header).
	 * The actual resource data is found at this offset.
	 * On the Java side an input stream to the asset file
	 * will begin at this offset. 
	 * UBinData resources have offsets that start at the
	 * very beginning of the resource file.
	 * Therefore mResourceOffset needs to be used on the 
	 * Java side when reading data from ubin resource file.
	 */
	private long mResourceOffset = 0;
	
	ByteBuffer mRecompilerCodeBlock;
	ByteBuffer mRecompilerEntryBlock;
	
	/**
	* @brief MoSyncThread constructor
	*/
	public MoSyncThread(Context context, Handler handler) throws Exception
	{	
		mContext = (MoSync)context;
		mHandler = handler;
		mHasDied = false;
		
		nativeInitRuntime();	
	}
	
	/**
	* @brief setMoSyncView
	*/
	public void setMoSyncView(MoSyncView moSyncView)
	{
		mMoSyncView = moSyncView;
	}
	
	/**
	* @brief isDead
	*/
	public boolean isDead()
	{
		return mHasDied;
	}
	
	/**
	* @brief updateSurfaceSize
	*/
	public void updateSurfaceSize(int width, int height)
	{
		SYSLOG("updateSurfaceSize");		
		
		// If the surface has same width and height we do not create a new canvas.
		if((mWidth == width) && (mHeight == height)) return;
		
		mWidth = width;
		mHeight = height;
		
		Bitmap bitmap = Bitmap.createBitmap(mWidth, mHeight, Bitmap.Config.ARGB_8888);
		Canvas canvas = new Canvas(bitmap);
		mDrawTargetScreen = new ImageCache(canvas, bitmap);
		
		mCanvas = mDrawTargetScreen.mCanvas;
		mBitmap = mDrawTargetScreen.mBitmap;
		
		updateScreen();
		
		SYSLOG("mBitmap width:" + mBitmap.getWidth() + " height:" + mBitmap.getHeight());
	}

	/**
	* @brief generateDataSection
	*/
	public ByteBuffer generateDataSection(int size)
	{
		try
		{
			mMemDataSection = ByteBuffer.allocateDirect(size);
			mMemDataSection.order(null);
		}
		catch (Exception e)
		{
			logError("MoSyncThread - Out of Memory!", e);
		}
		return mMemDataSection;
	}
	
	/**
	* @brief threadPanic
	*/
	public void threadPanic(int errorCode, String message)
	{
		SYSLOG("PANIC - errorCode: " + errorCode + " message: " + message);
		mHasDied = true;
		try
		{
			// Launch panic dialog.
			MoSyncPanicDialog.sPanicMessage = message;
			Intent myIntent = new Intent(mMoSyncView.getContext(), MoSyncPanicDialog.class);
			mMoSyncView.getContext().startActivity(myIntent);
			
			// Sleep so that the MoSync thread is kept alive while the dialog is open.
			while (true)
			{
				try
				{
					sleep(Long.MAX_VALUE);
				}
				catch (Exception e)
				{
					logError("threadPanic exception 1:" + e, e);
				}
			}
		}
		catch (Exception e)
		{
			logError("threadPanic exception 2:" + e, e);
		}
	}
	
	/**
	* @brief loadProgram
	*/
	public boolean loadProgram()
	{
		SYSLOG("loadProgram");
		try
		{
			AssetManager assetManager = mContext.getAssets();
			AssetFileDescriptor pAfd = assetManager.openFd(PROGRAM_FILE);
			FileDescriptor pFd = pAfd.getFileDescriptor();
			long pFdOffset = pAfd.getStartOffset();

			FileDescriptor rFd = null;
			mResourceOffset = 0;
			
			try
			{
				AssetFileDescriptor rAfd = assetManager.openFd(RESOURCE_FILE);
				rFd = rAfd.getFileDescriptor();
				mResourceOffset = rAfd.getStartOffset();
			}
			catch (FileNotFoundException fnfe)
			{
				logError("loadProgram - Has no resources! exception: " + fnfe.toString(), fnfe);
			}
			
			if (null != pFd)
			{
				if (false == nativeLoad(pFd, pFdOffset, rFd, mResourceOffset))
				{
					logError("loadProgram - ERROR Load program was unsuccesfull");
					threadPanic(0, "Unable to load program or resources");
					return false;
				}

				SYSLOG("loadProgram - Load program was succesfull");
				return true;
			}
		}
		catch (Exception e)
		{
			logError("loadProgram - Exception while loading program:" + e.toString(), e);
		}
		return false;
	}
	
	/**
	* @brief getResourceFileDescriptor
	*/
	public FileDescriptor getResourceFileDesriptor()
	{		
		try
		{
			AssetManager assetManager = mContext.getAssets();
			AssetFileDescriptor pAfd = assetManager.openFd(RESOURCE_FILE);
			FileDescriptor pFd = pAfd.getFileDescriptor();
			return pFd;
		}
		catch (Exception e)
		{
			logError("getResourceFileDesriptor exception:" + e.toString(), e);
		}
		return null;
	}
	
	/**
	* @brief getResourceStartOffset
	*/
	public int getResourceStartOffset()
	{
		return (int)mResourceOffset;
	}

  

	/**
	* @brief readInputStream
	*/
	public ByteBuffer readInputStream(InputStream is) throws Exception
	{  
		ReadableByteChannel byteChannel = Channels.newChannel(is);  
		ByteBuffer byteBuffer = ByteBuffer.allocateDirect(CHUNK_READ_SIZE);  

		while (byteChannel.read(byteBuffer) != -1)
		{  
			if (byteBuffer.remaining() < CHUNK_READ_SIZE)
			{
				ByteBuffer temp = ByteBuffer.allocateDirect(byteBuffer.capacity() * 2);  
				byteBuffer.flip();  
				temp.put(byteBuffer);
				byteBuffer = temp;
			}	
		}
		
		return byteBuffer;  
	}  

	/**
	* @brief updateScreen
	*/
	public void updateScreen()
	{
		maUpdateScreen();
	}
	
	/**
	* @brief postEvent
	*/
	public void postEvent(int[] event)
	{
		nativePostEvent(event);
		interrupt(); // Wake up thread.
	}

	/**
	* @brief run
	*/
	@Override 
	public void run()
	{
		Log.i("MoSync Thread", "run");

		if (false == loadProgram())
		{
			logError("load program failed!!");
			return;
		}
	
		nativeRun();
		
	}
	
	public static void logError(String message , Throwable t)
	{
		logError(message);
		t.printStackTrace();
	}

	public static void logError(String message)
	{
		Log.e("Dalvik Syscall ERROR", message);
	}

	#include "MoSyncSyscalls.jpp"

	public native boolean nativeInitRuntime();
	public native boolean nativeLoad(FileDescriptor program, long programOffset, FileDescriptor resource, long resourceOffset);
	public native boolean nativeLoadResource(ByteBuffer resource);
	public native ByteBuffer nativeLoadCombined(ByteBuffer combined);
	public native void nativeRun();	
	public native void nativePostEvent(int[] eventBuffer);
	
	static 
	{ 
		System.loadLibrary("mosync"); 
	}
}
