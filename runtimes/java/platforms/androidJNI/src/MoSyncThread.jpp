/* Copyright (C) 2010 MoSync AB

This program is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License, version 2, as published by
the Free Software Foundation.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
for more details.

You should have received a copy of the GNU General Public License
along with this program; see the file COPYING.  If not, write to the Free
Software Foundation, 59 Temple Place - Suite 330, Boston, MA
02111-1307, USA.
*/

package com.mosync.internal.android;

import android.app.Activity;

#ifdef _ANDROID_BLUETOOTH
import android.bluetooth.*;
#endif

import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.content.res.AssetFileDescriptor;
import android.content.res.AssetManager;

import android.graphics.Canvas;
import android.graphics.Bitmap;
import android.graphics.Paint;
import android.graphics.Region;
import android.graphics.BitmapFactory;
import android.graphics.Rect;
import android.graphics.Matrix;
import android.graphics.Path;

import android.location.Location;
import android.location.LocationManager;
import android.location.LocationListener;
import android.location.LocationProvider;

import android.media.MediaPlayer;

import android.net.SSLCertificateSocketFactory;
import android.net.Uri;

import android.os.Handler;
import android.os.Looper;
import android.os.Message;
import android.os.Bundle;
import android.os.SystemClock;

import android.telephony.TelephonyManager;

import android.util.Log;

import android.view.inputmethod.InputMethodManager;

import com.mosync.java.android.MoSync;
import com.mosync.java.android.TextBox;
import com.mosync.java.android.MoSyncPanicDialog;

import java.lang.reflect.Method;

import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.FileDescriptor;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.FileNotFoundException;
import java.io.InputStream;
import java.io.InterruptedIOException;
import java.io.IOException;
import java.io.OutputStream;

import java.net.*;

import java.nio.BufferUnderflowException;
import java.nio.ByteBuffer;
import java.nio.ByteOrder;
import java.nio.IntBuffer;
import java.nio.channels.Channels;
import java.nio.channels.FileChannel;
import java.nio.channels.ReadableByteChannel;

import java.util.Date;
import java.util.Hashtable;
import java.util.Locale;
import java.util.List;
import java.util.TimeZone;
import java.util.UUID;

import java.util.concurrent.ConcurrentLinkedQueue;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicInteger;

import java.nio.ByteOrder;

import javax.net.SocketFactory;

import com.mosync.java.android.MoSync;
import com.mosync.java.android.MoSyncPanicDialog;

#include "helpers.h"

public class MoSyncThread extends Thread
{
	static final String PROGRAM_FILE = "program.mp3";
	static final String RESOURCE_FILE = "resources.mp3";

	private MoSync mContext;
	// TODO: Delete if not needed: private Handler mHandler;
	private boolean hasDied;
	
	private long mResourceOffset = 0;
	
	ByteBuffer mRecompilerCodeBlock;
	ByteBuffer mRecompilerEntryBlock;
	
	/**
	* @brief MoSyncThread constructor
	*/
	public MoSyncThread(Context context, Handler handler) throws Exception
	{	
		Log.i("MoSyncThread", "Constructor");
		
		mContext = (MoSync)context;
		// TODO: Delete if not needed: mHandler = handler;
		hasDied = false;
		
		nativeInitRuntime();	
	}
	
	/**
	* @brief setMoSyncView
	*/
	/*public void setMoSyncView(MoSyncView moSyncView)
	{
		mMoSyncView = moSyncView;
	}*/
	
	/**
	* @brief isDead
	*/
	public boolean isDead()
	{
		return hasDied;
	}
	
	// TODO: Move this method to class MoSyncView? 
	// Does not seem to use anything in this class.
	/**
	* @brief updateSurfaceSize
	*/
	public void updateSurfaceSize(int width, int height)
	{
		Log.i("MoSyncThread", "updateSurfaceSize");		
		
		mWidth = width;
		mHeight = height;
		
		Bitmap bitmap = Bitmap.createBitmap(mWidth, mHeight, Bitmap.Config.ARGB_8888);
		Canvas canvas = new Canvas(bitmap);
		mDrawTargetScreen = new ImageCache(canvas, bitmap);
		
		mCanvas = mDrawTargetScreen.mCanvas;
		mBitmap = mDrawTargetScreen.mBitmap;
		
		Log.i("MoSyncThread", "input width:" + width + " height:" + height);
		Log.i("MoSyncThread", "mBitmap width:" + mBitmap.getWidth() + " height:" + mBitmap.getHeight());
	}

	/**
	* @brief generateDataSection
	*/
	public ByteBuffer generateDataSection(int size)
	{
		Log.i("MoSync Thread","generate data section");
		try
		{
			Log.i("MoSyncThread", "generate data section");

			mMemDataSection = ByteBuffer.allocateDirect(size);

			Log.i("MoSyncThread", "generate data section - SUCCESS");

			mMemDataSection.order(null);
		}
		catch (Exception e)
		{
			Log.i("MoSyncThread", "generate data section - Out of Memory!");
		}
		return mMemDataSection;
	}
	
	public ByteBuffer generateRecompilerCodeBlock(int size)
	{
		Log.i("MoSyncThread", "generate recompiler code block");
		try
		{
			mRecompilerCodeBlock = ByteBuffer.allocateDirect(size);
		}
		catch(Exception e)
		{
			Log.i("MoSyncThread", "generate recompiler code block - Out of Memory!");
		}
		return mRecompilerCodeBlock;
	}
	
	public ByteBuffer generateRecompilerEntryBlock(int size)
	{
		Log.i("MoSyncThread", "generate recompiler entry block");
		try
		{
			mRecompilerEntryBlock = ByteBuffer.allocateDirect(size);
		}
		catch(Exception e)
		{
			Log.i("MoSyncThread", "generate recompiler entry block - Out of Memory!");
		}
		return mRecompilerEntryBlock;
	}
	
	/**
	* @brief threadPanic
	*/
	public void threadPanic(int errorCode, String message)
	{
		Log.i("MoSyncThread", "threadPanic");
		Log.i("MoSyncThread PANIC", "errorCode: " + errorCode + " message: " + message);

		hasDied = true;
		try
		{
			// Launch panic dialog.
			MoSyncPanicDialog.sPanicMessage = message;
			Intent myIntent = new Intent(mContext, MoSyncPanicDialog.class);
			mContext.startActivity(myIntent);
			
			// Sleep so that the MoSync thread is kept alive while the dialog is open.
			while (true)
			{
				try
				{
					sleep(Long.MAX_VALUE);
				}
				catch (Exception e)
				{
					Log.i("MoSyncThread", "threadPanic exception 1:" + e);
					e.printStackTrace();
				}
			}
		}
		catch (Exception e)
		{
			Log.i("MoSyncThread", "threadPanic exception 2:" + e);
			e.printStackTrace();
		}
	}
	
	/**
	* @brief loadProgram
	*/
	public boolean loadProgram()
	{
		Log.i("MoSync Thread", "load program");
		try
		{
		
			AssetManager assetManager = mContext.getAssets();
			AssetFileDescriptor pAfd = assetManager.openFd(PROGRAM_FILE);
			FileDescriptor pFd = pAfd.getFileDescriptor();
			long pFdOffset = pAfd.getStartOffset();
			

			FileDescriptor rFd = null;
			mResourceOffset = 0;
			
			try
			{
				AssetFileDescriptor rAfd = assetManager.openFd(RESOURCE_FILE);
				rFd = rAfd.getFileDescriptor();
				mResourceOffset = rAfd.getStartOffset();
			}
			catch (FileNotFoundException fnfe)
			{
				Log.i("loadProgram","Has no resources!");
				Log.i("loadProgram","exception" + fnfe.toString());
			}
			
			if (null != pFd)
			{
				Log.i("MoSyncThread", "calling native function");
				if (false == nativeLoad(pFd, pFdOffset, rFd, mResourceOffset))
				{
					Log.e("MoSync Thread", "ERROR Load program was unsuccesfull");
					threadPanic(0, "Unable to load program or resources");
					return false;
				}

				Log.i("MoSyncThread", "Load program was succesfull");
				return true;
			}
		}
		catch (Exception e)
		{
			Log.e("MoSyncService", "Exception while loading program:" + e.toString());
		}
		return false;
	}
	
	/**
	* @brief getResourceFileDescriptor
	*/
	public FileDescriptor getResourceFileDesriptor()
	{		
		try
		{
			AssetManager assetManager = mContext.getAssets();
			AssetFileDescriptor pAfd = assetManager.openFd(RESOURCE_FILE);
			FileDescriptor pFd = pAfd.getFileDescriptor();
			return pFd;
		}
		catch (Exception e)
		{
			Log.e("MoSyncService", "getResourceFileDesriptor exception:" + e.toString());
		}
		return null;
	}
	
	/**
	* @brief getResourceStartOffset
	*/
	public int getResourceStartOffset()
	{
		return (int)mResourceOffset;
	}


private static final int CHUNK_READ_SIZE = 1024;   

	/**
	* @brief readInputStream
	*/
	public ByteBuffer readInputStream(InputStream is) throws Exception
	{  
		Log.i("MoSync Thread", "Read Input Stream");
		
		ReadableByteChannel byteChannel = Channels.newChannel(is);  
		ByteBuffer byteBuffer = ByteBuffer.allocateDirect(CHUNK_READ_SIZE);  

		while (byteChannel.read(byteBuffer) != -1)
		{  
			if (byteBuffer.remaining() < CHUNK_READ_SIZE)
			{
				ByteBuffer temp = ByteBuffer.allocateDirect(byteBuffer.capacity() * 2);  
				byteBuffer.flip();  
				temp.put(byteBuffer);
				byteBuffer = temp;
			}	
		}
		
		Log.i("MoSync Thread", "position : " + byteBuffer.position());
		
		return byteBuffer;  
	}  

	/**
	* @brief stopNow 
	*/
	public void stopNow()
	{
		Log.i("MoSync Thread","stopNow");
	}

	/**
	* @brief updateScreen
	*/
	public void updateScreen()
	{
		maUpdateScreen();
	}
	
	/**
	* @brief postEvent
	*/
	public void postEvent(int[] event)
	{
		nativePostEvent(event);
		interrupt(); // Wake up thread.
	}

	/**
	* @brief run
	*/
	@Override 
	public void run()
	{
		Log.i("MoSync Thread", "run");

		if (false == loadProgram())
		{
			Log.i("MoSync Thread", "load program failed!! :(");
			return;
		}
		
		Log.i("MoSync Thread", "load program worked!!");
		
		nativeRun();
		
		Log.i("MoSync Thread", "loop has ended");
	}
	
	#include "MoSyncSyscalls.jpp"

	public native boolean nativeInitRuntime();
	public native boolean nativeLoad(FileDescriptor program, long programOffset, FileDescriptor resource, long resourceOffset);
	public native boolean nativeLoadResource(ByteBuffer resource);
	public native ByteBuffer nativeLoadCombined(ByteBuffer combined);
	public native void nativeRun();	
	public native void nativePostEvent(int[] eventBuffer);
	
	static 
	{ 
		System.loadLibrary("mosync"); 
	}
}
