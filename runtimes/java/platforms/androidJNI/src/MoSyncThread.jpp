/* Copyright (C) 2010 MoSync AB

This program is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License, version 2, as published by
the Free Software Foundation.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
for more details.

You should have received a copy of the GNU General Public License
along with this program; see the file COPYING.  If not, write to the Free
Software Foundation, 59 Temple Place - Suite 330, Boston, MA
02111-1307, USA.
*/

package com.mosync.internal.android;

import java.nio.ByteBuffer;
import java.nio.IntBuffer;
import java.nio.channels.Channels;
import java.nio.channels.FileChannel;
import java.nio.channels.ReadableByteChannel;

import java.io.InputStream;
import java.io.OutputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.FileDescriptor;
import java.io.InterruptedIOException;

import java.io.IOException;

import java.net.*;
import android.net.Uri;

import android.content.Intent;
import android.content.Context;
import android.content.res.AssetManager;
import android.content.res.AssetFileDescriptor;

import android.os.Handler;


import android.graphics.Canvas;
import android.graphics.Bitmap;
import android.graphics.Paint;
import android.graphics.Region;
import android.graphics.BitmapFactory;
import android.graphics.Rect;
import android.graphics.Matrix;

import java.util.Date;
import java.util.TimeZone;
import java.util.Hashtable;
import java.util.Locale;
	
import android.util.Log;

import com.mosync.java.android.MoSyncPanicDialog;
import com.mosync.java.android.WebViewActivity;

import java.io.FileNotFoundException;

import android.content.BroadcastReceiver;
import android.content.IntentFilter;

import android.app.Activity;

import android.telephony.TelephonyManager;

import android.view.inputmethod.InputMethodManager;

#ifdef _ANDROID_BLUETOOTH
import android.bluetooth.*;

#endif

#include "helpers.h"

public class MoSyncThread extends Thread
{
	private Context mContext;
	private Handler mHandler;
	private MoSyncView mMoSyncView;
	private boolean hasDied;
	
	private long mResourceOffset = 0;
	
	ByteBuffer mRecompilerCodeBlock;
	ByteBuffer mRecompilerEntryBlock;
	
	public MoSyncThread(Context context, Handler handler) throws Exception
	{	
		mContext = context;
		mHandler = handler;
		hasDied = false;
	
		Log.i("MoSync Thread", "Constructor");

		nativeInitRuntime();	
		//initSyscalls();
	}
	
	public void setMoSyncView(MoSyncView moSyncView)
	{
		mMoSyncView = moSyncView;
	}
	
	public boolean isDead()
	{
		return hasDied;
	}
	
	public void updateSurfaceSize(int width, int height)
	{
		Log.i("MoSync Thread","updateSurfaceSize");		
		//mCore.resizeScreen(mWidth, mHeight);

		mWidth = width;
		mHeight = height;
		
		Bitmap bitmap = Bitmap.createBitmap(mWidth, mHeight, Bitmap.Config.ARGB_8888);
		Canvas canvas = new Canvas(bitmap);
		mDrawTargetScreen = new ImageCache(canvas, bitmap);
		
		mCanvas = mDrawTargetScreen.mCanvas;
		mBitmap = mDrawTargetScreen.mBitmap;
		
		Log.i("MoSync Thread","input width:" + width + " height:" + height);
		Log.i("MoSync Thread","mBitmap width:" + mBitmap.getWidth() + " height:" + mBitmap.getHeight());
	}

	public ByteBuffer generateDataSection(int size)
	{
		try
		{
			Log.i("MoSyncThread","generate data section");
			mMemDataSection = ByteBuffer.allocateDirect(size);
			Log.i("MoSyncThread","generate data section - SUCCESS");
		}
		catch(Exception e)
		{
			Log.i("MoSyncThread", "Out of Memory!");
		}
		return mMemDataSection;
	}
	
	public ByteBuffer generateRecompilerCodeBlock(int size)
	{
		Log.i("MoSyncThread","generate recompiler code block");
		try
		{
			mRecompilerCodeBlock = ByteBuffer.allocateDirect(size);
		}
		catch(Exception e)
		{
			Log.i("MoSyncThread", "Out of Memory!");
		}
		return mRecompilerCodeBlock;
	}
	
	public ByteBuffer generateRecompilerEntryBlock(int size)
	{
		Log.i("MoSyncThread","generate recompiler entry block");
		try
		{
			mRecompilerEntryBlock = ByteBuffer.allocateDirect(size);
		}
		catch(Exception e)
		{
			Log.i("MoSyncThread", "Out of Memory!");
		}
		return mRecompilerEntryBlock;
	}
	

	public void threadPanic(int errorCode, String message)
	{
		Log.i("MoSyncThread","threadPanic");
		hasDied = true;
		try
		{
			MoSyncPanicDialog.sPanicMessage = message;
			Intent myIntent = new Intent(mMoSyncView.getContext(), MoSyncPanicDialog.class);
			mMoSyncView.getContext().startActivity(myIntent);
			this.sleep(Long.MAX_VALUE);
		}
		catch(Exception e)
		{
			Log.i("MoSyncThread","threadPanic exception:" + e.toString());
		}
	}
	
	public boolean loadProgram()
	{
		Log.i("MoSync Thread", "load program");
		try
		{
		
			AssetManager assetManager = mContext.getAssets();
			AssetFileDescriptor pAfd = assetManager.openFd("program.mp3");
			FileDescriptor pFd = pAfd.getFileDescriptor();
			long pFdOffset = pAfd.getStartOffset();
			

			FileDescriptor rFd = null;
			mResourceOffset = 0;
			
			try
			{
				AssetFileDescriptor rAfd = assetManager.openFd("resources.mp3");
				rFd = rAfd.getFileDescriptor();
				mResourceOffset = rAfd.getStartOffset();
			}
			catch(FileNotFoundException fnfe)
			{
				Log.i("loadProgram","Has no resources!");
				Log.i("loadProgram","exception" + fnfe.toString());
			}
			
			if(null != pFd)
			{
				Log.i("MoSync Thread", "calling native function");
				if(false == nativeLoad(pFd, pFdOffset, rFd, mResourceOffset))
				{
					Log.e("MoSync Thread", "ERROR Load program was unsuccesfull");
					threadPanic(0, "Unable to load program or resources");
					return false;
				}

				Log.i("MoSync Thread", "Load program was succesfull");
				return true;
			}
		
		

		}
		catch(Exception e)
		{
			Log.e("MoSyncService", "Exception while loading program:" + e.toString());
		}
		return false;
	}
	
	public FileDescriptor getResourceFileDesriptor()
	{		
		try
		{
			AssetManager assetManager = mContext.getAssets();
			AssetFileDescriptor pAfd = assetManager.openFd("resources.mp3");
			FileDescriptor pFd = pAfd.getFileDescriptor();
			return pFd;
		}
		catch(Exception e)
		{
			Log.e("MoSyncService","getResourceFileDesriptor exception:" + e.toString());
		}
		return null;
	}
	
	public int getResourceStartOffset()
	{
		return (int)mResourceOffset;
	}


private static final int CHUNK_READ_SIZE = 1024;   

	public ByteBuffer readInputStream(InputStream is) throws Exception
	{  
		Log.i("MoSync Thread", "Read Input Stream");
		
		ReadableByteChannel byteChannel = Channels.newChannel(is);  
		ByteBuffer byteBuffer = ByteBuffer.allocateDirect(CHUNK_READ_SIZE);  

		while (byteChannel.read(byteBuffer) != -1)
		{  
			if (byteBuffer.remaining() < CHUNK_READ_SIZE)
			{
				ByteBuffer temp = ByteBuffer.allocateDirect(byteBuffer.capacity() * 2);  
				byteBuffer.flip();  
				temp.put(byteBuffer);
				byteBuffer = temp;
			}	
		}
		
		Log.i("MoSync Thread", "position : " + byteBuffer.position());
		
		return byteBuffer;  
	}  
/*
	public FileDescriptor getResourceFileDescriptor()
	{
	
	}
*/	
	public void stopNow()
	{
		Log.i("MoSync Thread","stopNow");
	}
	
	@Override public void run()
	{
		Log.i("MoSync Thread", "run");

		if(false == loadProgram())
		{
			Log.i("MoSync Thread", "load program failed!! :(");
			return;
		}
		
		Log.i("MoSync Thread", "load program worked!!");
		
		nativeRun();
		
		Log.i("MoSync Thread", "loop has ended");
	}
	
	#include "MoSyncSyscalls.jpp"

	public native boolean nativeInitRuntime();
	public native boolean nativeLoad(FileDescriptor program, long programOffset, FileDescriptor resource, long resourceOffset);
	public native boolean nativeLoadResource(ByteBuffer resource);
	public native ByteBuffer nativeLoadCombined(ByteBuffer combined);
	public native void nativeRun();	
	public native void nativePostEvent(int[] eventBuffer);
	
	static 
	{ 
		System.loadLibrary("mosync"); 
	}
}
