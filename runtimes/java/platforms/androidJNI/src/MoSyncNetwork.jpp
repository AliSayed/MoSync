/* Copyright (C) 2009 Mobile Sorcery AB

This program is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License, version 2, as published by
the Free Software Foundation.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
for more details.

You should have received a copy of the GNU General Public License
along with this program; see the file COPYING.  If not, write to the Free
Software Foundation, 59 Temple Place - Suite 330, Boston, MA
02111-1307, USA.
*/

#define HTTP_STATE_NULL 0
#define HTTP_STATE_SETUP 1
#define HTTP_STATE_WRITING 2
#define HTTP_STATE_FINISHING 3
#define HTTP_STATE_FINISHED 4

int CONNOP_CONNECT_SUCCESS = 1;
			
/*
 * Hashtable is used to keep all the open connections.
 */
Hashtable<Integer, ConnectionObject> mConnections_DoNotReferenceExplictly = 
	new Hashtable<Integer, ConnectionObject>();

/**
 * Connection handle counter.
 */
int mConnHandleCounter_DoNotReferenceExplictly = 1;

/**
 * Thread pool for network operations.
 * TODO: Perhaps rename to mNetworkThreadPool or something
 * to make the use explicit from the name.
 */
ThreadPool mThreadPool = new ThreadPool();

/**
* Initiates a connection and if successfull, adds the new connection to the table of open connections
*
* @param url	The URL to which the connection should be established.
				URLs that starts with "socket://" needs to have a port specified.
				URLs that starts with "btspp://" tries to connect to a bluetooth port.
*
* @return CONNERR_URL if the URL wasn't correct.
          CONNERR_GENERIC on other errors.
* 		  > 0 on success. This number is the handle to the opened connection.
*/
MAHandle maConnect(final String url) 
{
	Log.i("MoSyncSyscall", "maConnect url: " + url);

	if (networkIsMaxNumberOfConnectionsReached())
	{
		return CONNERR_MAX;
	}
	
	int connHandle = networkGetNextConnectionHandle();
	
	try
	{
		ConnectionObject connObj;
		
		if (url.startsWith("socket://"))
		{
			connObj = new SocketConnectionObject().create(url, connHandle);
		}	
		else if (url.startsWith("btspp://"))
		{
#ifdef _ANDROID_BLUETOOTH		
			connObj = btCreateBluetoothConnectionObject(url, connHandle);
#else
			throw new Exception("Bluetooth not supported!");
#endif // _ANDROID_BLUETOOTH
		}
		else
		{
			connObj = new UrlConnectionObject().create(url, connHandle);
		}
		
		connObj.connect();
	}
	catch (MalformedURLException e)
	{
		SYSLOG("MalformedURLException: " + e.toString());
		e.printStackTrace();
		return CONNERR_URL;
	}
	catch (IOException e)
	{
		SYSLOG("IOException: " + e.toString());
		e.printStackTrace();
		return CONNERR_GENERIC;
	}
	catch (Exception e)
	{
		SYSLOG("Exception: " + e.toString());
		e.printStackTrace();
		return CONNERR_GENERIC;
	}

	return connHandle;
}

/**
*
*/
int maConnGetAddr(MAHandle conn, long addr) throws Exception {
	Log.i("MoSyncSyscall", "maConnGetAddr");
	/* FIX-ME */
	return -1;
}

/**
* Close a connection.
*/
void maConnClose(MAHandle connHandle) throws Exception 
{
	Log.i("MoSyncSyscall", "maConnClose");
	ConnectionObject connObj = networkGetConnectionObject(connHandle);
	connObj.close();
	networkRemoveConnectionObject(connObj);
}

void maConnRead(MAHandle connHandle, int dst, int size) 
{
	Log.i(
		"@MoSyncSyscall",
		"maConnRead" + " connHandle:" + connHandle + " dst:" + dst + " size:" + size);
	SYSLOG("connHandle:" + connHandle + " dst:" + dst + " size:" + size);
	
	MYASSERT(size > 0);
	
	ConnectionObject connObj = networkGetConnectionObject(connHandle);
	connObj.read(dst, size);
}

void maConnWrite(MAHandle connHandle, int src, int size) throws IOException 
{
	Log.i("MoSyncSyscall", "maConnWrite connHandle:" + connHandle + " src:" + src + " size:" + size);
	SYSLOG("connHandle:" + connHandle + " src:" + src + " size:" + size);
	
	MYASSERT(size > 0);
	
	ConnectionObject connObj = networkGetConnectionObject(connHandle);
	connObj.write(src, size);
}

void maConnReadToData(MAHandle connHandle, MAHandle data, int offset, int size) 
{
	Log.i("MoSyncSyscall", "maConnReadToData");

	MYASSERT(offset >= 0);
	MYASSERT(size > 0);
	MYASSERT(offset + size > 0);
	
	ConnectionObject connObj = networkGetConnectionObject(connHandle);
	connObj.readToData(data, offset, size);
}

void maConnWriteFromData(MAHandle connHandle, MAHandle data, int offset, int size) 
	throws IOException 
{
	Log.i("MoSyncSyscall", "maConnWriteFromData");

	MYASSERT(offset >= 0);
	MYASSERT(size > 0);
	MYASSERT(offset + size > 0);

	ConnectionObject connObj = networkGetConnectionObject(connHandle);
	connObj.writeFromData(data, offset, size);
}

MAHandle maHttpCreate(String url, int method) throws Exception
{
	Log.i("MoSyncSyscall", "maHttpCreate");
	
	// Have we reached the max number of connections?
	if (networkIsMaxNumberOfConnectionsReached())
	{
		return CONNERR_MAX;
	}
	
	int connHandle = networkGetNextConnectionHandle();
	
	try
	{
		ConnectionObject connObj = 
			new HttpConnectionObject().create(url, method, connHandle);
		DEBUG_ASSERT(connObj.mHttpState == HTTP_STATE_NULL);
		connObj.mHttpState = HTTP_STATE_SETUP;
		networkAddConnectionObject(connObj);
	}
	catch (MalformedURLException e)
	{
		PRINT_STACK_TRACE;
		return CONNERR_URL;
	}
	catch (IOException e)
	{
		PRINT_STACK_TRACE;
		return CONNERR_GENERIC;
	}
	catch (Exception e)
	{
		PRINT_STACK_TRACE;
		return CONNERR_GENERIC;
	}
	
	return connHandle;
}

void maHttpSetRequestHeader(MAHandle connHandle, String key, String value)
	throws Exception
{
	Log.i("MoSyncSyscall","URLConnectionTask - maHttpSetRequestHeader");

	ConnectionObject connObj = networkGetConnectionObject(connHandle);
	connObj.setRequestProperty(key, value);
}

int maHttpGetResponseHeader(MAHandle connHandle, String key, long address, int bufSize)
	throws Exception
{
	Log.i("MoSyncSyscall","URLConnectionTask - maHttpGetResponseHeader");
	
	ConnectionObject connObj = networkGetConnectionObject(connHandle);
	return connObj.getResponseHeader(key, address, bufSize);
}

void maHttpFinish(MAHandle connHandle)
{
	Log.i("MoSyncSyscall","URLConnectionTask - maHttpFinish");
	
	ConnectionObject connObj = networkGetConnectionObject(connHandle);
	
	MYASSERT(connObj.mState == 0);
	MYASSERT(connObj.mHttpState == HTTP_STATE_SETUP || connObj.mHttpState == HTTP_STATE_WRITING);

	connObj.mState = CONNOP_FINISH;
	connObj.mHttpState = HTTP_STATE_FINISHING;
	connObj.mMoSyncThread = this;
	
	connObj.startConnectThread();
}

int maAccept(MAHandle serverHandle)
{
	Log.i("@@ NetworkSyscall", "maAccept");
	
	// Find the connection object. 
	ConnectionObject connObj = networkGetConnectionObject(serverHandle);
	if (null == connObj)
	{
		Log.i("@@@ maAccept", "null == connObj, serverHandle = " + serverHandle);
		return -1; // Error
	}
	
	// Verify that it is a server connection.
	if (!connObj.isServerConnection())
	{
		Log.i("@@@ maAccept", "!connObj.isServerConnection()");
		return -1; // Error
	}
	
	// Return if accept thread is running.
	if (connObj.isAcceptThreadRunning())
	{
		Log.i("@@@ maAccept", "connObj.isAcceptThreadRunning()");
		return -1; // Error
	}
	
	// Start accept thread.
	connObj.startAcceptThread();
	
	return 1; // Success
}

int networkGetNextConnectionHandle()
{
	return mConnHandleCounter_DoNotReferenceExplictly++;
}

boolean networkIsMaxNumberOfConnectionsReached()
{
	return (mConnHandleCounter_DoNotReferenceExplictly + 1) >= CONN_MAX;
}

ConnectionObject networkGetConnectionObject(MAHandle connHandle)
{
	return mConnections_DoNotReferenceExplictly.get(connHandle);
}
	
void networkAddConnectionObject(ConnectionObject connObj)
{
	mConnections_DoNotReferenceExplictly.put(connObj.mHandle, connObj);
}

void networkRemoveConnectionObject(ConnectionObject connObj)
{
	mConnections_DoNotReferenceExplictly.remove(connObj.mHandle); 
}

public abstract class ConnectionObject
{
	public ByteBuffer mByteBuffer;
	public long mMemory;
	public int mOffset;
	public int mSize;
	public URLConnection mConnection;
	public Socket mSocket;
	public boolean mReadData;
	public boolean mUseResource;
	public int mState;
	public int mHttpState;
	public boolean mCancelled;
	public boolean mIsHttpConnection;
	public boolean mIsSocketConnection;
	protected MAHandle mHandle;
	public MAHandle mData;
	public Thread mMoSyncThread;
	public String mSocketAddress;
	public int mSocketPort;
	
	public ConnectionObject()
	{
		mState = 0;
		mHttpState = HTTP_STATE_NULL;
		mCancelled = false;
		mIsHttpConnection = false;
		mIsSocketConnection = false;
		mMoSyncThread = MoSyncThread.this;
	}
	
	public void postResultEvent(int opType, int result)
	{
		postResultEvent(mHandle, opType, result);
	}
	
	public void postResultEvent(MAHandle handle, int opType, int result)
	{
		Log.i("ConnectionObject.postResultEvent", "handle: " + handle + " opType: " + opType + " result: " + result);

		MYASSERT((mState & opType) != 0);
		mState &= ~opType;

		int[] event = new int[4];
		event[0] = EVENT_TYPE_CONN;
		event[1] = handle;
		event[2] = opType;
		event[3] = result;
		
		Log.i("ConnectionObject.postResultEvent", "Calling nativePostEvent");
		nativePostEvent(event);
		
		Log.i("ConnectionObject.postResultEvent", "Calling interrupt");
		mMoSyncThread.interrupt();
	}
	
	// Why synchronization?
	public synchronized void close() throws IOException
	{
		mCancelled = true;
		if (getInputStream() != null)
		{
			getInputStream().close();
		}
		if (getOutputStream() != null)
		{
			getOutputStream().close();
		}
		mConnection = null;
	}
	
	public void read(int dst, int size)
	{
		mMemory = dst;
		mSize = size;
		mReadData = true;
		mUseResource = false;
		
		try
		{
			MYASSERT(getInputStream() != null);
		}
		catch (IOException e)
		{
			PRINT_STACK_TRACE;
		}
		
		MYASSERT((mState & CONNOP_READ) == 0);
		
		mState |= CONNOP_READ;
		//mMoSyncThread = MoSyncThread.this;
		
		Log.i("ConnectionObject", "Starting read thread");
		
		mThreadPool.execute(new HttpConnectionRunner(this));
	}
	
	public void write(int src, int size)
	{
		mMemory = src;
		mSize = size;
		mReadData = false;
		mUseResource = false;
		
		try
		{
			MYASSERT(getOutputStream() != null);
		}
		catch (IOException e)
		{
			e.printStackTrace();
			return;
		}
		
		MYASSERT((mState & CONNOP_WRITE) == 0);
		
		// HTTP_STATE_WRITING is never really used. 
		// We do not need to set it. 
		// TODO: Remove it altogether.
		/*
		if (connObj.mIsHttpConnection == true) 
		{
			HttpURLConnection httpConn = (HttpURLConnection) connObj.mConnection;
			
			if (httpConn.getRequestMethod().equals("POST") && 
				connObj.mHttpState == HTTP_STATE_SETUP) 
			{
				connObj.mHttpState = HTTP_STATE_WRITING;
			}
		}
		else if (connObj.mIsSocketConnection == true) 
		{
			if(connObj.mHttpState == HTTP_STATE_SETUP)
				connObj.mHttpState = HTTP_STATE_WRITING;
		}
		*/
		
		mState |= CONNOP_WRITE;
		//mMoSyncThread = MoSyncThread.this;
		
		Log.i("ConnectionObject", "Starting write thread");
		
		mThreadPool.execute(new HttpConnectionRunner(this));
	}
	
	public void readToData(MAHandle data, int offset, int size)
	{
	/*
		Binary binaryResource = (Binary)getResource(data);
		MYASSERT(binaryResource.size() >= offset + size);
	*/
		ByteBuffer byteBuffer = (ByteBuffer) mBinaryResources.get(data);
		if (null == byteBuffer) 
		{
			BIG_PHAT_ERROR;
		}

		mData = data;
		//mBinary = binaryResource;
		mByteBuffer = byteBuffer;
		mOffset = offset;
		mSize = size;
		mReadData = true;
		mUseResource = true;
		
		try
		{
			MYASSERT(getInputStream() != null);
		}
		catch(IOException e)
		{
			PRINT_STACK_TRACE;
		}
		
		/*
			The JNI side is responsible for setting the resource in flux
		*/
		//setResource(data, mFlux);
		
		mState |= CONNOP_READ;
		//mMoSyncThread = MoSyncThread.this;
		
		mThreadPool.execute(new HttpConnectionRunner(this));
	}
	
	public void writeFromData(MAHandle data, int offset, int size)
	{
	/*
		Binary binaryResource = (Binary)getResource(data);
		MYASSERT(binaryResource.size() >= offset + size);
	*/
		ByteBuffer byteBuffer = (ByteBuffer) mBinaryResources.get(data);
		if (null == byteBuffer) 
		{
			BIG_PHAT_ERROR;
		}
		
		mData = data;
		//mBinary = binaryResource;
		mByteBuffer = byteBuffer;
		mOffset = offset;
		mSize = size;
		mReadData = false;
		mUseResource = true;
		
		try
		{
			MYASSERT(getOutputStream() != null); 	
		}
		catch(IOException e)
		{
			PRINT_STACK_TRACE;
		}
		
		// HTTP_STATE_WRITING is never really used. 
		// We do not need to set it. 
		// TODO: Remove it altogether.
		/*
		MYASSERT((connObj.mState & CONNOP_WRITE) == 0);
		if(connObj.mIsHttpConnection == true) {
			HttpURLConnection httpConn = (HttpURLConnection) connObj.mConnection;
			
			if(httpConn.getRequestMethod().equals("POST") && connObj.mHttpState == HTTP_STATE_SETUP) {
				connObj.mHttpState = HTTP_STATE_WRITING;
			}
		}
		else if(connObj.mIsSocketConnection == true) {
			if(connObj.mHttpState == HTTP_STATE_SETUP)
				connObj.mHttpState = HTTP_STATE_WRITING;
		}
		*/
		
		/*
			The JNI side is responsible for setting the resource in flux
		*/
		//setResource(data, mFlux);
		
		mState |= CONNOP_WRITE;
		//mMoSyncThread = MoSyncThread.this;
		
		mThreadPool.execute(new HttpConnectionRunner(this));
	}
	
	public void setRequestProperty(String key, String value)
	{
		MYASSERT(mHttpState == HTTP_STATE_SETUP);
		
		try
		{
			mConnection.setRequestProperty(key, value);
		} 
		catch (IllegalStateException e)
		{
			PRINT_STACK_TRACE;
		} 
		catch (NullPointerException e)
		{
			PRINT_STACK_TRACE;
		}
	}

	public int getResponseHeader(String key, long address, int bufSize)
	{
		try
		{
			String value = mConnection.getHeaderField(key);
			
			if (value == null)
			{
				return CONNERR_NOHEADER;
			}
			
			// Write the bufSize first characters in the String value to ds_mem starting at address
			
			byte[] vstr = value.getBytes();
			
			SYSLOG("value: " + value + " vstr: " + new String(vstr) + " vstr.length: " + vstr.length + "position: " + address);
			
			mMemDataSection.mark();
			mMemDataSection.position((int)address);
			mMemDataSection.put(vstr, 0, vstr.length);
			mMemDataSection.reset();
			
			return vstr.length;
		} 
		catch (IllegalStateException e)
		{
			PRINT_STACK_TRACE;
		} 
		
		return -1;
	}

	public void connect()
	{
		mState |= CONNOP_CONNECT;
		networkAddConnectionObject(this);
		startConnectThread();
	}
	
	public void startConnectThread() { }
	public void startAcceptThread() { }
	public boolean isServerConnection() { return false; }
	public boolean isAcceptThreadRunning() { return false; }
	
	public abstract InputStream getInputStream() throws IOException;
	public abstract OutputStream getOutputStream() throws IOException;
	
} // End of class ConnectionObject

class UrlConnectionObject extends ConnectionObject
{
	/**
	 * Initialize the connection object.
	 */
	public ConnectionObject create(String url, MAHandle handle) 
		throws MalformedURLException, IOException
	{
		URL connectionURL = new URL(url);
		URLConnection connection = connectionURL.openConnection();
		connection.setAllowUserInteraction(true);
		connection.setDoInput(true);
		connection.setDoOutput(true);
		connection.setUseCaches(false);
		
		mConnection = connection;
		mHandle = handle;
			
		return this;
	}
	
	/**
	 * Constructor.
	 */
	public UrlConnectionObject()
	{
		// This naming is a bit weird... 
		// Remove the "is" variables.
		mIsHttpConnection = true;
	}
	
	/**
	 * Start executing connection.
	 */
	@Override
	public void startConnectThread()
	{
		mThreadPool.execute(new HttpConnectionConnector(this));
	}
	
	@Override
	public InputStream getInputStream() throws IOException
	{	
		return mConnection.getInputStream();
	}
	
	@Override
	public OutputStream getOutputStream() throws IOException
	{	
		return mConnection.getOutputStream();
	}
} // End of class UrlConnectionObject

class HttpConnectionObject extends ConnectionObject
{
	/**
	 * Initialize the connection object.
	 */
	public ConnectionObject create(String url, int method, MAHandle handle) 
		throws MalformedURLException, IOException
	{
		URL connectionURL = new URL(url);
		URLConnection connection = connectionURL.openConnection();
		connection.setAllowUserInteraction(true);
		connection.setDoInput(true);
		connection.setDoOutput(true);
		connection.setUseCaches(false);
		
		HttpURLConnection httpConnection = (HttpURLConnection) connection;
		
		switch (method) 
		{
			case HTTP_GET:
				httpConnection.setRequestMethod("GET");
				break;
			case HTTP_POST:
				httpConnection.setRequestMethod("POST");
				break;
			case HTTP_HEAD:
				httpConnection.setRequestMethod("HEAD");
				break;
			default:
				BIG_PHAT_ERROR;
		}

		mConnection = connection;
		mHandle = handle;
			
		return this;
	}
	
	/**
	 * Constructor.
	 */
	public HttpConnectionObject()
	{
		mIsHttpConnection = true;
	}
	
	/**
	 * Start executing connection.
	 */
	@Override
	public void startConnectThread()
	{
		mThreadPool.execute(new HttpConnectionFinish(this));
	}
	
	@Override
	public InputStream getInputStream() throws IOException
	{	
		return mConnection.getInputStream();
	}
	
	@Override
	public OutputStream getOutputStream() throws IOException
	{	
		return mConnection.getOutputStream();
	}
} // End of class HttpConnectionObject

class SocketConnectionObject extends ConnectionObject
{
	/**
	 * Initialize the connection object.
	 */
	public ConnectionObject create(String url, MAHandle handle)
		throws MalformedURLException, IOException, Exception
	{
		Log.i("@@@TEST", "Socket url: " + url);
		
		// Restructure the url since port can't be part of it.
		String realUrl = url.substring(9);
		String[] splitUrl = realUrl.split("\\b:\\d{1,5}\\b");

		if (splitUrl.length > 2) 
		{
			throw new MalformedURLException("Malformed URL: " + url);
		}
		
		String newUrl = splitUrl[0];
		int port = 80;
		if (splitUrl.length == 2)
		{
			int end = (splitUrl[0].length() + realUrl.length()) - (splitUrl[0].length() + splitUrl[1].length());
			port = Integer.valueOf(realUrl.substring(splitUrl[0].length() + 1, end)).intValue();
			newUrl += splitUrl[1];
		}
		else 
		{
			port = Integer.valueOf(realUrl.substring(splitUrl[0].length() + 1)).intValue();
		}

		Log.i("@@@TEST", "Socket newUrl: " + newUrl + " port: " + port);
		
		mSocketAddress = newUrl;
		mSocketPort = port;
		mHandle = handle;
			
		return this;
	}
	
	/**
	 * Constructor.
	 */
	private SocketConnectionObject()
	{
		mIsSocketConnection = true;
	}
	
	/**
	 * Start executing connection.
	 */
	@Override
	public void startConnectThread()
	{
		mThreadPool.execute(new HttpConnectionConnector(this));
	}
	
	@Override
	public InputStream getInputStream() throws IOException
	{	
		return mSocket.getInputStream();
	}
	
	@Override
	public OutputStream getOutputStream() throws IOException
	{	
		return mSocket.getOutputStream();
	}
} // End of class SocketConnectionObject

#ifdef _ANDROID_BLUETOOTH

ConnectionObject btCreateBluetoothConnectionObject(String url, MAHandle handle)
	throws MalformedURLException, IOException, Exception
{
	if (url.startsWith("btspp://localhost:")) // Server request
	{
		return new BluetoothServerConnectionObject().create(url, handle);
	}
	else // Client request
	{
		return new BluetoothConnectionObject().create(url, handle);
	}
}

/**
 * Bluetooth connection object. Used for client connections
 * and for server side accepted connections.
 */
class BluetoothConnectionObject extends ConnectionObject
{
	String mDeviceAddress = null;
	int mChannel = 0;
	String mUUID = null;
	BluetoothSocket mSocket = null;
	boolean mIsChannelClientConnectionRequest = false;
	boolean mIsUUIDClientConnectionRequest = false;
	
	/**
	 * Constructor.
	 */
	public BluetoothConnectionObject()
	{
	}
	
	/**
	 * Initialize the connection object with a prefabricated BluetoothSocket.
	 */
	public BluetoothConnectionObject createWithBluetoothSocket(BluetoothSocket socket, MAHandle handle)
	{
		mState |= CONNOP_CONNECT;
		mHandle = handle;
		mSocket = socket;
		networkAddConnectionObject(this);
		
		// Post connect event on this connection handle.
		postResultEvent(CONNOP_CONNECT, CONNOP_CONNECT_SUCCESS);
		
		Log.i("@BluetoothConnectionObject", "createWithBluetoothSocket - done");
		
		return this;
	}
	
	/**
	 * Initialize the connection object.
	 */
	public ConnectionObject create(String url, MAHandle handle)
		throws MalformedURLException, IOException, Exception
	{
		// Set the handle for this connection.
		mHandle = handle;
		
		// Get the content part of the url.
		// Strip "btspp://"
		String realUrl = url.substring(8);
		
		// Get the parts separated by the colon.
		String[] splitUrl = realUrl.split(":");
		if (splitUrl.length != 2) 
		{
			throw new MalformedURLException("Malformed URL: " + url);
		}
		
		String part1 = splitUrl[0];
		String part2 = splitUrl[1];
			
		// Format device address for use with the Android API.
		mDeviceAddress = part1;
		
		// Is it a channel number?
		// Note we now use a regexp that will allow higher channel numbers.
		// TODO: Proper regexp to use when implementation is done is: "\\b[0123]{1,2}\\b"
		if (part2.matches("\\b[0123456789]{1,5}\\b"))
		{
			mIsChannelClientConnectionRequest = true;
			mChannel = Integer.parseInt(part2);
		}
		// Is it a service record UUID?
		else if (part2.matches("\\b[0123456789ABCDEFabcdef]{32}\\b"))
		{
			mIsUUIDClientConnectionRequest = true;
			mUUID = part2;
		}
		else 
		{
			throw new MalformedURLException("Malformed URL: " + url);
		}
		
		Log.i("@BluetoothConnectionObject", "mDeviceAddress = " + mDeviceAddress);
		Log.i("@BluetoothConnectionObject", "mChannel = " + mChannel);
		Log.i("@BluetoothConnectionObject", "mUUID = " + mUUID);
			
		return this;
	}
	
	@Override
	public void close() throws IOException
	{
		super.close();
		
		if (null != mSocket)
		{
			mSocket.close();
			mSocket = null;
		}
	}
	
	@Override
	public InputStream getInputStream() throws IOException
	{	
		return mSocket.getInputStream();
	}
	
	@Override
	public OutputStream getOutputStream() throws IOException
	{	
		return mSocket.getOutputStream();
	}
	
	/**
	 * Start executing connection.
	 */
	@Override
	public void startConnectThread()
	{
		Log.i("@@@ BluetoothConnectionObject", "startConnectThread");
		
		mThreadPool.execute(new Runnable()
		{
			public void run()
			{
				try 
				{
					// Make this thread a looper thread if there is no associated looper.
					// TODO: Do we need to be a looper thread here?
					if (null == Looper.myLooper())
					{
						Looper.prepare();
					}
					
					doConnect();
				}
				catch (Throwable e)
				{
					e.printStackTrace();
				}
			}
		});
	}
	
	public void doConnect()
	{
		Log.i("@@BluetoothConnectionObject", "doConnect");
			
		try
		{
			BluetoothAdapter adapter = btGetBluetoothAdapter();
			if (null == adapter)
			{
				Log.i("@@BluetoothConnectionObject", "Bluetooth adapter not found");
				postResultEvent(CONNOP_CONNECT, CONNERR_UNAVAILABLE);
				return;
			}
			Log.i("@@BluetoothConnectionObject", "Bluetooth adapter FOUND");
			
			BluetoothDevice device = btGetBluetoothDevice(mDeviceAddress);
			if (null == device)
			{
				Log.i("@@BluetoothConnectionObject", "Device not found at address: " + mDeviceAddress);
				postResultEvent(CONNOP_CONNECT, CONNERR_GENERIC);
				return;
			}
			
			Log.i("@@BluetoothConnectionObject", "probe x");
				
			if (mIsChannelClientConnectionRequest)
			{
				Log.i("@@BluetoothConnectionObject", "mIsChannelClientConnectionRequest");
				
				// Use undocumented method via reflection to connect to a channel.
				Method createRfcommSocket = device.getClass().getMethod(
					"createRfcommSocket", 
					new Class[] { int.class });
				if (null == createRfcommSocket)
				{
					Log.i("@@BluetoothConnectionObject", "Could not find method createRfcommSocket");
					postResultEvent(CONNOP_CONNECT, CONNERR_GENERIC);
					return;
				}
				
				mSocket = (BluetoothSocket) createRfcommSocket.invoke(device, mChannel);
				if (null == mSocket)
				{
					Log.i("@@BluetoothConnectionObject", "Could not create socket via createRfcommSocket");
					postResultEvent(CONNOP_CONNECT, CONNERR_GENERIC);
					return;
				}
			}
			else if (mIsUUIDClientConnectionRequest)
			{
				Log.i("@@BluetoothConnectionObject", "mIsUUIDClientConnectionRequest");
				String uuid = btFormatServiceUUID(mUUID);
				Log.i("@@BluetoothConnectionObject", "Connecting to service uuid: " + uuid);
				mSocket = device.createRfcommSocketToServiceRecord(
					java.util.UUID.fromString(uuid)
				);
				if (null == mSocket)
				{
					Log.i("@@BluetoothConnectionObject", "No socket created via createRfcommSocketToServiceRecord");
					postResultEvent(CONNOP_CONNECT, CONNERR_GENERIC);
					return;
				}
			}
			
			Log.i("@@BluetoothConnectionObject", "connect 1");
			mSocket.connect();
			Log.i("@@BluetoothConnectionObject", "connect 2");
				
			postResultEvent(CONNOP_CONNECT, CONNOP_CONNECT_SUCCESS);
		}
		catch (InterruptedIOException e)
		{
			Log.i("@@BluetoothConnectionObject", "InterruptedIOException " + e);
			e.printStackTrace();
			postResultEvent(CONNOP_CONNECT, CONNERR_CANCELED);
			return;
		}
		catch (IOException e)
		{
			Log.i("@@BluetoothConnectionObject", "IOException " + e);
			e.printStackTrace();
			postResultEvent(CONNOP_CONNECT, CONNERR_GENERIC);
			return;
		}
		catch (Exception e)
		{
			Log.i("@@BluetoothConnectionObject", "Exception " + e);
			e.printStackTrace();
			postResultEvent(CONNOP_CONNECT, CONNERR_GENERIC);
			return;
		}
	}
} // End of class BluetoothConnectionObject

/**
 * Bluetooth server object.
 */
class BluetoothServerConnectionObject extends ConnectionObject
{
	String mServiceName = null;
	String mUUID = null;
	BluetoothServerSocket mServerSocket = null;
	boolean mAcceptThreadRunning = false;
	
	/**
	 * Constructor.
	 */
	public BluetoothServerConnectionObject()
	{
	}
	
	public boolean isServerConnection() { return true; }
	
	public boolean isAcceptThreadRunning() { return mAcceptThreadRunning; }
	
	/**
	 * Initialize the connection object.
	 */
	public ConnectionObject create(String url, MAHandle handle)
		throws MalformedURLException, IOException, Exception
	{
		// Set the handle for this connection.
		mHandle = handle;
		
		// Example of server connection url: 
		// btspp://localhost:0000110100001000800000805F9B34FB;name=My Service
		
		// Strip "btspp://localhost:"
		String realUrl = url.substring(18);
		
		// Split into uuid part and name part.
		String[] splitUrl = realUrl.split(";name=");
		
		// Set UUID.
		mUUID = splitUrl[0];
		
		// Set service name.
		if (splitUrl.length == 2)
		{
			mServiceName = splitUrl[1];
		}
		
		Log.i("@BT", "realServerUrl = " + realUrl);
		Log.i("@BT", "splitUrl = " + splitUrl);
		Log.i("@BT", "splitUrl.length = " + splitUrl.length);
		Log.i("@BT", "mServiceName = " + mServiceName);
		Log.i("@BT", "mUUID = " + mUUID);
			
		return this;
	}
	
	@Override
	public void close() throws IOException
	{
		if (null != mServerSocket)
		{
			// This should also terminate any ongoing accept and terminate its thread.
			mServerSocket.close();
			mServerSocket = null;
		}
	}
	
	@Override
	public InputStream getInputStream() throws IOException
	{	
		return null;
	}
	
	@Override
	public OutputStream getOutputStream() throws IOException
	{	
		return null;
	}
	
	@Override
	public void connect()
	{
		// We do NOT spawn a thread here. That is done via maAccept.
		
		mState |= CONNOP_CONNECT;
		networkAddConnectionObject(this);
		postResultEvent(CONNOP_CONNECT, CONNOP_CONNECT_SUCCESS);
	}
	
	/**
	 * Spawn accept thread.
	 */
	@Override
	public void startAcceptThread()
	{
		Log.i("@@@ BluetoothServerConnectionObject", "startAcceptThread");
		
		mThreadPool.execute(new Runnable()
		{
			public void run()
			{
				mAcceptThreadRunning = true;
				
				try 
				{
					// Make this thread a looper thread if there is no associated looper.
					if (null == Looper.myLooper())
					{
						Looper.prepare();
					}
					
					doAccept();
				}
				catch (Throwable e)
				{
					e.printStackTrace();
				}
				finally
				{
					mAcceptThreadRunning = false;
				}
			}
		});
	}
	
	public void doAccept()
	{
		Log.i("@@BluetoothServerConnectionObject", "doAccept");
		
		try
		{
			mState |= CONNOP_ACCEPT;
			
			BluetoothAdapter adapter = btGetBluetoothAdapter();
			if (null == adapter)
			{
				Log.i("@@BluetoothServerConnectionObject", "Bluetooth adapter not found");
				postResultEvent(CONNOP_ACCEPT, CONNERR_UNAVAILABLE);
				return;
			}
			
			// Create server socket.
			BluetoothServerSocket mServerSocket = adapter.listenUsingRfcommWithServiceRecord(
				mServiceName, 
				UUID.fromString(btFormatServiceUUID(mUUID)));
				
			Log.i("@@BluetoothServerConnectionObject", "doAccept - blocking");
			
			// Accept. Will block. Terminate by calling close on the server socket.
			BluetoothSocket socket = mServerSocket.accept();
			
			Log.i("@@BluetoothServerConnectionObject", "doAccept - socket accepted");
			
			// Write mock data for testing.
			//socket.getOutputStream().write("Hej hopp!!!".getBytes());
			//socket.getOutputStream().flush();
			
			Log.i("@@BluetoothServerConnectionObject", "test data written to socket");
			
			// Have we reached max number of connection handles?
			if (networkIsMaxNumberOfConnectionsReached())
			{
				postResultEvent(CONNOP_ACCEPT, CONNERR_MAX);
				return;
			}
			
			// Get new connection handle.
			MAHandle newConnHandle = networkGetNextConnectionHandle();;
			
			Log.i("@@BluetoothServerConnectionObject", "doAccept - create BluetoothConnectionObject");
			
			// Create new connection object.
			BluetoothConnectionObject connObj = new BluetoothConnectionObject()
				.createWithBluetoothSocket(socket, newConnHandle);
			
			Log.i("@@BluetoothServerConnectionObject", "doAccept - post event");
			
			// Post result event on server handle.
			postResultEvent(CONNOP_ACCEPT, newConnHandle);
			
			Log.i("@@BluetoothServerConnectionObject", "doAccept - done");
		}
		catch (InterruptedIOException e)
		{
			Log.i("@@BluetoothServerConnectionObject", "InterruptedIOException " + e);
			e.printStackTrace();
			postResultEvent(CONNOP_ACCEPT, CONNERR_CANCELED);
			return;
		}
		catch (IOException e)
		{
			Log.i("@@BluetoothServerConnectionObject", "IOException " + e);
			e.printStackTrace();
			postResultEvent(CONNOP_ACCEPT, CONNERR_GENERIC);
			return;
		}
		catch (Exception e)
		{
			Log.i("@@BluetoothServerConnectionObject", "Exception " + e);
			e.printStackTrace();
			postResultEvent(CONNOP_ACCEPT, CONNERR_GENERIC);
			return;
		}
	}
} // End of class BluetoothServerConnectionObject

#endif // _ANDROID_BLUETOOTH

class HttpConnectionConnector implements Runnable 
{
	ConnectionObject mConn;

	HttpConnectionConnector(ConnectionObject conn) 
	{
		mConn = conn;
	}

	public final void run()
	{
		try
		{
			int result = 1;
			if (mConn.mIsHttpConnection)
			{
				mConn.mConnection.connect();
			
				HttpURLConnection http = (HttpURLConnection) mConn.mConnection;
				
				result = http.getResponseCode();
				if (result <= 0)
				{
					DUMP(result);
					result = CONNERR_PROTOCOL;
				}
				else
				{
#ifndef PHONE_RELEASE
					//dump headers
					int i = 0;
					while (true)
					{
						String key = mConn.mConnection.getHeaderFieldKey(i);
						String value = mConn.mConnection.getHeaderField(i);
						DEBUG_ALWAYS(key + ": " + value + "\n");
						if(key == null && value == null)
						{
							break;
						}
						i++;
					}
#endif
					mConn.mHttpState = HTTP_STATE_FINISHED;
				}
			}
			if (mConn.mIsSocketConnection)
			{
				Log.i("Connector","connection to socket");
				mConn.mSocket = new Socket(mConn.mSocketAddress, mConn.mSocketPort);
				Log.i("Connector","connection returned");
				
				if (mConn.mSocket.isConnected())
				{
					mConn.mHttpState = HTTP_STATE_FINISHED;
				}
				else
				{
					result = CONNERR_GENERIC;
				}
			}
			synchronized(mConn) 
			{
				if (mConn.mCancelled) 
				{
					mConn.postResultEvent(CONNOP_CONNECT, CONNERR_CANCELED);
					return;
				}
			}
			mConn.postResultEvent(CONNOP_CONNECT, result);
		}
		catch (InterruptedIOException e)
		{
			PRINT_STACK_TRACE;
			mConn.postResultEvent(CONNOP_CONNECT, CONNERR_CANCELED);
			return;
		}
		catch (IOException e)
		{
			PRINT_STACK_TRACE;
			mConn.postResultEvent(CONNOP_CONNECT, CONNERR_GENERIC);
			return;
		}
	}
}

/**
 * Class that reads or writes data. 
 * TODO: It should be renamed, because it is a general class
 * used for all connection types.
 * Make two methods from this class in ConnectionObject:
 * doRead and doWrite, and call from thread (Runnable anon class).
 */
class HttpConnectionRunner implements Runnable 
{
	ConnectionObject mConn;

	HttpConnectionRunner(ConnectionObject conn)
	{
		mConn = conn;
	}

	public final void run() 
	{
		int opType = -1;
		try
		{
			if (mConn.mReadData == true) // Read data
			{
				int result = -1;
				int opResult;
				opType = CONNOP_READ;
				
				Log.i("HttpConnectionRunner", "Read num bytes: " + mConn.mSize);
				
				byte[] bytes = new byte[mConn.mSize];
				result = mConn.getInputStream().read(bytes);
				
				Log.i("HttpConnectionRunner", "Read result: " + result);
				
				if (mConn.mUseResource == true) // store in resource 
				{
					Log.i("HttpConnectionRunner", "Read to resource");
					
					// READ DATA DIRECTLY INTO A RESOURCE

					mConn.mByteBuffer.position(0);
					mConn.mByteBuffer.put(bytes, 0, result);
				
					//result = mConn.getInputStream().read(mConn.mBinary.arr, mConn.mOffset, mConn.mSize);
				}
				else // store in memory
				{
					Log.i("HttpConnectionRunner", "Read to memory");
					
					if (result > 0)
					{
						// WRITE THE DATA IN BUFFER bytes TO MEMORY AT ADDRESS mConn.mMemory
						
						mMemDataSection.mark();
						mMemDataSection.position((int)mConn.mMemory);
						mMemDataSection.put(bytes, 0, result);
						mMemDataSection.reset();
						
						opResult = result;
					}
				}
				
				// success
				if (result > 0)
				{
					opResult = result;
				}
				else if (result == -1) 
				{
					opResult = CONNERR_CLOSED;
				} 
				else 
				{
					DEBUG_ALWAYS("ConnRead error "+result+"!\n");
					opResult = CONNERR_INTERNAL;
				}
				
				/*
					Restore resource from flux
				*/
				//setResource(mConn.mData, mConn.mBinary);
				
				mConn.postResultEvent(opType, opResult);
				return;
			}
			else // Write data
			{
				opType = CONNOP_WRITE;
				if (mConn.mUseResource == true) // resource
				{
					Log.i("HttpConnectionRunner","Send from resource");
					/*
					if(mConn.mBinary instanceof Binary) {
						Binary bin = (Binary)mConn.mBinary;
						
						mConn.getOutputStream().write(bin.arr, mConn.mOffset, mConn.mSize);
					} else {
						byte[] buffer = new byte[mConn.mSize];
						DataInputStream dis = new DataInputStream(mConn.mBinary.getInputStream());
						dis.readFully(buffer);
						dis.close();
						
						mConn.getOutputStream().write(buffer);
					}
					*/
					
					// WRITE DATA DIRECTLY TO THE STREAM FROM mConn.ByteBuffer
					
				}
				else // memory
				{
					Log.i("HttpConnectionRunner", "Send from memory");
					SYSLOG("memstart:" + (int)mConn.mMemory + " size:" + mConn.mSize + " datasize:" + mMemDataSection.capacity());
					
					// WRITE DATA DIRECTLY TO THE STREAM FROM memory at position mConn.mMemory
					
					byte[] data = new byte[mConn.mSize];
					mMemDataSection.mark();
					mMemDataSection.position((int)mConn.mMemory);
					mMemDataSection.get(data);
					mMemDataSection.reset();
					
					Log.i("HttpConnectionRunner", "Writing data: " + new String(data));
					mConn.getOutputStream().write(data);
					
					//readMemStream(mConn.getOutputStream(), mConn.mMemory, mConn.mSize);
				}
				
				//success
				
				/*
					Restore resource from flux
				*/
				//setResource(mConn.mData, mConn.mBinary);
				
				mConn.postResultEvent(opType, 1);
				return;
			}	
		}
		catch (InterruptedIOException e)
		{
			SYSLOG("InterruptedIOException e:" + e.toString());
			PRINT_STACK_TRACE;
			mConn.postResultEvent(opType, CONNERR_CANCELED);
			return;
		}
		catch (IOException e)
		{
			SYSLOG("IOException e:" + e.toString());
			PRINT_STACK_TRACE;
			mConn.postResultEvent(opType, CONNERR_GENERIC);
			return;
		}
		catch (Exception e)
		{
			SYSLOG("Exception e:" + e.toString());
			PRINT_STACK_TRACE;
			mConn.postResultEvent(opType, CONNERR_GENERIC);
			return;
		}
	}
}

class HttpConnectionFinish implements Runnable
{
	ConnectionObject mConn;

	HttpConnectionFinish(ConnectionObject conn)
	{
		mConn = conn;
	}

	public final void run() 
	{
		HttpURLConnection httpConn = (HttpURLConnection) mConn.mConnection;
		try 
		{
			if (mConn.getOutputStream() != null) 
			{
				mConn.getOutputStream().close();
			}
			
			int result = httpConn.getResponseCode();
			if (result <= 0) 
			{
				DUMP(result);
				result = CONNERR_PROTOCOL;
			} 
			else 
			{
//#ifndef PHONE_RELEASE
				//dump headers
				int i = 0;
				while (true) 
				{
					String key = mConn.mConnection.getHeaderFieldKey(i);
					String value = mConn.mConnection.getHeaderField(i);
					DEBUG_ALWAYS(key + ": " + value + "\n");
					if (key == null && value == null)
					{
						break;
					}
					i++;
				}
//#endif
				mConn.mHttpState = HTTP_STATE_FINISHED;
			}
			mConn.postResultEvent(CONNOP_FINISH, result);
		} 
		catch (InterruptedIOException e) 
		{
			PRINT_STACK_TRACE;
			mConn.postResultEvent(CONNOP_FINISH, CONNERR_CANCELED);
		} 
		catch (IOException e) 
		{
			PRINT_STACK_TRACE;
			mConn.postResultEvent(CONNOP_FINISH, CONNERR_GENERIC);
		}
	}
}

/*
class SocketConnectionRunner implements Runnable 
{
	ConnectionObject mConn;

	SocketConnectionRunner(ConnectionObject conn)
	{
		mConn = conn;
	}

	public final void run() {

		int opType = -1;
		try
		{
			if(mConn.mReadData == true) // Read data
			{
				int result = -1;
				int opResult;
				opType = CONNOP_READ;
				
				if(mConn.mUseResource == true) // store in resource 
				{
					Log.i("HttpConnectionRunner","Read to resource");
					result = mConn.getInputStream().read(mConn.mBinary.arr, mConn.mOffset, mConn.mSize);
				}
				else // store in memory
				{
					Log.i("HttpConnectionRunner","Read to memory");
					byte[] bytes = new byte[mConn.mSize];
					result = mConn.getInputStream().read(bytes);
					if(result > 0)
					{
						writeMemBytes(mConn.mMemory, bytes, 0, result);
						opResult = result;
					}
				}
				
				// success
				if(result > 0)
				{
					opResult = result;
				}
				else if(result == -1) {
					opResult = CONNERR_CLOSED;
				} else {
					DEBUG_ALWAYS("ConnRead error "+result+"!\n");
					opResult = CONNERR_INTERNAL;
				}
				
				setResource(mConn.mData, mConn.mBinary);
				mConn.postResultEvent(opType, opResult);
				return;
			}
			else // Write data
			{
				opType = CONNOP_WRITE;
				if(mConn.mUseResource == true) // resource
				{
					Log.i("HttpConnectionRunner","Send from resource");
					if(mConn.mBinary instanceof Binary) {
						Binary bin = (Binary)mConn.mBinary;
						mConn.getOutputStream().write(bin.arr, mConn.mOffset, mConn.mSize);
					} else {
						byte[] buffer = new byte[mConn.mSize];
						DataInputStream dis = new DataInputStream(mConn.mBinary.getInputStream());
						dis.readFully(buffer);
						dis.close();
						mConn.getOutputStream().write(buffer);
					}
				}
				else // memory
				{
					Log.i("HttpConnectionRunner","Send from memory");
					readMemStream(mConn.getOutputStream(), mConn.mMemory, mConn.mSize);
				}
				
				//success
				setResource(mConn.mData, mConn.mBinary);
				mConn.postResultEvent(opType, 1);
				return;
			}	
		}
		catch(InterruptedIOException e)
		{
			PRINT_STACK_TRACE;
			mConn.postResultEvent(opType, CONNERR_CANCELED);
			return;
		}
		catch(IOException e)
		{
			PRINT_STACK_TRACE;
			mConn.postResultEvent(opType, CONNERR_GENERIC);
			return;
		}
		
	}
}
*/

/* 
Old code that is moved to class BluetoothCOnnectionObject.

TODO: Delete this commented out code when implementation is tested.
 
class BluetoothConnectionConnector implements Runnable 
{
	BluetoothConnectionObject mConnObj;

	BluetoothConnectionConnector(BluetoothConnectionObject connObj) 
	{
		mConnObj = connObj;
	}

	public void run()
	{
		try
		{
			String address = mConnObj.mAddress;
			BluetoothAdapter adapter = btGetBluetoothAdapter();
			if (null == adapter)
			{
				mConnObj.postResultEvent(CONNOP_CONNECT, CONNERR_GENERIC);
				return;
			}
			BluetoothDevice device = btGetBluetoothAdapter().getRemoteDevice(address);
			if (null == device)
			{
				mConnObj.postResultEvent(CONNOP_CONNECT, CONNERR_GENERIC);
				return;
			}
			
			Method createRfcommSocket = device.getClass().getMethod(
				"createRfcommSocket", 
				new Class[] { int.class });
			if (null == createRfcommSocket)
			{
				mConnObj.postResultEvent(CONNOP_CONNECT, CONNERR_GENERIC);
				return;
			}
			
			BluetoothSocket socket = (BluetoothSocket) createRfcommSocket.invoke(
				device, 
				mConnObj.mChannel);
			if (null == socket)
			{
				mConnObj.postResultEvent(CONNOP_CONNECT, CONNERR_GENERIC);
				return;
			}
			
			socket.connect();
			
			mConnObj.mSocket = socket;
			
			Log.i("@@BluetoothConnectionConnector","connection to Bluetooth socket made");
			
			int success = 1;
			mConnObj.postResultEvent(CONNOP_CONNECT, success);
		}
		catch (InterruptedIOException e)
		{
			PRINT_STACK_TRACE;
			mConnObj.postResultEvent(CONNOP_CONNECT, CONNERR_CANCELED);
			return;
		}
		catch (IOException e)
		{
			PRINT_STACK_TRACE;
			mConnObj.postResultEvent(CONNOP_CONNECT, CONNERR_GENERIC);
			return;
		}
		catch (Exception e)
		{
			PRINT_STACK_TRACE;
			mConnObj.postResultEvent(CONNOP_CONNECT, CONNERR_GENERIC);
			return;
		}
	}
}
*/


