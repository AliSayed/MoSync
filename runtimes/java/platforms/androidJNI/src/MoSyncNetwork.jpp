/* Copyright (C) 2009 Mobile Sorcery AB

This program is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License, version 2, as published by
the Free Software Foundation.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
for more details.

You should have received a copy of the GNU General Public License
along with this program; see the file COPYING.  If not, write to the Free
Software Foundation, 59 Temple Place - Suite 330, Boston, MA
02111-1307, USA.
*/

#define HTTP_STATE_NULL 0
#define HTTP_STATE_SETUP 1
#define HTTP_STATE_WRITING 2
#define HTTP_STATE_FINISHING 3
#define HTTP_STATE_FINISHED 4

/*
* The hashtable mConnections is used to keep all the open connections.
*/
Hashtable<Integer, ConnectionInformation> mConnections = new Hashtable<Integer, ConnectionInformation>();

/**
 * Connection handle counter.
 */
int mConnNextHandle = 1;

/**
 * Thread pool for network operations.
 * TODO: Perhaps rename to mNetworkThreadPool or something
 * to make the use explicit from the name.
 */
ThreadPool mThreadPool = new ThreadPool();

/**
* Initiates a connection and if successfull, adds the new connection to the table of open connections
*
* @param url	The URL to which the connection should be established.
				URLs that starts with "socket://" needs to have a port specified.
				URLs that starts with "btspp://" tries to connect to a bluetooth port.
*
* @return CONNERR_URL if the URL wasn't correct.
          CONNERR_GENERIC on other errors.
* 		  > 0 on success. This number is the handle to the opened connection.
*/
MAHandle maConnect(final String url) 
{
	Log.i("MoSyncSyscall","maConnect");
	Log.i("maConnect", "url:" + url);

	try
	{
		ConnectionInformation connectionInfo;
		
		if (url.startsWith("socket://"))
		{
			connectionInfo = new SocketConnectionInformation().create(url, mConnNextHandle);
		}	
		else if (url.startsWith("btspp://"))
		{
#ifdef _ANDROID_BLUETOOTH		
			connectionInfo = new BluetoothConnectionInformation().create(url, mConnNextHandle);
#else
			throw new Exception("Bluetooth not supported!");
#endif // _ANDROID_BLUETOOTH
		}
		else
		{
			connectionInfo = new UrlConnectionInformation().create(url, mConnNextHandle);
		}
		
		mConnections.put(mConnNextHandle, connectionInfo);
		
		connectionInfo.mState |= CONNOP_CONNECT;
		
		Log.i("@@@ maConnect", "connectionInfo.startConnectThread");
		
		connectionInfo.startConnectThread();
	}
	catch (MalformedURLException e)
	{
		SYSLOG("MalformedURLException: " + e.toString());
		e.printStackTrace();
		return CONNERR_URL;
	}
	catch (IOException e)
	{
		SYSLOG("IOException: " + e.toString());
		e.printStackTrace();
		return CONNERR_GENERIC;
	}
	catch (Exception e)
	{
		SYSLOG("Exception: " + e.toString());
		e.printStackTrace();
		return CONNERR_GENERIC;
	}

	// Return current handle value and increment.
	return mConnNextHandle++;
}

/**
*
*/
int maConnGetAddr(MAHandle conn, long addr) throws Exception {
	Log.i("MoSyncSyscall","maConnect");
	/* FIX-ME */
	return -1;
}

/**
* Close a connection.
*/
void maConnClose(MAHandle conn) throws Exception 
{
	Log.i("MoSyncSyscall","maConnClose");
	ConnectionInformation connectionInfo = mConnections.get(conn);
	connectionInfo.close();
	mConnections.remove(conn);
}

void maConnRead(MAHandle conn, int dst, int size) 
{
	Log.i(
		"@MoSyncSyscall",
		"maConnRead" + " conn:" + conn + " dst:" + dst + " size:" + size);
	SYSLOG("conn:" + conn + " dst:" + dst + " size:" + size);
	
	MYASSERT(size > 0);
	
	ConnectionInformation connectionInfo = mConnections.get(conn);
	connectionInfo.read(dst, size);
}

void maConnWrite(MAHandle conn, int src, int size) throws IOException 
{
	Log.i("MoSyncSyscall","maConnWrite");
	SYSLOG("conn:" + conn + " src:" + src + " size:" + size);
	
	MYASSERT(size > 0);
	
	ConnectionInformation connectionInfo = mConnections.get(conn);
	connectionInfo.write(src, size);
}

void maConnReadToData(MAHandle conn, MAHandle data, int offset, int size) 
{
	Log.i("MoSyncSyscall","maConnReadToData");

	MYASSERT(offset >= 0);
	MYASSERT(size > 0);
	MYASSERT(offset + size > 0);
	
	ConnectionInformation connectionInfo = mConnections.get(conn);
	connectionInfo.readToData(data, offset, size);
}

void maConnWriteFromData(MAHandle conn, MAHandle data, int offset, int size) 
	throws IOException 
{
	Log.i("MoSyncSyscall","maConnReadFromData");

	MYASSERT(offset >= 0);
	MYASSERT(size > 0);
	MYASSERT(offset + size > 0);

	ConnectionInformation connectionInfo = mConnections.get(conn);
	connectionInfo.writeFromData(data, offset, size);
}

MAHandle maHttpCreate(String url, int method) throws Exception
{
	Log.i("MoSyncSyscall","URLConnectionTask - maHttpCreate");
	try
	{
		ConnectionInformation connectionInfo = 
			new HttpConnectionInformation().create(url, method, mConnNextHandle);
		DEBUG_ASSERT(connectionInfo.mHttpState == HTTP_STATE_NULL);
		connectionInfo.mHttpState = HTTP_STATE_SETUP;
		mConnections.put(mConnNextHandle, connectionInfo);
	}
	catch (MalformedURLException e)
	{
		PRINT_STACK_TRACE;
		return CONNERR_URL;
	}
	catch (IOException e)
	{
		PRINT_STACK_TRACE;
		return CONNERR_GENERIC;
	}
	catch (Exception e)
	{
		PRINT_STACK_TRACE;
		return CONNERR_GENERIC;
	}
	
	return mConnNextHandle++;
}

void maHttpSetRequestHeader(MAHandle conn, String key, String value)
	throws Exception
{
	Log.i("MoSyncSyscall","URLConnectionTask - maHttpSetRequestHeader");

	ConnectionInformation connectionInfo = mConnections.get(conn);
	connectionInfo.setRequestProperty(key, value);
}

int maHttpGetResponseHeader(MAHandle conn, String key, long address, int bufSize)
	throws Exception
{
	Log.i("MoSyncSyscall","URLConnectionTask - maHttpGetResponseHeader");
	
	ConnectionInformation connectionInfo = mConnections.get(conn);
	return connectionInfo.getResponseHeader(key, address, bufSize);
}

void maHttpFinish(MAHandle conn)
{
	Log.i("MoSyncSyscall","URLConnectionTask - maHttpFinish");
	
	ConnectionInformation connectionInfo = mConnections.get(conn);
	
	MYASSERT(connectionInfo.mState == 0);
	MYASSERT(connectionInfo.mHttpState == HTTP_STATE_SETUP || connectionInfo.mHttpState == HTTP_STATE_WRITING);

	connectionInfo.mState = CONNOP_FINISH;
	connectionInfo.mHttpState = HTTP_STATE_FINISHING;
	connectionInfo.mMoSyncThread = this;
	
	connectionInfo.startConnectThread();
}

int maAccept(int serverHandle)
{
	Log.i("@@ NetworkSyscall", "maAccept");
	return -1;
}

public abstract class ConnectionInformation
{
	public ByteBuffer mByteBuffer;
	public long mMemory;
	public int mOffset;
	public int mSize;
	public URLConnection mConnection;
	public Socket mSocket;
	public boolean mReadData;
	public boolean mUseResource;
	public int mState;
	public int mHttpState;
	public boolean mCancelled;
	public boolean mIsHttpConnection;
	public boolean mIsSocketConnection;
	//public boolean mIsBluetoothConnection;
	protected MAHandle mHandle;
	public InputStream mIs;
	public OutputStream mOs;
	public MAHandle mData;
	public Thread mMoSyncThread;
	public String mSocketAddress;
	public int mSocketPort;
	
	public ConnectionInformation()
	{
		mState = 0;
		mHttpState = HTTP_STATE_NULL;
		mCancelled = false;
		mIsHttpConnection = false;
		mIsSocketConnection = false;
		mMoSyncThread = MoSyncThread.this;
	}
	
	public void postResultEvent(int opType, int result) 
	{
		Log.i("ConnectionInformation.postResultEvent", "handle: " + mHandle + " opType: " + opType + " result: " + result);

		MYASSERT((mState & opType) != 0);
		mState &= ~opType;

		int[] event = new int[4];
		event[0] = EVENT_TYPE_CONN;
		event[1] = mHandle;
		event[2] = opType;
		event[3] = result;
		
		Log.i("ConnectionInformation.postResultEvent", "Calling nativePostEvent");
		nativePostEvent(event);
		
		Log.i("ConnectionInformation.postResultEvent", "Calling interrupt");
		mMoSyncThread.interrupt();
	}
	
	// TODO: Why synchronized? And need we not synchronize reading and writing?
	// Or mark a connection as beeing in use when a thread operates on it?
	public synchronized void close() throws IOException
	{
		mCancelled = true;
		if (mIs != null)
		{
			mIs.close();
		}
		if (mOs != null)
		{
			mOs.close();
		}
		mConnection = null;
	}
	
	public void read(int dst, int size)
	{
		mMemory = dst;
		mSize = size;
		mReadData = true;
		mUseResource = false;
		
		try
		{
			mIs = getInputStream();
			MYASSERT(mIs != null);
		}
		catch (IOException e)
		{
			PRINT_STACK_TRACE;
		}
		
		MYASSERT((mState & CONNOP_READ) == 0);
		
		mState |= CONNOP_READ;
		mMoSyncThread = MoSyncThread.this;
		
		mThreadPool.execute(new HttpConnectionRunner(this));
	}
	
	public void write(int src, int size)
	{
		mMemory = src;
		mSize = size;
		mReadData = false;
		mUseResource = false;
		
		try
		{
			mOs = getOutputStream();
			MYASSERT(mOs != null);
		}
		catch(IOException e)
		{
			PRINT_STACK_TRACE;
		}
		
		MYASSERT((mState & CONNOP_WRITE) == 0);
		
		// HTTP_STATE_WRITING is never really used. 
		// We do not need to set it. 
		// TODO: Remove it altogether.
		/*
		if (connectionInfo.mIsHttpConnection == true) 
		{
			HttpURLConnection httpConn = (HttpURLConnection) connectionInfo.mConnection;
			
			if (httpConn.getRequestMethod().equals("POST") && 
				connectionInfo.mHttpState == HTTP_STATE_SETUP) 
			{
				connectionInfo.mHttpState = HTTP_STATE_WRITING;
			}
		}
		else if (connectionInfo.mIsSocketConnection == true) 
		{
			if(connectionInfo.mHttpState == HTTP_STATE_SETUP)
				connectionInfo.mHttpState = HTTP_STATE_WRITING;
		}
		*/
		
		mState |= CONNOP_WRITE;
		mMoSyncThread = MoSyncThread.this;
		
		mThreadPool.execute(new HttpConnectionRunner(this));
	}
	
	public void readToData(MAHandle data, int offset, int size)
	{
	/*
		Binary binaryResource = (Binary)getResource(data);
		MYASSERT(binaryResource.size() >= offset + size);
	*/
		ByteBuffer byteBuffer = (ByteBuffer) mBinaryResources.get(data);
		if (null == byteBuffer) 
		{
			BIG_PHAT_ERROR;
		}

		mData = data;
		//mBinary = binaryResource;
		mByteBuffer = byteBuffer;
		mOffset = offset;
		mSize = size;
		mReadData = true;
		mUseResource = true;
		
		try
		{
			mIs = getInputStream();
			MYASSERT(mIs != null);
		}
		catch(IOException e)
		{
			PRINT_STACK_TRACE;
		}
		
		/*
			The JNI side is responsible for setting the resource in flux
		*/
		//setResource(data, mFlux);
		
		mState |= CONNOP_READ;
		mMoSyncThread = MoSyncThread.this;
		
		mThreadPool.execute(new HttpConnectionRunner(this));
	}
	
	public void writeFromData(MAHandle data, int offset, int size)
	{
	/*
		Binary binaryResource = (Binary)getResource(data);
		MYASSERT(binaryResource.size() >= offset + size);
	*/
		ByteBuffer byteBuffer = (ByteBuffer) mBinaryResources.get(data);
		if (null == byteBuffer) 
		{
			BIG_PHAT_ERROR;
		}
		
		mData = data;
		//mBinary = binaryResource;
		mByteBuffer = byteBuffer;
		mOffset = offset;
		mSize = size;
		mReadData = false;
		mUseResource = true;
		
		try
		{
			mOs = getOutputStream();
			MYASSERT(mOs != null); 	
		}
		catch(IOException e)
		{
			PRINT_STACK_TRACE;
		}
		
		// HTTP_STATE_WRITING is never really used. 
		// We do not need to set it. 
		// TODO: Remove it altogether.
		/*
		MYASSERT((connectionInfo.mState & CONNOP_WRITE) == 0);
		if(connectionInfo.mIsHttpConnection == true) {
			HttpURLConnection httpConn = (HttpURLConnection) connectionInfo.mConnection;
			
			if(httpConn.getRequestMethod().equals("POST") && connectionInfo.mHttpState == HTTP_STATE_SETUP) {
				connectionInfo.mHttpState = HTTP_STATE_WRITING;
			}
		}
		else if(connectionInfo.mIsSocketConnection == true) {
			if(connectionInfo.mHttpState == HTTP_STATE_SETUP)
				connectionInfo.mHttpState = HTTP_STATE_WRITING;
		}
		*/
		
		/*
			The JNI side is responsible for setting the resource in flux
		*/
		//setResource(data, mFlux);
		
		mState |= CONNOP_WRITE;
		mMoSyncThread = MoSyncThread.this;
		
		mThreadPool.execute(new HttpConnectionRunner(this));
	}
	
	public void setRequestProperty(String key, String value)
	{
		MYASSERT(mHttpState == HTTP_STATE_SETUP);
		
		try
		{
			mConnection.setRequestProperty(key, value);
		} 
		catch (IllegalStateException e)
		{
			PRINT_STACK_TRACE;
		} 
		catch (NullPointerException e)
		{
			PRINT_STACK_TRACE;
		}
	}

	public int getResponseHeader(String key, long address, int bufSize)
	{
		try
		{
			String value = mConnection.getHeaderField(key);
			
			if (value == null)
			{
				return CONNERR_NOHEADER;
			}
			
			// Write the bufSize first characters in the String value to ds_mem starting at address
			
			byte[] vstr = value.getBytes();
			
			SYSLOG("value: " + value + " vstr: " + new String(vstr) + " vstr.length: " + vstr.length + "position: " + address);
			
			mMemDataSection.mark();
			mMemDataSection.position((int)address);
			mMemDataSection.put(vstr, 0, vstr.length);
			mMemDataSection.reset();
			
			return vstr.length;
		} 
		catch (IllegalStateException e)
		{
			PRINT_STACK_TRACE;
		} 
		
		return -1;
	}

	public abstract void startConnectThread();
	public abstract InputStream getInputStream() throws IOException;
	public abstract OutputStream getOutputStream() throws IOException;
	
} // End of class ConnectionInformation

class UrlConnectionInformation extends ConnectionInformation
{
	/**
	 * Initialize the connection info object.
	 */
	public ConnectionInformation create(String url, MAHandle handle) 
		throws MalformedURLException, IOException
	{
		URL connectionURL = new URL(url);
		URLConnection connection = connectionURL.openConnection();
		connection.setAllowUserInteraction(true);
		connection.setDoInput(true);
		connection.setDoOutput(true);
		connection.setUseCaches(false);
		
		mConnection = connection;
		mHandle = handle;
			
		return this;
	}
	
	/**
	 * Constructor.
	 */
	public UrlConnectionInformation()
	{
		// This naming is a bit weird... 
		// Remove the "is" variables.
		mIsHttpConnection = true;
	}
	
	/**
	 * Start executing connection.
	 */
	@Override
	public void startConnectThread()
	{
		mThreadPool.execute(new HttpConnectionConnector(this));
	}
	
	@Override
	public InputStream getInputStream() throws IOException
	{	
		return mConnection.getInputStream();
	}
	
	@Override
	public OutputStream getOutputStream() throws IOException
	{	
		return mConnection.getOutputStream();
	}
} // End of class UrlConnectionInformation

class HttpConnectionInformation extends ConnectionInformation
{
	/**
	 * Initialize the connection info object.
	 */
	public ConnectionInformation create(String url, int method, MAHandle handle) 
		throws MalformedURLException, IOException
	{
		URL connectionURL = new URL(url);
		URLConnection connection = connectionURL.openConnection();
		connection.setAllowUserInteraction(true);
		connection.setDoInput(true);
		connection.setDoOutput(true);
		connection.setUseCaches(false);
		
		HttpURLConnection httpConnection = (HttpURLConnection) connection;
		
		switch (method) 
		{
		case HTTP_GET:
			httpConnection.setRequestMethod("GET");
			break;
		case HTTP_POST:
			httpConnection.setRequestMethod("POST");
			break;
		case HTTP_HEAD:
			httpConnection.setRequestMethod("HEAD");
			break;
		default:
			BIG_PHAT_ERROR;
		}

		mConnection = connection;
		mHandle = handle;
			
		return this;
	}
	
	/**
	 * Constructor.
	 */
	public HttpConnectionInformation()
	{
		mIsHttpConnection = true;
	}
	
	/**
	 * Start executing connection.
	 */
	@Override
	public void startConnectThread()
	{
		mThreadPool.execute(new HttpConnectionFinish(this));
	}
	
	@Override
	public InputStream getInputStream() throws IOException
	{	
		return mConnection.getInputStream();
	}
	
	@Override
	public OutputStream getOutputStream() throws IOException
	{	
		return mConnection.getOutputStream();
	}
} // End of class HttpConnectionInformation

class SocketConnectionInformation extends ConnectionInformation
{
	/**
	 * Initialize the connection info object.
	 */
	public ConnectionInformation create(String url, MAHandle handle)
		throws MalformedURLException, IOException, Exception
	{
		Log.i("@@@TEST", "Socket url: " + url);
		
		// Restructure the url since port can't be part of it.
		String realUrl = url.substring(9);
		String[] splitUrl = realUrl.split("\\b:\\d{1,5}\\b");

		if (splitUrl.length > 2) 
		{
			throw new MalformedURLException("Malformed URL: " + url);
		}
		
		String newUrl = splitUrl[0];
		int port = 80;
		if (splitUrl.length == 2)
		{
			int end = (splitUrl[0].length() + realUrl.length()) - (splitUrl[0].length() + splitUrl[1].length());
			port = Integer.valueOf(realUrl.substring(splitUrl[0].length() + 1, end)).intValue();
			newUrl += splitUrl[1];
		}
		else 
		{
			port = Integer.valueOf(realUrl.substring(splitUrl[0].length() + 1)).intValue();
		}

		Log.i("@@@TEST", "Socket newUrl: " + newUrl + " port: " + port);
		
		mSocketAddress = newUrl;
		mSocketPort = port;
		mHandle = handle;
			
		return this;
	}
	
	/**
	 * Constructor.
	 */
	private SocketConnectionInformation()
	{
		mIsSocketConnection = true;
	}
	
	/**
	 * Start executing connection.
	 */
	@Override
	public void startConnectThread()
	{
		mThreadPool.execute(new HttpConnectionConnector(this));
	}
	
	@Override
	public InputStream getInputStream() throws IOException
	{	
		return mSocket.getInputStream();
	}
	
	@Override
	public OutputStream getOutputStream() throws IOException
	{	
		return mSocket.getOutputStream();
	}
} // End of class SocketConnectionInformation

#ifdef _ANDROID_BLUETOOTH
class BluetoothConnectionInformation extends ConnectionInformation
{
	private String mDeviceAddress;
	private int mChannel;
	private String mUUID;
	private BluetoothSocket mSocket;
	private boolean mIsServerConnectionRequest = false;
	private boolean mIsChannelClientConnectionRequest = false;
	private boolean mIsUUIDClientConnectionRequest = false;
	
	/**
	 * Constructor.
	 */
	public BluetoothConnectionInformation()
	{
	}
	
	/**
	 * Initialize the connection info object.
	 */
	public ConnectionInformation create(String url, MAHandle handle)
		throws MalformedURLException, IOException, Exception
	{
		mDeviceAddress = null;
		mChannel = 0;
		mUUID = null;
		
		// Get the device address and the channel.
		String realUrl = url.substring(8);
		
		Log.i("@BT", "realUrl=" + realUrl);
		
		// Get the parts separated by the colon.
		String[] splitUrl = realUrl.split(":");
		if (splitUrl.length != 2) 
		{
			Log.e("@BT", "Malformed URL: " + url);
			throw new MalformedURLException("Malformed URL: " + url);
		}
		
		String part1 = splitUrl[0];
		String part2 = splitUrl[1];
		
		Log.i("@BT", "part1=" + part1);
		Log.i("@BT", "part2=" + part2);
			
		// If the address part is "localhost" it is a server connection.
		// Note that we have uppercased the data in the url.
		// Example: btspp://localhost:0000110100001000800000805F9B34FB;name=Serial Port
		if (part1.equals("localhost")) // Server connection
		{
			Log.i("@BT", "BT SERVER URL DETECTED");
			
			mIsServerConnectionRequest = true;
			
			// Split into uuid part and name part.
			String[] uuidAndName = part2.split(";name=");
			Log.i("@BT", "uuidAndName.length=" + uuidAndName.length);
			Log.i("@BT", "uuidAndName[0]=" + uuidAndName[0]);
			if (uuidAndName.length == 2)
			{
				Log.i("@BT", "uuidAndName[1]=" + uuidAndName[1]);
			}
			mUUID = btFormatServiceUUID(uuidAndName[0]);
			// TODO: Add support for service name.
		}
		else // Client connection
		{
			Log.i("@BT", "BT CLIENT URL DETECTED");
			
			// Format device address for use with the Android API.
			mDeviceAddress = btFormatDeviceAddress(part1);
			
			// Is it a channel number?
			// Note we now use a regexp that will allow higher channel numbers.
			// TODO: Proper regexp to use when implementation is done is: "\\b[0123]{1,2}\\b"
			if (part2.matches("\\b[0123456789]{1,5}\\b"))
			{
				mIsChannelClientConnectionRequest = true;
				mChannel = Integer.parseInt(part2);
			}
			// Is it a service record UUID?
			else if (part2.matches("\\b[0123456789ABCDEFabcdef]{32}\\b"))
			{
				mIsUUIDClientConnectionRequest = true;
				mUUID = btFormatServiceUUID(part2);
			}
			else 
			{
				Log.e("@BT", "Malformed URL: " + url);
				throw new MalformedURLException("Malformed URL: " + url);
			}
		}
		
		// Set the handle for this connection.
		mHandle = handle;
		
		Log.i("@BT", "mDeviceAddress = " + mDeviceAddress);
		Log.i("@BT", "mChannel = " + mChannel);
		Log.i("@BT", "mUUID = " + mUUID);
			
		return this;
	}
	
	@Override
	public void close() throws IOException
	{
		super.close();
		
		if (null != mSocket)
		{
			mSocket.close();
			mSocket = null;
		}
	}
	
	// Mocked data for debugging. Also uncomment connect to run with mock data.
	//String myOutData = "1212121212121212129";
	//ByteArrayInputStream myInputStream = new ByteArrayInputStream(myOutData.getBytes());
	//ByteArrayOutputStream myOutputStream = new ByteArrayOutputStream();
	
	@Override
	public InputStream getInputStream() throws IOException
	{	
		//return myInputStream;
		return mSocket.getInputStream();
	}
	
	
	@Override
	public OutputStream getOutputStream() throws IOException
	{	
		//return myOutputStream;
		return mSocket.getOutputStream();
	}
	
	/**
	 * Return the device address, formatted for use with the Android API.
	 */
	public String getDeviceAddress()
	{
		return mDeviceAddress;
	}
	
	public int getChannel()
	{
		return mChannel;
	}
	
	public BluetoothSocket getSocket()
	{
		return mSocket;
	}
	
	public void setSocket(BluetoothSocket socket)
	{
		mSocket = socket;
	}
	
	/**
	 * Start executing connection.
	 */
	@Override
	public void startConnectThread()
	{
		Log.i("@@@ BluetoothConnectionInformation", "startConnectThread 1");
		
		// TODO: Move this to MoSyncBluetooth and also allow turning on Bluetooth.
		// Move code to turn on Bluetooth to one place in the code.
		mThreadPool.execute(new Runnable()
		{
			public void run()
			{
				try 
				{
					Log.i("@@@ BluetoothConnectionInformation", "startConnectThread 2");
					
					// Make this thread a looper thread if there is no associated looper.
					if (null == Looper.myLooper())
					{
						Looper.prepare();
					}
					//Looper.loop();
					Log.i("@@@ BluetoothConnectionInformation", "startConnectThread 3");
					doConnect();
					Log.i("@@BluetoothConnectionConnector", "===Before Looper.quit");
					Looper.myLooper().quit(); // TODO: Not needed?
					Log.i("@@BluetoothConnectionConnector", "===After Looper.quit");
				}
				catch (Throwable e)
				{
					e.printStackTrace();
				}
			}
		});
		
		Log.i("@@@ BluetoothConnectionInformation", "startConnectThread 4");
	}
	
	public void doConnect()
	{
		Log.i("@@BluetoothConnectionConnector", "doConnect");
			
		try
		{
			String address = getDeviceAddress();
			
			BluetoothAdapter adapter = btGetBluetoothAdapter();
			if (null == adapter)
			{
				Log.i("@@BluetoothConnectionConnector", "Bluetooth adapter not found");
				postResultEvent(CONNOP_CONNECT, CONNERR_UNAVAILABLE);
				return;
			}
			BluetoothDevice device = btGetBluetoothAdapter().getRemoteDevice(address);
			if (null == device)
			{
				Log.i("@@BluetoothConnectionConnector", "Device not found at address: " + address);
				postResultEvent(CONNOP_CONNECT, CONNERR_GENERIC);
				return;
			}
			
			if (mIsServerConnectionRequest)
			{
			// TODO: Implement a structure that holds active servers,
			// map connection handle -> connectioninfo object (we have that
			// already!).
			// Make new class for Bluetooth server connections. Should fit smoothtly
			// into the existing desig.
			// While at it, rename ConnectionInformation to ConnectionObject.
			
			/*
				// Create server socket.
				BluetoothServerSocket serverSocket = 
					adapter.listenUsingRfcommWithServiceRecord("NameOfService", mUUID);
				
				Log.i("@@BluetoothConnectionConnector", "Opening Bluetooth server socket");
				
				socket.connect();
				
				setSocket(socket);
				
				Log.i("@@BluetoothConnectionConnector", "Connection to Bluetooth socket made");
				
				int success = 1;
				postResultEvent(CONNOP_CONNECT, success);
			*/
				postResultEvent(CONNOP_CONNECT, CONNERR_GENERIC);
			}
			else if (mIsChannelClientConnectionRequest)
			{
				Method createRfcommSocket = device.getClass().getMethod(
					"createRfcommSocket", 
					new Class[] { int.class });
				if (null == createRfcommSocket)
				{
					Log.i("@@BluetoothConnectionConnector", "No method createRfcommSocket");
					postResultEvent(CONNOP_CONNECT, CONNERR_GENERIC);
					return;
				}
				
				BluetoothSocket socket = (BluetoothSocket) createRfcommSocket.invoke(
					device, 
					getChannel());
				if (null == socket)
				{
					Log.i("@@BluetoothConnectionConnector", "No socket created");
					postResultEvent(CONNOP_CONNECT, CONNERR_GENERIC);
					return;
				}
				
				Log.i("@@BluetoothConnectionConnector", "Connecting to socket via channel");
				
				socket.connect();
				
				setSocket(socket);
				
				Log.i("@@BluetoothConnectionConnector", "Connection to Bluetooth socket made");
				
				int success = 1;
				postResultEvent(CONNOP_CONNECT, success);
			}
			else if (mIsUUIDClientConnectionRequest)
			{
				BluetoothSocket socket = device.createRfcommSocketToServiceRecord(
					java.util.UUID.fromString(btFormatServiceUUID(mUUID)));
				if (null == socket)
				{
					Log.i("@@BluetoothConnectionConnector", "No socket created");
					postResultEvent(CONNOP_CONNECT, CONNERR_GENERIC);
					return;
				}
				
				Log.i("@@BluetoothConnectionConnector", "Connecting to socket via UUID");
				
				socket.connect();
				
				setSocket(socket);
				
				Log.i("@@BluetoothConnectionConnector", "Connection to Bluetooth socket made");
				
				int success = 1;
				postResultEvent(CONNOP_CONNECT, success);
			}
			else
			{
				Log.i("@@BluetoothConnectionConnector", "Unregocnized Bluetooth connection");
				postResultEvent(CONNOP_CONNECT, CONNERR_GENERIC);
			}
		}
		catch (InterruptedIOException e)
		{
			Log.i("@@BluetoothConnectionConnector", "InterruptedIOException " + e);
			e.printStackTrace();
			PRINT_STACK_TRACE;
			postResultEvent(CONNOP_CONNECT, CONNERR_CANCELED);
			return;
		}
		catch (IOException e)
		{
			Log.i("@@BluetoothConnectionConnector", "IOException " + e);
			e.printStackTrace();
			PRINT_STACK_TRACE;
			postResultEvent(CONNOP_CONNECT, CONNERR_GENERIC);
			return;
		}
		catch (Exception e)
		{
			Log.i("@@BluetoothConnectionConnector", "Exception " + e);
			e.printStackTrace();
			PRINT_STACK_TRACE;
			postResultEvent(CONNOP_CONNECT, CONNERR_GENERIC);
			return;
		}
	}
} // End of class BluetoothConnectionInformation
#endif // _ANDROID_BLUETOOTH

class HttpConnectionConnector implements Runnable 
{
	ConnectionInformation mConn;

	HttpConnectionConnector(ConnectionInformation conn) 
	{
		mConn = conn;
	}

	public final void run()
	{
		try
		{
			int result = 1;
			if (mConn.mIsHttpConnection)
			{
				mConn.mConnection.connect();
			
				HttpURLConnection http = (HttpURLConnection) mConn.mConnection;
				
				result = http.getResponseCode();
				if (result <= 0)
				{
					DUMP(result);
					result = CONNERR_PROTOCOL;
				}
				else
				{
#ifndef PHONE_RELEASE
					//dump headers
					int i = 0;
					while (true)
					{
						String key = mConn.mConnection.getHeaderFieldKey(i);
						String value = mConn.mConnection.getHeaderField(i);
						DEBUG_ALWAYS(key + ": " + value + "\n");
						if(key == null && value == null)
						{
							break;
						}
						i++;
					}
#endif
					mConn.mHttpState = HTTP_STATE_FINISHED;
				}
			}
			if (mConn.mIsSocketConnection)
			{
				Log.i("Connector","connection to socket");
				mConn.mSocket = new Socket(mConn.mSocketAddress, mConn.mSocketPort);
				Log.i("Connector","connection returned");
				
				if (mConn.mSocket.isConnected())
				{
					mConn.mHttpState = HTTP_STATE_FINISHED;
				}
				else
				{
					result = CONNERR_GENERIC;
				}
			}
			synchronized(mConn) 
			{
				if (mConn.mCancelled) 
				{
					mConn.postResultEvent(CONNOP_CONNECT, CONNERR_CANCELED);
					return;
				}
			}
			mConn.postResultEvent(CONNOP_CONNECT, result);
		}
		catch (InterruptedIOException e)
		{
			PRINT_STACK_TRACE;
			mConn.postResultEvent(CONNOP_CONNECT, CONNERR_CANCELED);
			return;
		}
		catch (IOException e)
		{
			PRINT_STACK_TRACE;
			mConn.postResultEvent(CONNOP_CONNECT, CONNERR_GENERIC);
			return;
		}
	}
}

/**
 * Class that reads or writes data. 
 * TODO: It should be renamed, because it is a general class
 * used for all connection types.
 * Make two methods from this class in ConnectionInformation:
 * doRead and doWrite, and call from thread (Runnable anon class).
 */
class HttpConnectionRunner implements Runnable 
{
	ConnectionInformation mConn;

	HttpConnectionRunner(ConnectionInformation conn)
	{
		mConn = conn;
	}

	public final void run() 
	{
		int opType = -1;
		try
		{
			if (mConn.mReadData == true) // Read data
			{
				int result = -1;
				int opResult;
				opType = CONNOP_READ;
				
				byte[] bytes = new byte[mConn.mSize];
				result = mConn.mIs.read(bytes);
				
				if (mConn.mUseResource == true) // store in resource 
				{
					Log.i("HttpConnectionRunner","Read to resource");
					
					// READ DATA DIRECTLY INTO A RESOURCE

					mConn.mByteBuffer.position(0);
					mConn.mByteBuffer.put(bytes, 0, result);
				
					//result = mConn.mIs.read(mConn.mBinary.arr, mConn.mOffset, mConn.mSize);
				}
				else // store in memory
				{
					Log.i("HttpConnectionRunner","Read to memory");
					
					if (result > 0)
					{
						// WRITE THE DATA IN BUFFER bytes TO MEMORY AT ADDRESS mConn.mMemory
						
						mMemDataSection.mark();
						mMemDataSection.position((int)mConn.mMemory);
						mMemDataSection.put(bytes, 0, result);
						mMemDataSection.reset();
						
						opResult = result;
					}
				}
				
				// success
				if (result > 0)
				{
					opResult = result;
				}
				else if (result == -1) 
				{
					opResult = CONNERR_CLOSED;
				} 
				else 
				{
					DEBUG_ALWAYS("ConnRead error "+result+"!\n");
					opResult = CONNERR_INTERNAL;
				}
				
				/*
					Restore resource from flux
				*/
				//setResource(mConn.mData, mConn.mBinary);
				
				mConn.postResultEvent(opType, opResult);
				return;
			}
			else // Write data
			{
				opType = CONNOP_WRITE;
				if (mConn.mUseResource == true) // resource
				{
					Log.i("HttpConnectionRunner","Send from resource");
					/*
					if(mConn.mBinary instanceof Binary) {
						Binary bin = (Binary)mConn.mBinary;
						
						mConn.mOs.write(bin.arr, mConn.mOffset, mConn.mSize);
					} else {
						byte[] buffer = new byte[mConn.mSize];
						DataInputStream dis = new DataInputStream(mConn.mBinary.getInputStream());
						dis.readFully(buffer);
						dis.close();
						
						mConn.mOs.write(buffer);
					}
					*/
					
					// WRITE DATA DIRECTLY TO THE STREAM FROM mConn.ByteBuffer
					
				}
				else // memory
				{
					Log.i("HttpConnectionRunner","Send from memory");
					SYSLOG("memstart:" + (int)mConn.mMemory + " size:" + mConn.mSize + " datasize:" + mMemDataSection.capacity());
					
					// WRITE DATA DIRECTLY TO THE STREAM FROM memory at position mConn.mMemory
					
					byte[] data = new byte[mConn.mSize];
					mMemDataSection.mark();
					mMemDataSection.position((int)mConn.mMemory);
					mMemDataSection.get(data);
					mMemDataSection.reset();
					
					mConn.mOs.write(data);
					
					//readMemStream(mConn.mOs, mConn.mMemory, mConn.mSize);
				}
				
				//success
				
				/*
					Restore resource from flux
				*/
				//setResource(mConn.mData, mConn.mBinary);
				
				mConn.postResultEvent(opType, 1);
				return;
			}	
		}
		catch (InterruptedIOException e)
		{
			SYSLOG("InterruptedIOException e:" + e.toString());
			PRINT_STACK_TRACE;
			mConn.postResultEvent(opType, CONNERR_CANCELED);
			return;
		}
		catch (IOException e)
		{
			SYSLOG("IOException e:" + e.toString());
			PRINT_STACK_TRACE;
			mConn.postResultEvent(opType, CONNERR_GENERIC);
			return;
		}
		catch (Exception e)
		{
			SYSLOG("Exception e:" + e.toString());
			PRINT_STACK_TRACE;
			mConn.postResultEvent(opType, CONNERR_GENERIC);
			return;
		}
	}
}

class HttpConnectionFinish implements Runnable
{
	ConnectionInformation mConn;

	HttpConnectionFinish(ConnectionInformation conn)
	{
		mConn = conn;
	}

	public final void run() 
	{
		HttpURLConnection httpConn = (HttpURLConnection) mConn.mConnection;
		try 
		{
			if (mConn.mOs != null) 
			{
				mConn.mOs.close();
				mConn.mOs = null;
			}
			
			int result = httpConn.getResponseCode();
			if (result <= 0) 
			{
				DUMP(result);
				result = CONNERR_PROTOCOL;
			} 
			else 
			{
//#ifndef PHONE_RELEASE
				//dump headers
				int i = 0;
				while (true) 
				{
					String key = mConn.mConnection.getHeaderFieldKey(i);
					String value = mConn.mConnection.getHeaderField(i);
					DEBUG_ALWAYS(key + ": " + value + "\n");
					if (key == null && value == null)
					{
						break;
					}
					i++;
				}
//#endif
				mConn.mHttpState = HTTP_STATE_FINISHED;
			}
			mConn.postResultEvent(CONNOP_FINISH, result);
		} 
		catch (InterruptedIOException e) 
		{
			PRINT_STACK_TRACE;
			mConn.postResultEvent(CONNOP_FINISH, CONNERR_CANCELED);
		} 
		catch (IOException e) 
		{
			PRINT_STACK_TRACE;
			mConn.postResultEvent(CONNOP_FINISH, CONNERR_GENERIC);
		}
	}
}

/*
class SocketConnectionRunner implements Runnable 
{
	ConnectionInformation mConn;

	SocketConnectionRunner(ConnectionInformation conn)
	{
		mConn = conn;
	}

	public final void run() {

		int opType = -1;
		try
		{
			if(mConn.mReadData == true) // Read data
			{
				int result = -1;
				int opResult;
				opType = CONNOP_READ;
				
				if(mConn.mUseResource == true) // store in resource 
				{
					Log.i("HttpConnectionRunner","Read to resource");
					result = mConn.mIs.read(mConn.mBinary.arr, mConn.mOffset, mConn.mSize);
				}
				else // store in memory
				{
					Log.i("HttpConnectionRunner","Read to memory");
					byte[] bytes = new byte[mConn.mSize];
					result = mConn.mIs.read(bytes);
					if(result > 0)
					{
						writeMemBytes(mConn.mMemory, bytes, 0, result);
						opResult = result;
					}
				}
				
				// success
				if(result > 0)
				{
					opResult = result;
				}
				else if(result == -1) {
					opResult = CONNERR_CLOSED;
				} else {
					DEBUG_ALWAYS("ConnRead error "+result+"!\n");
					opResult = CONNERR_INTERNAL;
				}
				
				setResource(mConn.mData, mConn.mBinary);
				mConn.postResultEvent(opType, opResult);
				return;
			}
			else // Write data
			{
				opType = CONNOP_WRITE;
				if(mConn.mUseResource == true) // resource
				{
					Log.i("HttpConnectionRunner","Send from resource");
					if(mConn.mBinary instanceof Binary) {
						Binary bin = (Binary)mConn.mBinary;
						mConn.mOs.write(bin.arr, mConn.mOffset, mConn.mSize);
					} else {
						byte[] buffer = new byte[mConn.mSize];
						DataInputStream dis = new DataInputStream(mConn.mBinary.getInputStream());
						dis.readFully(buffer);
						dis.close();
						mConn.mOs.write(buffer);
					}
				}
				else // memory
				{
					Log.i("HttpConnectionRunner","Send from memory");
					readMemStream(mConn.mOs, mConn.mMemory, mConn.mSize);
				}
				
				//success
				setResource(mConn.mData, mConn.mBinary);
				mConn.postResultEvent(opType, 1);
				return;
			}	
		}
		catch(InterruptedIOException e)
		{
			PRINT_STACK_TRACE;
			mConn.postResultEvent(opType, CONNERR_CANCELED);
			return;
		}
		catch(IOException e)
		{
			PRINT_STACK_TRACE;
			mConn.postResultEvent(opType, CONNERR_GENERIC);
			return;
		}
		
	}
}
*/

/*
class BluetoothConnectionConnector implements Runnable 
{
	BluetoothConnectionInformation mConnectionInfo;

	BluetoothConnectionConnector(BluetoothConnectionInformation connectionInfo) 
	{
		mConnectionInfo = connectionInfo;
	}

	public void run()
	{
		try
		{
			String address = mConnectionInfo.getDeviceAddress();
			BluetoothAdapter adapter = btGetBluetoothAdapter();
			if (null == adapter)
			{
				mConnectionInfo.postResultEvent(CONNOP_CONNECT, CONNERR_GENERIC);
				return;
			}
			BluetoothDevice device = btGetBluetoothAdapter().getRemoteDevice(address);
			if (null == device)
			{
				mConnectionInfo.postResultEvent(CONNOP_CONNECT, CONNERR_GENERIC);
				return;
			}
			
			Method createRfcommSocket = device.getClass().getMethod(
				"createRfcommSocket", 
				new Class[] { int.class });
			if (null == createRfcommSocket)
			{
				mConnectionInfo.postResultEvent(CONNOP_CONNECT, CONNERR_GENERIC);
				return;
			}
			
			BluetoothSocket socket = (BluetoothSocket) createRfcommSocket.invoke(
				device, 
				mConnectionInfo.getChannel());
			if (null == socket)
			{
				mConnectionInfo.postResultEvent(CONNOP_CONNECT, CONNERR_GENERIC);
				return;
			}
			
			socket.connect();
			
			mConnectionInfo.setSocket(socket);
			
			Log.i("@@BluetoothConnectionConnector","connection to Bluetooth socket made");
			
			int success = 1;
			mConnectionInfo.postResultEvent(CONNOP_CONNECT, success);
		}
		catch (InterruptedIOException e)
		{
			PRINT_STACK_TRACE;
			mConnectionInfo.postResultEvent(CONNOP_CONNECT, CONNERR_CANCELED);
			return;
		}
		catch (IOException e)
		{
			PRINT_STACK_TRACE;
			mConnectionInfo.postResultEvent(CONNOP_CONNECT, CONNERR_GENERIC);
			return;
		}
		catch (Exception e)
		{
			PRINT_STACK_TRACE;
			mConnectionInfo.postResultEvent(CONNOP_CONNECT, CONNERR_GENERIC);
			return;
		}
	}
}
*/


