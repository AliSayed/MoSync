/* Copyright (C) 2009 Mobile Sorcery AB

This program is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License, version 2, as published by
the Free Software Foundation.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
for more details.

You should have received a copy of the GNU General Public License
along with this program; see the file COPYING.  If not, write to the Free
Software Foundation, 59 Temple Place - Suite 330, Boston, MA
02111-1307, USA.
*/

package com.mosync.java.android;

#include "syscall_helpers.h"
#include "generated\MAAPI_consts.h"
#include "config_platform.h"
#include "helpers.h"

import android.content.Context;
import android.graphics.*;
import android.os.Handler;
import android.os.Process;
import android.view.SurfaceView;
import android.view.SurfaceHolder;
import android.util.Log;
import android.view.KeyEvent;
import android.view.MotionEvent;

import java.util.Vector;
import java.util.Timer;
import java.util.TimerTask;

public class MoSyncView extends SurfaceView implements SurfaceHolder.Callback
{

	class MoSyncThread extends Thread
	{
		private Context mContext;
		private Handler mHandler;
		private MoSyncView mMoSyncView;
		private SurfaceHolder mSurfaceHolder;
		private Core mCore;
		private int mWidth;
		private int mHeight;
		
		private boolean mStop;
		
		public MoSyncThread(SurfaceHolder surfaceHolder, Context context, Handler handler, MoSyncView view) throws Exception
		{	
			mSurfaceHolder = surfaceHolder;
			mContext = context;
			mHandler = handler;
			mMoSyncView = view;
			
			Log.i("MoSync Thread", "Constructor");
		 
			try
			{
				mCore = new Core(mMoSyncView, 
						mContext.getResources().openRawResource(R.raw.program),
						mContext.getResources().openRawResource(R.raw.resources));
			}
			catch(Exception e)
			{
				Log.e("MoSync Thread","Core creation exception: " + e.toString());
				throw(e);
			}
		}
		
		public void updateSurfaceSize(int width, int height)
		{
			Log.i("MoSync Thread","updateSurfaceSize");
			mWidth = width;
			mHeight = height;
			mCore.resizeScreen(mWidth, mHeight);
		}
		
		public boolean stopNow()
		{
			if(mStop == true) return false;
			Log.i("MoSync Thread","stopNow");
			mStop = true;
			return true;
		}
		
		@Override public void run()
		{
			Log.i("MoSync Thread", "run");
			
			while(true)
			{
				try
				{
					mStop = false;
#ifndef PHONE_RELEASE
					mCore.mInstCount = 0;
#endif
					long startTime = System.currentTimeMillis();
					while(!mStop)
					{
						mCore.mIP = mCore.run();
					}
					long time = System.currentTimeMillis() - startTime;
					if(time == 0) time++;
#ifndef PHONE_RELEASE						
					Log.i("MoSync Thread",""+mCore.mInstCount+" instructions in "+time+" ms: "+ (((double)mCore.mInstCount) / time)+" KIPS\n");
#endif
				} catch(Throwable e) {
					Log.i("MoSync Thread","Thread crashed! " + e.toString());
					break;
				}
			}
			
			Log.i("MoSync Thread", "loop has ended");
		}
		
		class WaitTask extends TimerTask {
			private final int mSequence;
			WaitTask(int sequence) {
				mSequence = sequence;
			}
			public final void run() {
				if(mSequence != mWaitSequence)
					return;
				FinishWait();
			}
		}

		synchronized public final void Wait(int timeout) {
			if(mEventBuffer.size() > 0)
				return;
			YIELD;
			if(timeout > 0) {
				mTimer.schedule(new WaitTask(mWaitSequence), timeout);
			}
			stop();
		}
		
		synchronized private final void FinishWait() {
			if(!mStop)
				return;
			mStop = false;
			try {
				mWaitSequence++;
				this.notify();
			} catch(Exception e) {
				IN_FILE_ON_LINE;
				PRINT_STACK_TRACE;
			}
		}
	}
	
	/** Handle to the application context, used to e.g. fetch Drawables. */
	private Context mContext;
	public SurfaceHolder mSurfaceHolder;
	
	private Vector mEventBuffer = new Vector(EVENT_BUFFER_SIZE);
	private boolean mEventOverflow = false;
	private int mWaitSequence = 0;
	Timer mTimer = new Timer();
	
	/** The thread that actually draws the animation */
	private MoSyncThread thread;

	private int mKeyState;
	
	public MoSyncView(Context context) throws Exception
	{
		super(context);
		mContext = context;
		
		// register our interest in hearing about changes to our surface
		mSurfaceHolder = getHolder();
		    
		// Use accelerated surfaces if available
		int mode = 0;
		try {
			mode = 1;
			mSurfaceHolder.setType(android.view.SurfaceHolder.SURFACE_TYPE_HARDWARE);
		} catch(Exception e) {
			try {
				mode = 2;
				mSurfaceHolder.setType(android.view.SurfaceHolder.SURFACE_TYPE_GPU);
			} catch(Exception e2) {
				mSurfaceHolder.setType(android.view.SurfaceHolder.SURFACE_TYPE_NORMAL);
				// if this didn't work we can do nothing...
			}
		}

#ifdef PUBLIC_DEBUG
		switch(mode)
		{
			case 1: Log.i("MoSync", "Hardware accelerated surface"); break;
			case 2: Log.i("MoSync", "GPU accelerated surface"); break;
			default: Log.i("MoSync", "No hardware acceleration available");
		}
#endif // PUBLIC_DEBUG
		
		mSurfaceHolder.addCallback(this);    
		
		// create thread only; it's started in surfaceCreated()
		thread = new MoSyncThread(mSurfaceHolder, mContext, new Handler() {}, this);
		setVisibility(VISIBLE);
		// make sure we get key events
		setFocusableInTouchMode(true);
	}
	
	public void stopThread()
	{
		Log.i("MoSync View","stopThread");
		if(thread.isAlive())
		{
			boolean stopped = thread.stopNow();
			if(!stopped)
			{
				boolean retry = true;
				while (retry) {
					try {
						thread.join();
						retry = false;
					} catch (InterruptedException e) {
						Log.i("MoSync View", "stopThread InteruptedException:" + e.toString() + "/n");
					}
				}
			}
		}
	}
	
	public void killApplication()
	{
		stopThread();
		Process.killProcess(Process.myPid());
	}

	@Override protected void onDraw(Canvas canvas)
	{
	  Log.i("MoSync View","onDraw");
	}

	/*
	* Called when surface has changed
	*/
	public void surfaceChanged(SurfaceHolder holder, int format, int width, int height)
	{
		Log.i("MoSync View", "surfaceChanged");
		thread.updateSurfaceSize(width, height);
	}

	/*
	 * Called when surface has been created
	 */
	public void surfaceCreated(SurfaceHolder holder)
	{
		Log.i("MoSync View", "surfaceCreated");
		
		if(!thread.isAlive())
		{
			thread.updateSurfaceSize(getWidth(), getHeight());
			thread.start();
		}
		else
		{
			Log.i("MoSync View","surfaceCreated - Thread was already alive");
		}
	}

	/*
	* Called when the surface has destroyed.
	 */
	public void surfaceDestroyed(SurfaceHolder holder)
	{
		Log.i("MoSync View", "surfaceDestroyed");
		stopThread();
	}

	private final int convertToMoSyncKeyCode(int keyCode) {
#define CONVERT_KEYCODE(k) if(keyCode == KeyEvent.KEYCODE_##k) return MAK_##k;
#define CONVERT_DPAD_KEYCODE(k) if(keyCode == KeyEvent.KEYCODE_DPAD_##k) return MAK_##k;
#define CONVERT_SPECIAL(kIn, kOut) if(keyCode == KeyEvent.KEYCODE_##kIn) return MAK_##kOut;
		DEVICE_KEYS(CONVERT_KEYCODE);
		DEVICE_DPAD_KEYS(CONVERT_DPAD_KEYCODE);
		DEVICE_SPECIAL(CONVERT_SPECIAL);
		return 0;
	}
	
		private final int convertToMoSyncKeyByteCode(int keyCode) {
#define CONVERT_KEYCODEB(k) if(keyCode == KeyEvent.KEYCODE_##k) return MAKB_##k;
#define CONVERT_DPAD_KEYCODEB(k) if(keyCode == KeyEvent.KEYCODE_DPAD_##k) return MAKB_##k;
#define CONVERT_SPECIALB(kIn, kOut) if(keyCode == KeyEvent.KEYCODE_##kIn) return MAKB_##kOut;
		DEVICE_KEYS(CONVERT_KEYCODEB);
		DEVICE_DPAD_KEYS(CONVERT_DPAD_KEYCODEB);
		DEVICE_SPECIAL(CONVERT_SPECIALB);
		return 0;
	}
	
	public boolean onKeyUp(int keyCode, KeyEvent keyEvent)
	{
		Log.i("MoSyncView", "key up event :" + keyEvent.toString() + "/n");
		int convertedKeyCode = convertToMoSyncKeyCode(keyCode);
		Log.i("MoSyncView", "android key :" + keyCode + " - MoSync key :" + convertedKeyCode + "/n");
		
		int[] event = new int[2];
		mKeyState &= ~convertToMoSyncKeyByteCode(keyCode);
		
		EI_TYPE = EVENT_TYPE_KEY_RELEASED;
		EI_KEY = convertedKeyCode;
		postEvent(event);
		
		return true;
	}
	
	public boolean onKeyDown(int keyCode, KeyEvent keyEvent)
	{
		Log.i("MoSyncView", "key down event :" + keyEvent.toString() + "/n");
		int convertedKeyCode = convertToMoSyncKeyCode(keyCode);
		Log.i("MoSyncView", "android key :" + keyCode + " - MoSync key :" + convertedKeyCode + "/n");
			
		int[] event = new int[2];
		mKeyState |= convertToMoSyncKeyByteCode(keyCode);
		
		EI_TYPE = EVENT_TYPE_KEY_PRESSED;
		EI_KEY = convertedKeyCode;
		postEvent(event);
		
		return true;
	}
	
	public int getKeys() {
		return mKeyState;
	}
	
	public boolean onTouchEvent(MotionEvent motionEvent)
	{
		int action = motionEvent.getAction();
/*		
		int[] event = new int[3];
		EI_TYPE = EVENT_TYPE_POINTER_RELEASED;
		EI_POINTX = x;
		EI_POINTY = y;
		
		switch(motionEvent.getAction())
		{
			case 0:
				Log.i("MoSync View", "pointer pressed x:" + x + " y:" + y + "/n");
				EI_TYPE = EVENT_TYPE_POINTER_PRESSED;
				break;
			case 1:
				Log.i("MoSync View", "pointer released x:" + x + " y:" + y + "/n");
				EI_TYPE = EVENT_TYPE_POINTER_RELEASED;
				break;
			case 2:
				Log.i("MoSync View", "pointer dragged x:" + x + " y:" + y + "/n");
				EI_TYPE = EVENT_TYPE_POINTER_DRAGGED;
				break;
			dafault:
				return false;
		}
*/		
		return true;
	}
/*	
	protected final void pointerPressed(int x, int y) {
		DEBUG_TEMP("pointerPressed "+x+" "+y+"\n");
		int[] event = new int[3];
		EI_TYPE = EVENT_TYPE_POINTER_PRESSED;
		EI_POINTX = x;
		EI_POINTY = y;
		postEvent(event);
	}
	
	protected final void pointerReleased(int x, int y) {
		DEBUG_TEMP("pointerReleased "+x+" "+y+"\n");
		int[] event = new int[3];
		EI_TYPE = EVENT_TYPE_POINTER_RELEASED;
		EI_POINTX = x;
		EI_POINTY = y;
		postEvent(event);	
	}
	
	protected final void pointerDragged(int x, int y) {
		DEBUG_TEMP("pointerDragged "+x+" "+y+"\n");
		int[] event = new int[3];
		EI_TYPE = EVENT_TYPE_POINTER_DRAGGED;
		EI_POINTX = x;
		EI_POINTY = y;
		postEvent(event);
	}
*/	
	synchronized public final int[] getEvent() {
		if(mEventBuffer.isEmpty()) {
			return null;
		}
		int[] event = (int[]) mEventBuffer.firstElement();
		mEventBuffer.removeElementAt(0);
		return event;
	}
	
	synchronized public final void postEvent(int[] event) {
		if(!mEventOverflow) {
			if(mEventBuffer.size() + 1 == EVENT_BUFFER_SIZE) {	//leave space for Close event
				mEventOverflow = true;
				mEventBuffer.removeAllElements();
//				DEBUG("EventBuffer overflow!\n");
			}
			mEventBuffer.addElement(event);
		}
		thread.FinishWait();
	}

	protected void postFocusLostEvent() {
		int[] event = new int[1];
		event[0] = EVENT_TYPE_FOCUS_LOST;
		postEvent(event);
	}

	protected void postFocusGainedEvent() {
		int[] event = new int[1];
		event[0] = EVENT_TYPE_FOCUS_GAINED;
		postEvent(event);
	}
	
/*	
	
	private final void handleKeyEvent(int keyCode, boolean released) {
#ifdef PUBLIC_DEBUG
		try {
#endif
			int mak = convertKeyCode(keyCode);
			if(mak != 0) {
				int[] event = new int[2];
				if(released == true) {
					mKeyState &= ~convertKeyBit(keyCode);
				} else {
					mKeyState |= convertKeyBit(keyCode);				
				}

				EI_TYPE = released ? EVENT_TYPE_KEY_RELEASED : EVENT_TYPE_KEY_PRESSED;
				EI_KEY = mak;
				postEvent(event);
			}
#ifdef PUBLIC_DEBUG
		} catch(Exception e) {
			PRINT_STACK_TRACE;
			MAMidlet.self.programError("Key error", e);
		}
#endif
	}

	synchronized public final void postEvent(int[] event) {
		if(!mEventOverflow) {
			if(mEventBuffer.size() + 1 == EVENT_BUFFER_SIZE) {	//leave space for Close event
				mEventOverflow = true;
				mEventBuffer.removeAllElements();
				DEBUG("EventBuffer overflow!\n");
			}
			mEventBuffer.addElement(event);
		}
		FinishWait();
	}

	public int getKeys() {
		return mKeyState;
	}

	protected final void pointerPressed(int x, int y) {
		DEBUG_TEMP("pointerPressed "+x+" "+y+"\n");
		int[] event = new int[3];
		EI_TYPE = EVENT_TYPE_POINTER_PRESSED;
		EI_POINTX = x;
		EI_POINTY = y;
		postEvent(event);
	}
	
	protected final void pointerReleased(int x, int y) {
		DEBUG_TEMP("pointerReleased "+x+" "+y+"\n");
		int[] event = new int[3];
		EI_TYPE = EVENT_TYPE_POINTER_RELEASED;
		EI_POINTX = x;
		EI_POINTY = y;
		postEvent(event);	
	}
	
	protected final void pointerDragged(int x, int y) {
		DEBUG_TEMP("pointerDragged "+x+" "+y+"\n");
		int[] event = new int[3];
		EI_TYPE = EVENT_TYPE_POINTER_DRAGGED;
		EI_POINTX = x;
		EI_POINTY = y;
		postEvent(event);
	}
		
	synchronized protected final void keyPressed(int keyCode) {
		DEBUG_KEYS("keyPressed "+keyCode+"\n");
		handleKeyEvent(keyCode, false);
	}
	synchronized protected final void keyReleased(int keyCode) {
		DEBUG_KEYS("keyReleased "+keyCode+"\n");
		handleKeyEvent(keyCode, true);
	}
*/

}
