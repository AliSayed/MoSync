/*
Copyright (C) 2011 MoSync AB

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License,
version 2, as published by the Free Software Foundation.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
MA 02110-1301, USA.
*/

/**
 * @file WebViewLoveSMS.cpp
 * @author Mikael Kindborg
 *
 * Application for sending Love SMSs.
 *
 * This program illustrates how to use WebView for the
 * user interface of a MoSync C++ application.
 *
 * An application can divide the program code between the
 * WebView layer and the C++ layer in a variety of ways.
 * In one extreme, the WebView is used purely for
 * rendering the user interface, the HTML/CSS/JavaScript
 * code could even be generated by C++ code. In the other
 * extreme, almost the entire application is written in
 * HTML/CSS/JavaScript, and only the calls needed to access
 * native functionality via the MoSync API is written in C++.
 *
 * Which approach is chosen depends on the preferences of the
 * development team, existing code and libraries, compatibility
 * considerations etc. Some teams may prefer to be C++ centric,
 * white others may prefer to do most of the development using
 * JavScript and web technologies.
 *
 * In this application, much of the application logic is written
 * in JavaScript, and the C++ layer is used for sending text
 * messages and for saving/loading the phone number entered
 * in the user interface. There is only one phone number saved,
 * because, after all, this is an application to be used with
 * your loved one. ;-)
 */

#include <ma.h>					// MoSync API (base API).
#include <maheap.h>				// C memory allocation functions.
#include <mastring.h>			// C String functions.
#include <mavsprintf.h>			// sprintf etc.
#include <MAUtil/Moblet.h>		// Class Moblet.
#include <MAUtil/String.h>		// Class String.
#include <NativeUI/FileUtil.h>	// File utility functions.
#include <NativeUI/Screen.h>	// The Screen widget.
#include <NativeUI/WebView.h>	// The WebView widget.
#include <NativeUI/WebViewListener.h>	// WebView event listener.
#include <NativeUI/WebViewMessage.h>	// JavaScript to C++ messages.

using namespace MAUtil;
using namespace NativeUI;

/**
 * Set to true to actually send SMS.
 * You can turn off SMS sending during debugging
 * by setting this variable to false.
 */
static bool sSendSMSForReal = true;

// Forward declaration.
class LoveSMSWebViewListener;

/**
 * The application class.
 */
class LoveSMSMoblet : public Moblet
{
public:
	LoveSMSMoblet()
	{
		extractFileSystem();
		createUI();
	}

	virtual ~LoveSMSMoblet()
	{
		// Deleting the root widget will also delete child widgets.
		delete mScreen;

		// Delete the file utility object.
		delete mFileUtil;
	}

	void extractFileSystem()
	{
		// Create file utility object.
		mFileUtil = FileUtil::create();

		// Extract bundled files to the local file system.
		mFileUtil->extractLocalFiles();
	}

	void createUI()
	{
		// Create and configure the WebView.
		WebView* webView = new WebView();
		webView->fillSpaceHorizontally();
		webView->fillSpaceVertically();
		webView->disableZoom();
		webView->enableWebViewMessages();
		webView->openURL("PageMain.html");

		// Create and show the screen that holds the WebView.
		Screen* screen = new Screen();
		screen->setMainWidget(webView);
		screen->show();
	}

	/**
	 * This method is called when a key is pressed, and closes
	 * the application when the back key (on Android) is pressed.
	 */
	void keyPressEvent(int keyCode, int nativeCode)
	{
		if (MAK_BACK == keyCode)
		{
			// Call close to exit the application.
			close();
		}
	}

	/**
	 * SMS events are handled as custom events in the moblet.
	 */
	void customEvent(const MAEvent& event)
	{
		switch (event.type)
		{
			case EVENT_TYPE_SMS:
				// Depending on the event status, we call
				// different JavaScript functions. These are
				// currently hard-coded, but could be passed
				// as parameters to decouple the JavaScript
				// code from the C++ code.
				if (MA_SMS_RESULT_SENT == event.status)
				{
					callJSFunction("SMSSent");
				}
				else if (MA_SMS_RESULT_NOT_SENT == event.status)
				{
					callJSFunction("SMSNotSent");
				}
				else if (MA_SMS_RESULT_DELIVERED == event.status)
				{
					callJSFunction("SMSDelivered");
				}
				else if (MA_SMS_RESULT_NOT_DELIVERED == event.status)
				{
					callJSFunction("SMSNotDelivered");
				}
				break;
		}
	}

	/**
	 * Here we handle messages sent from JavaScript.
	 */
	void handleWebViewMessage(WebViewMessage& message)
	{
		if (message.is("SendSMS"))
		{
			// Save phone no and send SMS.
			savePhoneNoAndSendSMS(
				message.getParam(0),
				message.getParam(1));
		}
		else if (message.is("PageLoaded"))
		{
			// Load and set saved phone number.
			// We could implement a JavaScript File API to do
			// this, which would be a much more general way.
			setSavedPhoneNo();
		}
	}

	void savePhoneNoAndSendSMS(
		const String& phoneNo,
		const String&  message)
	{
		lprintfln("*** SMS to: %s\n", phoneNo.c_str());
		lprintfln("*** SMS data: %s\n", message.c_str());

		// Save the phone number.
		savePhoneNo(phoneNo);

		if (sSendSMSForReal)
		{
			// Send the message.
			int result = maSendTextSMS(
				phoneNo.c_str(),
				message.c_str());

			// Provide feedback via JS.
			if (0 != result)
			{
				callJSFunction("SMSNotSent");
			}
		}
		else
		{
			callJSFunction("SMSNotSent");
		}
	}

	/**
	 * Read saved phone number and set it on
	 * the JavaScript side.
	 */
	void setSavedPhoneNo()
	{
		char script[512];
		sprintf(
			script,
			"SetPhoneNo('%s')",
			loadPhoneNo().c_str());
		callJS(script);
	}

	/**
	 * Save the phone number.
	 */
	void savePhoneNo(const String& phoneNo)
	{
		mFileUtil->writeTextToFile(phoneNoPath(), phoneNo);
	}

	/**
	 * Load the phone number.
	 */
	String loadPhoneNo()
	{
		MAUtil::String phoneNo;
		bool success = mFileUtil->readTextFromFile(phoneNoPath(), phoneNo);
		if (success)
		{
			return phoneNo;
		}
		else
		{
			return "";
		}
	}

	String phoneNoPath()
	{
		return mFileUtil->getLocalPath() + "SavedPhoneNo";
	}

	/**
	 * Call a JavaScript function.
	 */
	void callJSFunction(const String& fun)
	{
		char code[512];
		sprintf(code, "%s()", fun.c_str());
		mWebView->callJS(code);
	}

	/**
	 * Run JavaScript code.
	 */
	void callJS(const String& script)
	{
		mWebView->callJS(script);
	}

private:
	/**
	 * The screen widget that is the root of the UI.
	 */
	Screen* mScreen;

	/**
	 * The WebView widget that displays the application UI.
	 */
	WebView* mWebView;

	/**
	 * File utility object.
	 */
	FileUtil* mFileUtil;
};
// End of class LoveSMSMoblet

/**
 * Class that listens for WebView events.
 * Here we receive messages from JavScript.
 */
class LoveSMSWebViewListener : public WebViewListener
{
public:
	/**
	 * Constructor that saves the pointer to the
	 * application moblet.
	 */
	LoveSMSWebViewListener(LoveSMSMoblet* moblet)
	{
		mMoblet = moblet;
	}

	/**
	 * This method is called when a "mosync://" url is
	 * invoked in the WebView.
	 */
    virtual void webViewHookInvoked(
		WebView* webView,
		int hookType,
		MAHandle urlData)
    {
		// Create message object
		WebViewMessage message(urlData);

		// Let the moblet handle the message.
		mMoblet->handleWebViewMessage(message);

		// Deallocate the url data. Note that this is
		// very important to do, as memory will get
		// consumed otherwise. Each hook invoked event
		// allocates a new data object with the url data.
		maDestroyObject(urlData);
    }

    // TODO: Remove when made non-abstract.
    virtual void webViewContentLoading(
		WebView* webView,
		const int webViewState)
    {
    }

private:
    /**
     * Pointer to the application moblet.
     */
    LoveSMSMoblet* mMoblet;
};
// End of class LoveSMSWebViewListener

/**
 * Main function that is called when the program starts.
 * This function needs to be declared as extern "C".
 */
extern "C" int MAMain()
{
	Moblet::run(new LoveSMSMoblet());
	return 0;
}
